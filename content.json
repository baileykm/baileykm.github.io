{"meta":{"title":"Bailey's Blog","subtitle":"歌唱吧, 像没有人聆听一样...","description":null,"author":"Bailey","url":"https://baileykm.github.io"},"pages":[{"title":"categories","date":"2018-04-20T18:10:12.000Z","updated":"2018-04-20T18:10:12.000Z","comments":true,"path":"categories/index.html","permalink":"https://baileykm.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-20T18:14:08.000Z","updated":"2018-04-20T18:14:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://baileykm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实例教程 - 在线账本 (三)","slug":"实例教程-在线账本-3","date":"2019-05-14T15:59:28.000Z","updated":"2019-05-17T08:07:50.338Z","comments":true,"path":"2019/05/14/实例教程-在线账本-3/","link":"","permalink":"https://baileykm.github.io/2019/05/14/实例教程-在线账本-3/","excerpt":"本节为系列教程的第三部分: 真正的在线记账本: 客户端 + 服务器 + 数据库. 经过前两节的努力, 我们已经实现了一个客户端+服务器模式的在线记账本, 但记账数据并未保存到数据库, 当服务端重启数据将丢失, 本节我们将实现将数据保存到数据库, 实现一个真正意义上的 “在线记账本”.","text":"本节为系列教程的第三部分: 真正的在线记账本: 客户端 + 服务器 + 数据库. 经过前两节的努力, 我们已经实现了一个客户端+服务器模式的在线记账本, 但记账数据并未保存到数据库, 当服务端重启数据将丢失, 本节我们将实现将数据保存到数据库, 实现一个真正意义上的 “在线记账本”. 12. 创建数据库 13. 对接数据库 13.1 准备数据库驱动 13.2 创建数据库工具类 13.3 创建数据库访问类 14. 最后一步, 大功造成! 12. 创建数据库本教程中我们使用 MySQL, 当然, 你也可以使用其它的 DBMS, 如: Microsoft SQL Server 等. 只需要使用相应的 JDBC 驱动, 并变换一个连接参数即可 (见下文). MySQL 的安装与配置就不赘述了, 问度娘~ 创建一个名为 account_book 的数据库 (Schema): 1create databae account_book; 在 account_book数据库中创建基本表 bills, 用于存储账单数据: 1234567CREATE TABLE `bills` ( `id` int(11) NOT NULL AUTO_INCREMENT, `time` datetime NOT NULL, `amount` int(11) NOT NULL, `memo` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8; 注意观察 bills 表的结构, 它们与此前我们客户端/服务器的数据模型是一致的. 13. 对接数据库13.1 准备数据库驱动我们将使用 JDBC 连接 MySQL 数据库, 所以先得 下载 MySQL 的驱动程序. 然后, 将此驱动程序文件 (.jar) 放到上节创建的 WEB-INF/lib文件夹下 ( 和上节 web-lighter 的那些 jar 文件放在一直 ) 最后, 在 IDEA 中驱动程序文件上点击右键, 在右键菜单中选择 Add As Library…, 将其添加到构建路径. 完成后的配置后的 WEB-INFO 文件夹结构大概像这样: 13.2 创建数据库工具类与数据库交互时有很多参数和步骤是相同的, 为了统一管理, 我们先来创建一个数据库工具类. Code-13.2: DBUtil.java 1234567891011121314151617181920212223package example.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBUtil &#123; // 数据库驱动程序名 final private static String driver = \"com.mysql.jdbc.Driver\"; // 数据连接地址 // 注意其中的数据库名\"account_book\" final private static String url = \"jdbc:mysql://localhost/account_book?autoReconnect=true\"; // 数据库登录名 final private static String user = \"root\"; // 数据库登录密码 final private static String password = \"1234\"; // 返回数据库连接对象 public static Connection getConnection() throws ClassNotFoundException, SQLException &#123; Class.forName(driver); return DriverManager.getConnection(url, user, password); &#125;&#125; DBUtil类将数据库连接参数信息统一保存, 此外还提供了一个公有 (public) 静态(static) 方法getConnection() 返回数据库连接对象. 这里的 DBUtil 只对取得连接对象(Connection)这一功能进行的封装. 在未来实践的过程中你可能会意识到可以把更多的功能 (如: 执行查询/更新) 封装到 DBUtil 里. 注意: 第 12, 14, 16 行中的数据库名, 登录名, 密码改成你自己的! 13.3 创建数据库访问类现在让我们把跟数据库交互的相关操作都封装起来, 创建如下AccountBookDAO类: 对照代码中的注释慢慢看… 本人有点懒, 若前面注释过的内容, 后面再出现就没再说明了, 所以请按顺序看. Code-13.3: AccountBookDAO.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package example.dao;import example.vo.Bill;import java.sql.*;import java.util.ArrayList;import java.util.List;public class AccountBookDAO &#123; /** * 查询数据库中现有的账单 */ public List&lt;Bill&gt; queryBills() throws SQLException, ClassNotFoundException &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; List&lt;Bill&gt; bills = new ArrayList&lt;&gt;(); try &#123; // 获得数据库连接对象, 参见 Code-13.2 第 19 ~ 22 行 conn = DBUtil.getConnection(); // 创建语句(Statement)对象 stmt = conn.createStatement(); // 执行查询, 查询到的结果放在结果集(ResultSet)中 rs = stmt.executeQuery(\"select * from bills order by time desc;\"); // 将查询到的每一条账单数据打包成一个 Bill 对象, 并放入 List&lt;Bill&gt; // 参见第 110 ~ 117 行 while (rs.next()) &#123; bills.add(packBill(rs)); &#125; &#125; finally &#123; if (rs != null) rs.close(); if (stmt != null) stmt.close(); if (conn != null) conn.close(); &#125; // 返回查询结果 return bills; &#125; /** * 保存账单数据到数据库 */ public Bill saveBill(Bill bill) throws SQLException, ClassNotFoundException &#123; Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; try &#123; // 获得数据库连接对象, 参见 Code-13.2 第 19 ~ 22 行 conn = DBUtil.getConnection(); String sql = \"insert into bills(time, amount, memo) values (?, ?, ?)\"; // 这里使用了PreparedStatement, 支持参数占位符\"?\", 与第 21 行对比一下 // Statement.RETURN_GENERATED_KEYS 参数要求成功 insert 后返回此记录的主键字段值 // 注意看第 12 节中, 建表 SQL 语句中 ID 字段是\"自增长\"型(AUTO_INCREMENT) pstm = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); // 取得服务器当前系统时间 // 若要保存的信息同时含日期和时间, 必须使用 Timestamp Timestamp now = new Timestamp(System.currentTimeMillis()); // 设置 PreparedStatement 的参数, 即SQL语句中的那些\"?\" // 注意在 JDBC 中, 第 1 个参数序号是 1, 而不是 0 pstm.setTimestamp(1, now); pstm.setInt(2, bill.getAmount()); pstm.setString(3, bill.getMemo()); // 执行数据库更新操作, 将账单数据保存到数据库 pstm.executeUpdate(); // 获得数据库端生成的主键值 rs = pstm.getGeneratedKeys(); if (rs.next()) &#123; // 将主键值和账单时间写入账单数据模型 // 以保持数据模型与数据库中实际存储的数据一致 bill.setId(rs.getInt(1)); bill.setTime(now); &#125; else &#123; throw new SQLException(\"新增数据失败\"); &#125; &#125; finally &#123; if (rs != null) rs.close(); if (pstm != null) pstm.close(); if (conn != null) conn.close(); &#125; return bill; &#125; /** * 删除账单 */ public void removeBill(Bill bill) throws SQLException, ClassNotFoundException &#123; Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; try &#123; conn = DBUtil.getConnection(); String sql = \"delete from bills where id = ?\"; pstm = conn.prepareStatement(sql); pstm.setInt(1, bill.getId()); pstm.execute(); &#125; finally &#123; if (pstm != null) pstm.close(); if (conn != null) conn.close(); &#125; &#125; /** * 将 ResultSet 中的账单数据打包成 Bill 对象 */ private Bill packBill(ResultSet rs) throws SQLException &#123; Bill bill = new Bill(); bill.setId(rs.getInt(\"id\")); bill.setTime(rs.getTimestamp(\"time\")); bill.setAmount(rs.getInt(\"amount\")); bill.setMemo(rs.getString(\"memo\")); return bill; &#125;&#125; 上述AccountBookDAO实现了对账单数据进行查询/插入/删除功能的封装. 修改功能并未实现, 留给你来完成. 此外, 请注意, AccountBookDAO 与外界的接口部分转递的信息是最简单朴素的 Bill 或 List&lt;Bill&gt;. 也就是说, 我们要尽可能地让 AccountBookDAO 之外的世界不知道数据库和 JDBC 的存在, 也无需关心数据是怎么来的, 怎么保存的, 这同样是分层解耦的思想. 14. 最后一步, 大功造成!最后我们来修改 BillAction.java 中的代码, 让它来与上面定义的 AccountBookDAO 对接, 而不是对接AccountBookService. Code-14.1: BillAction.java (修改后) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package example.action;import com.bailey.web.lighter.action.ActionResult;import com.bailey.web.lighter.action.ActionSupport;import com.bailey.web.lighter.annotation.Inject;import com.bailey.web.lighter.annotation.Param;import com.bailey.web.lighter.annotation.Request;import example.dao.AccountBookDAO;import example.service.AccountBookService;import example.vo.Bill;public class BillAction extends ActionSupport &#123; // 响应前端 /wl/getBills 请求, 将账本中的所有账单记录返回前端. // 注意形参表中使用 @Inject 注解后不是AccountBookService了, 而变成 AccountBookDAO @Request(url = \"/getBills\") public ActionResult getBills(@Inject AccountBookDAO dao) &#123; try &#123; // 使用AccountBookDAO从数据库中获得所有账单数据 // ActionResult.success() 方法将账单数据封装为JSON字符串 return ActionResult.success(dao.queryBills()); &#125; catch (Exception e) &#123; // 若数据库交互异常, 向前端返回\"出错\"信息 return ActionResult.failure(); &#125; &#125; // 响应前端 /wl/saveOrUpdateBill 请求, 将账本中的所有账单记录返回前端. // 注意形参表中使用 @Inject 注解后不是AccountBookService了, 而变成 AccountBookDAO @Request(url = \"/saveOrUpdateBill\") public ActionResult saveOrUpdateBill( @Inject AccountBookDAO dao, @Param(name = \"action\") String action, @Param(name = \"bill\") Bill bill) &#123; try &#123; switch (action) &#123; case \"append\": // 插入账单数据到数据库 bill = dao.saveBill(bill); break; case \"remove\": // 删除账单 dao.removeBill(bill); break; &#125; // 将保存后的账单数据打包成 JSON 字符串返回前端 // 注意这里必须把保存后的账单信息带回前端 // 因为对于新增账单而言, 账单的ID和时间是在服务器端生成的 return ActionResult.success(bill); &#125; catch (Exception e) &#123; // 若出错, 向前端返回\"出错\"信息 return ActionResult.failure(); &#125; &#125;&#125; 再开一个浏览器窗口, 打开第 (二)节教程, 仔细对比上面的代码(Code-14.1)和原先的代码(Code-10.1)的变化. 其实, 关键的变化是我们把服务器端数据模型的交互操作从 AccountBookService 切换成了 AccountBookDAO. 这又是分层设计的优势的另一体现 ​ 重启一下服务器端 Tomcat, 浏览器里一波操作之后是不是发现数据都已经保存到数据库里了. 此时, 即使重启服务器, 你的账本数据都还好好的在那里等着你. 这才是真正的”在线记账本”! 这回大家开心了吧~ 按照惯例我们还是来小结一下: 本节内容其实不多, 只是在第(二)节基础上把数据的存储位置切换到了数据库里. 问题的关键在于: 分层松耦合的设计将使得程序变得条理清晰, 而又灵活, 在需要撤换某一层时, 低耦合的设计将使得这项工作简单且平顺地完成. 反思 AccountBookDAO.java (Code-13.3) 的代码, 你也许会发现它并不那么优雅, 甚至有点点臃肿, 乱! 比如: 那些 SQL 语句能否不用手工来写, 如果有工具能帮我们根据账单数据的变化自动生成该有多好 那个packBill()方法的作用在于把数据库查询结果 ResultSet 中的数据库封装成简单的值对象bill (VO) , 此方法里大量的代码都在做搬运工. 能否有工具能帮我们完成这个封装工作, 并维护 bill 的状态? 严格来说, 与数据库中记录对应的 Java 对象应称作持久层对象(PO, Persistant Object) 本例为了简单起见, 不想把事情搞大, 所以将就用一下此前定义的那个 VO (Value Object) 类似的问题还很多, 程序写得多了, 你就会有强烈的愿望, 想要有个东西来帮你完成与数据库交互这一层的封装,这就是所谓的持久层封装. 呵呵, 那还等什么? 继续学习ORM (Object Relational Mapping), 持久层框架 (如: Hibernate, myBatis, Cayenne…) , 它们就是你想要的. 当然, 本人推荐 Cayenne, 本博客里好几篇介绍 Cayenne 的文章. 好了, 点个关注呗~ 掌声、鲜花、小礼物走一走呗~ ​ 如果你发现此教程中有错误, 比如: 按照教程来做就是不对, 或者有些地方没有解释清楚. 麻烦你告诉我, 我改! 即使你天生丽质, 自己已经把教程中的错误搞定了, 也一定记得告诉我, 我改! 免得折腾后来的同学~","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"jQuery","slug":"jQuery","permalink":"https://baileykm.github.io/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"https://baileykm.github.io/tags/Ajax/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://baileykm.github.io/tags/Bootstrap/"}]},{"title":"实例教程 - 在线账本 (二)","slug":"实例教程-在线账本-2","date":"2019-05-14T15:27:52.000Z","updated":"2019-05-17T07:16:26.240Z","comments":true,"path":"2019/05/14/实例教程-在线账本-2/","link":"","permalink":"https://baileykm.github.io/2019/05/14/实例教程-在线账本-2/","excerpt":"此为系列教程的第二部分: 客户端 (前端) + 服务器端 (后端) 模式的在线记账本. 本节我们将在上节的基础上进一步完成服务器端的开发, 从而将我们的记账本变为前、后端贯通的 B/S 软件.","text":"此为系列教程的第二部分: 客户端 (前端) + 服务器端 (后端) 模式的在线记账本. 本节我们将在上节的基础上进一步完成服务器端的开发, 从而将我们的记账本变为前、后端贯通的 B/S 软件. 6. 搭建服务器端环境 6.1 安装 JDK 6.2 安装与配置 Tomcat 7. 创建动态 Web 项目 8. 建立服务器端账单的数据模型 9. 实现账本服务 10. 监听并分发前端请求 11. 对接服务器端 11.1 从服务器端获取账本数据 11.2 将新增账单保存到服务器端 11.3 与服务器端同步删除账单 6. 搭建服务器端环境有很多种技术可以用来实现网站的服务器端, 比如: PHP, ASP, ASP.NET, J2EE …… 这里我们选用 J2EE 技术, 可以把这样的网站称作 Java Web 应用程序. 既然是 Java Web 应用程序, 自然 JDK 的安装是少不了的, 请自行下载安装 JDK. 此外, 还需要安装一个 Java Web 容器, 我们的网站将运行在 Web 容器的世界里. 同样, Java Web 容器也有很多, 比如: Tomcat, WebLogic, WebSphere, JBOSS…. 当然, 你还得安装一个称手的集成开发环境 (IDE), 比如: Eclipse, ItelliJ IDEA. 本教程中的示例代码基于 JDK1.8 + Tomcat 8.5 测试通过 本文使用 IDE 的是 ItelliJ IDEA 准备就绪, 我们就开始吧 ~ 6.1 安装 JDK这个没什么好说的, Windows 下的 JDK 安装无非就是双击运行安装程序, 一路 “Next”, 直至 “Finish”. 只是安装过程中请关注一下你的 JDK 的安装路径, 待会需要用到. 6.2 安装与配置 Tomcat建议使用解压版的 Tomcat ( 比如上面链接下载的 Tomcat ) 找一个你中意的位置解压 Tomcat 压缩文件, 在系统变量中添加 JAVA_HOME, 值为 JDK 安装路径. 在控制台下进入 Tomcat 解压目录中的 bin 目录, 运行 startup.bat, 等待 Tomcat 启动完成. 打开浏览器, 地址栏输入 http://localhost:8080, 回车. 如果一切顺利, 你应该可以看到类似这样的页面: 看到上图的页面后 Happy 一下之后即可关闭控制台窗口. 记得关闭, 否则在下一步可能导致你创建的动态 Web 项目不能正常启动 当然, 如果你是个勤奋的孩子, 可能你的电脑上还安装了诸如 php 之类的东东, 那它们可能会抢先一步占领 Tomcat 默认使用的 8080 端口, 此时可以打开 Tomcat conf 文件夹下的 server.xml 更改其中的 8080 端口配置. 关于 JDK, Tomcat 及 开发环境的安装配置真懒得说太多, 打开百度可以搜索到 N 个教程. 如果有问题就问度娘吧~ 7. 创建动态 Web 项目在 IDEA 中, 选择 File &gt; New &gt; Project… 菜单, 在弹出的 “New Project” 窗口中选择 Java Enterprise &gt; Web Application 注意上图红框中的内容, 如果是空的, 选一下 或者 “New…” 一下. 然后, “Next”, 填写一个项目名称, “Finish”. 这样一个动态 Web 项目就创建好了. 如果你知道怎么使用 Maven, 强烈建议将此项目建为 Maven 应用程序 强烈建议自学 Maven ! 接着, 把前一节 ( 在线账本(一) ) 写的代码以及第三方文件依次拷贝到当前新建的项目中, 完成后大概是下图这个结构: 如果使用 Eclipse 创建动态 Web 项目, 可能上图中的 web 文件夹名为 webContent 上图中有些文件若没有, 可从上节下载的压缩文件中拷贝(index.js 除外, 这个文件要你自己写). 在 IDEA 窗口右上角的选择 Edit Configurations, 如图-7.1: 图-7.1 在出现的 Run/Debug Configurations 窗口中注意关注一下图红框的内容, 这个 URL 将是你网站的根. 图-7.2 关闭图-7.2窗口, 点击图-7.1中那个绿色的 “虫”, 以调试模式启动项目. 项目启动完成后, 打开浏览器, 地址栏输入 http://localhost:8080, 回车. 你应该可以看到上一节完成的那个记账本的页面. 若图-7.2 中红框内容不是 http://localhost:8080, 则地址栏输入的 URL 相应改变一下. ​ 到此为止, 我们把此前做的 “纯前端的记账本” 移置到了动态 Web 项目里了. 记住, 今后记账本页面的正确打开方式应是 http://localhost:8080 , 而不是直接双击 index.html ! 8. 建立服务器端账单的数据模型又来啦~ 数据模型~ MVC ~ YES, 让我们仍然从数据模型开始… 在项目的 src 目录下创建 example.vo 包 (package), 并在此包中创建一个类: Bill 目录结构大概如下: 图中 example 下的其余包 (文件夹) 可以一并创建, 以后会用到 Code-8.1: Bill.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package example.vo;import java.util.Date;// 一条账单的数据模型 (VO类)public class Bill &#123; private Integer id; // 账单ID private Date time; // 账单时间 private Integer amount; // 金额 private String memo; // 备注 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Date getTime() &#123; return time; &#125; public void setTime(Date time) &#123; this.time = time; &#125; public Integer getAmount() &#123; return amount; &#125; public void setAmount(Integer amount) &#123; this.amount = amount; &#125; public String getMemo() &#123; return memo; &#125; public void setMemo(String memo) &#123; this.memo = memo; &#125;&#125; 看出来了吗? 这个类的结构和前端账单数据数据结构是一致的. 对, 在服务器我们就要使用这个Bill 类的实例 (对象) 来存储一条账单的信息. 9. 实现账本服务这个标题好诡异… 什么叫账本服务? 姑且这样吧, 我也不知道取什么标题好. 在这里, 我们在example.service包下创建一个账本服务类AccountBookService, 以提供账本数据存储, 新增账单, 删除账单等服务. 代码如下: Code-9.1: AccountBookService.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package example.service;import example.vo.Bill;import java.util.ArrayList;import java.util.Date;import java.util.Iterator;import java.util.List;// 账本服务类public class AccountBookService &#123; // 账本服务单例 private static AccountBookService instance; // 账本中的账单列表 private List&lt;Bill&gt; bills; // 账本服务构造函数, 注意 private 修饰符, 为的是将此服务实现为\"单例\" private AccountBookService() &#123; // 构建一些测试用的数据 buildTestData(); &#125; // 静态(static)的 getInstance() 方法返回账本服务单例 public static AccountBookService getInstance() &#123; if (instance == null) &#123; instance = new AccountBookService(); &#125; return instance; &#125; // 返回账本中的账单列表 public List&lt;Bill&gt; getBills() &#123; return bills; &#125; // 添加 1 条账单 public void addBillItem(Bill bill) &#123; // 将新账单添加到最前面 bills.add(0, bill); &#125; // 删除 1 条账单 public void removeBillItem(Bill billToRemove) &#123; for (Iterator&lt;Bill&gt; itr = bills.iterator(); itr.hasNext(); ) &#123; Bill bill = itr.next(); if (bill.getId().equals(billToRemove.getId())) &#123; itr.remove(); break; &#125; &#125; &#125; // 构建一个 5 行账单记录的账本. 测试用 private void buildTestData() &#123; bills = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; Bill bill = new Bill(); bill.setId(i); bill.setTime(new Date()); bill.setAmount(Math.round(Math.random() * 10000)); bill.setMemo(\"收入\" + bill.getAmount() / 100.0 + \"元\"); bills.add(bill); &#125; &#125;&#125; 解释一下: 上面代码的注释中多次提到”单例”这个词, 它来自设计模式中的单例模式这个概念. 简单说, 所谓单例, 就是我们希望在当前的运行环境中, 这个某个类的实例(对象)只有一个(唯一的). 显然, 在这里, 我们希望账本服务 (AccountBookService) 只有一个实例, 否则多个服务提供账本, 那这个世界不就乱了吗? 关于单例模式的实现, 可参考上述代码第 14 行 及 19 ~ 31 行 建议抽空自学 “设计模式” 第 17 行使用一个 List 来存储账本 (多条账单) 数据, 其中的每一个元素即为一条账单 (Bill 对象, 参见 Code-8.1). 第 39 ~ 42 行, 45 ~ 53 行分别实现了从账本 bills 新增 1 条账单和删除 1 条账单的逻辑. 这些代码的功能和逻辑与第 (一) 节中新增/删除账单的代码类似, 只是这里使用 Java 语言描述. (参见第 (一) 节, Code-4.2.2, Code-5.2.1) 第 57 ~ 67 行的 buildTestData()方法(函数)构建了一个 5 行账单记录的账本, 用于测试. 10. 监听并分发前端请求看完前面第 8, 9 节是不是一头雾水, 到底要干什么呀, 到底要怎么把前后端对接起来呀~ 别急, 现在就开始… 大致的思路是: 在服务器实现一个 Servlet 监听前端发来的请求, 在服务器端做相应的处理, 最后将处理结果反馈给前端. 本文为了简便, 我们来使用本人封装的小工具: Web-lighter, 关于这个东东的详细介绍, 请参看 Web-lighter 简介 安利一下! 用上 web-lighter, 真香! web-lighter 的底层也是使用的 servlet. 现在先别忙着跑去看 web-lighter 说明书, 继续跟着来, 说不定学完本节你也就会了. 在项目的WEB-INF文件夹下创建一个名为 lib 的文件夹, 将 web-lighter 及其依赖的第三方 jar 文件 拷贝到此文件夹. 如图: 选中所有新拷入的 jar 文件, 右键菜单中选择 Add As Library… , 将这些 jar 文件添加到构建路径. 以上操作的目的在于将 web-lighter 及其依赖的第三方 jar 放入项目构建路径(Build Path). 若使用其它 IDE, 操作方法与上文所述有一定差异, 但目的一致. 如果你使用 Maven 则只需配置 pom.xml, 将 web-lighter 加入项目依赖. 具体方法参看 Web-lighter 简介 ​ 准备就绪, 开始写程序啦~ 在example.actoin包下创建BillAction类, 它用于监听前端发来的请求, 进行处理后, 将结果反馈给前端. Code-10.1: BillAction.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package example.action;import com.bailey.web.lighter.action.ActionResult;import com.bailey.web.lighter.action.ActionSupport;import com.bailey.web.lighter.annotation.Inject;import com.bailey.web.lighter.annotation.Param;import com.bailey.web.lighter.annotation.Request;import example.service.AccountBookService;import example.vo.Bill;// 处理前端关于账单的请求的的 Action 类// 注意继承 com.bailey.web.lighter.action.ActionSupportpublic class BillAction extends ActionSupport &#123; // 响应前端 /wl/getBills 请求, 将账本中的所有账单记录返回前端. // 注意形参表中使用 @Inject 注解, 以告知 Web-lighter 将 AccountBookService 实例作为参数注入 @Request(url = \"/getBills\") public ActionResult getBills(@Inject AccountBookService service) &#123; // service.getBills() 将获得账本中的所有账单数据 ( List&lt;Bill&gt; ) // 参见 Code-9.1 中 34 行 return ActionResult.success(service.getBills()); &#125; // 响应前端 /wl/saveOrUpdateBill 请求, 实现保存/更新账单功能 // @Inject 注解告知 Web-lighter 将 AccountBookService 实例作为参数注入 // @Param 注解告知 Web-lighter 将前端上行的 action, bill 两个参数分别解析后注入 @Request(url = \"/saveOrUpdateBill\") public ActionResult saveOrUpdateBill( @Inject AccountBookService service, @Param(name = \"action\") String action, @Param(name = \"bill\") Bill bill) &#123; // 根据上行参数 action 确定前端请求是要新增账单, 还是删除账单 switch (action) &#123; case \"append\": // 调用 AccountBookService 中的 addBillItem() 方法将新账单数据添入账本 // 参见 Code-9.1 中第 39 行 service.addBillItem(bill); break; case \"remove\": // 调用 AccountBookService 中的 removeBillItem() 方法将账单从账本中删除 // 参见 Code-9.1 中第 45 行 service.removeBillItem(bill); break; &#125; // 返回当前账单信息 return ActionResult.success(bill); &#125;&#125; 代码中注释都已经写满了, 就不对具体的代码作更多解释了. ​ 小结: BillAction负责监听前端各种请求, 然后转发给AccountBookService的具体方法来处理. AccountBookService负责管理账本数据, 并提供了 添加/删除 账单功能. Bill 用于封装一条账单的数据. 为保万无一失, 来对比一下我们的 src 文件夹结构是否如下图 ? ​ 好了, 现在服务器端的事情已经干完了, 重启 Tomcat, 等待前端发来请求吧~ 当然我们还得修改前端代码, 以使其能正确地和服务器端对接. 11. 对接服务器端盼星星, 盼月亮, 终于等到了这一天~ 来吧, 以下内容修改的是前 index.js 中的内容. 11.1 从服务器端获取账本数据首先我们在 index.js 中添加一个函数, 来完成向服务器端请求账本数据, 对接 Code-10.1 中第 17 ~ 22 行 Code-11.1.1 123456789101112131415161718192021222324// 从服务器端获得账本数据// 注意参数 callback 函数为从服务器端成功取到数据的回调函数function getBillsFromServer(callback) &#123; // 使用 jQuery 向服务器端发送 Ajax 请求 $.ajax(&#123; url: \"/wl/getBills\", // 对应 Code-10.1 第 17 行, 注意多了 \"/wl\" 前缀 type: 'post', // 声明以 Post 方式发送请求 dataType: \"json\", // 告诉 jQuery, 服务器端返回的数据是 JSON 格式 beforeSend: function () &#123; // 发送请求前的回调函数 $(\"#progress\").show(); // 发送请求前显示进度提示(左下角一个绕图图的 gif) &#125;, success: function (resp) &#123; // 请求成功时的回调函数 if (resp.code &gt;= 0) &#123; // 若服务器端回应数据中状态码 code &gt;= 0, 说明服务器端一切正常 callback(resp.result);// 回调 callback, 并将服务器端返回的数据传入 &#125; &#125;, error: function () &#123; // 请求失败的回调函数 $.fail(\"出错啦!\") &#125;, complete: function () &#123; // 请求完成时的回调函数 $(\"#progress\").hide(); // 请求完成, 隐藏进度提示 &#125; &#125;);&#125; 修改$(document).ready(function () {...});代码, 变成初始时从服务器端获取账本数据, 而不再使用前端 bills 数组的账单数据. 修改后的代码如下 (注意和 Code-4.2.1进行对比): Code-11.1.2 123456789101112131415161718192021$(document).ready(function () &#123; // 从服务器端获取账本数据 // 此处调用的是 Code-11.1.1 中定义的那个 getBillsFromServer 函数 // 你找到 Code-11.1.1 中 getBillsFromServer 函数所需要的 callback 回调函数了吗?? getBillsFromServer(function (result) &#123; // 将获取到的数据赋值给 bills 数组 bills = result; // 显示账单列表 showBillItems(); // 显示结余 refreshBalance(); &#125;); // 注册打开/关闭记账按钮的点击事件监听 $('#btn-add-bill').click(toggleBillEditor); // 注册 \"记一笔\" 按钮点击事件监听 $('#btn-confirm-add').click(addBillItem);&#125;); 好了, 现在打开浏览器, 地址栏输入 http://localhost:8080, 是否看到的账单数据变成了服务器端的数据了? 怎么看出是从服务器端来的数据? 呵呵~ 从服务器端来的账单时间都是当前系统时间. (看服务器端代码 Code-9.1 第 57 ~ 67 行就知道了) 注意: 因为我们使用了 web-lighter, 它自动把服务器端待回传数据 (bills) 使用 JSON 格式进行了打包(Code-10.1 第 48 行). 打开浏览器调试界面 (如: Chrome 中的开发者工具), 可以看到从服务器端回传的数据, 如图: 若你未使用 web-lighter, 应注意对应地修改 Code-11.1.1 第 8 行的配置, 以及第 12 ~ 16 行和其它地方的代码逻辑. 总之, 前后端的数据格式要配套. web-lighter 使用 JSON 格式对回传数据进行打包, 数据包中 code 为状态码, 默认情况下 code &lt; 0 表示出错, result 为数据部分. 参看 Web-lighter 简介 11.2 将新增账单保存到服务器端服务器端已经做好了接收客户端请求的准备, 此时我们只需修改前端代码既可: 11.2.1 对接服务器端 saveOrUpdateBillCode-11.2.1 1234567891011121314151617181920212223242526// 保存数据更改到服务端function saveToServer(action, bill, callback) &#123; $.ajax(&#123; url: \"/wl/saveOrUpdateBill\", // 对应服务器端 (Code-10.1 第 27 行) type: 'post', dataType: \"json\", data: &#123; // 上行参数 action: action, // 对应服务器端 Action 方法参数 (Code-10.1 第 30 行) bill: JSON.stringify(bill) // 对应服务器端 Action 方法参数 (Code-10.1 第 31 行) &#125;, beforeSend: function () &#123; $(\"#progress\").show(); &#125;, success: function (resp) &#123; if (resp.code &gt;= 0) &#123; callback(resp.result); &#125; &#125;, error: function () &#123; $.fail(\"出错啦!\") &#125;, complete: function () &#123; $(\"#progress\").hide(); &#125; &#125;);&#125; 注意 Code-11.2.1 中第 9 行使用 JSON.stringify(bill) 将账单按 JSON 格式进行了序列化. 即: 将 bill 对象转为 JSON 格式字符串 11.2.2 完成新增账单数据功能修改 index.js 中的 addBillItemData 方法(Code-4.2.2), 以将数据保存到服务器端: Code-11.2.2 12345678910111213// 新增一条账单的数据到账本数据模型// 参数说明:// bill - 新账单的数据, 一个对象, 形如 Code-3.3.1 中展示的那样一坨// callback - 数据模型更新成功后的回调函数function addBillItemData(bill, callback) &#123; // 保存数据到服务器端 saveToServer('append', bill, function (newBill) &#123; // 更新前端账本数据, 以保持和服务器端一致 bills.unshift(newBill); // 回调刷新界面 callback(newBill); &#125;);&#125; ​ OK, 现在刷新一下浏览器, 试一下, 新增账单时数据是不是已经保存到服务器端了. 怎么看出来数据已经保存到服务器端? 呵呵, 若数据保存在服务器端, 新增账单后, 刷新浏览器, 新账单数据并不会丢失. 11.3 与服务器端同步删除账单修改 index.js 中的 removeBillData()函数: Code-11.3.1 123456789101112131415// 删除一条账单的数据function removeBillData(bill, callback) &#123; // 保存数据到服务器端, 调用的仍然是 Code-11.2.1 中的 saveToServer 函数, 只是参数变了 saveToServer('remove', bill, function () &#123; // 删除前端账本数据模型中对应的记录, 与服务器端保存一致 for (var i = 0; i &lt; bills.length; i++) &#123; if (bills[i].id === bill.id) &#123; bills.splice(i, 1); break; &#125; &#125; // 回调刷新界面 callback(); &#125;);&#125; 注意和原先 index.js 中的 removeBillData() 函数 (Code-5.2.1) 对比一下: 上一节中我们只是从前端账本 (bills) 中移除了待删除账单(bill), 而在这里, 我们先通知服务器端删除账单数据, 成功后再移除前端账本中的数据, 以保持前后端同步. ​ 好了, 就这样, 我们实现了客户端 + 服务器模式的在线记账本. 现在, 只要不重启服务器端的 Tomcat 无论如何刷新页面(即使关闭浏览器重新开启), 你的账单数据都不会丢失. 我们来做一下小结: 客户端 + 服务器模式的在线记账本的工作流程: 打开 index.html 页面时, 客户端自动向服务器发起 Ajax 请求 ( getBillsFromServer() ), 取得账本数据, 呈现初始账单列表 当客户端有动作时(添加/删除账单), 向服务器端发送 Ajax 请求 ( saveToServer() ), 通知服务器端 服务器端更新账本数据模型, 成功后反馈更新结果 刷新前端页面 后续的用户操作, 继续重复上述 2 ~ 4 步 本节使用了 web-lighter, 它只是一个服务器端的轻量级封装, 为的是简化开发过程. 当领悟了整个开发过程后, 建议尝试一下使用原生的 Servlet 来完成 BillAction 的功能, 为的是更加清楚底层的原理. 当然, 也可以使用 Struts 等其它第三方框架来实现. 服务器端同样有一个 MVC 模型, 相对而言服务器端的账本数据 (bills) 是它的 Model 层, 而 BillAction 属于服务器端的 Controller 层, 其返回的 ActionResult 更像服务器端的 View. 服务器端的 View 层通过网络通信和客户端的 Model 层对接, 从而形成一个 MVC 链, 上游的 View 层与下游的 Model 层对接. 按照 MVC 模式的松耦合架构, 使得我们即便在前一节的基础上加入了服务器端, 前端代码相较于前一节也没有太大的改动. 其实前端代码主要变动的只是与前端的 Model 层相关的部分: 构建数据模型 ( getBillsFromServer() ) 和更新数据模型 ( addBillItemData(), removeBillData() )的那部分. 后两点是不是有点看不明白呀~ 细细揣摩一下… ​ 下一节我们将使用数据库来存储账本数据, 这样就实现了真正意义上的在线记账本. 即使服务器端重启 Tomcat, 你的账本仍然不会丢失. 准备好了, 就继续看下一节吧…","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"jQuery","slug":"jQuery","permalink":"https://baileykm.github.io/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"https://baileykm.github.io/tags/Ajax/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://baileykm.github.io/tags/Bootstrap/"}]},{"title":"实例教程 - 在线账本 (一)","slug":"实例教程-在线账本-1","date":"2019-05-14T14:20:08.000Z","updated":"2019-05-17T18:33:52.301Z","comments":true,"path":"2019/05/14/实例教程-在线账本-1/","link":"","permalink":"https://baileykm.github.io/2019/05/14/实例教程-在线账本-1/","excerpt":"本系列教程将带领大家完成一个 B/S 架构的”在线账本”, 希望通过这个实例教程能帮助大家打通 “任督二脉”, 把所学知识融汇贯通. 此为系列教程的第一部分: 纯前端代码实现的记账本. 只要你有一点 HMTL, CSS, Javascript 的基础就可以跟上我们的脚步. 当然, 了解一点点 Bootstrap 和 jQuery 将会更轻松.","text":"本系列教程将带领大家完成一个 B/S 架构的”在线账本”, 希望通过这个实例教程能帮助大家打通 “任督二脉”, 把所学知识融汇贯通. 此为系列教程的第一部分: 纯前端代码实现的记账本. 只要你有一点 HMTL, CSS, Javascript 的基础就可以跟上我们的脚步. 当然, 了解一点点 Bootstrap 和 jQuery 将会更轻松. 1. 先看效果 2. 构建前端静态页面 3. 前端逻辑实现 3.1 MVC 模式 3.2 设计账本数据模型 3.3 展示账单列表 4. 新增账单 4.1 显示/隐藏”新账单编辑面板” 4.2 实现”新增账单”功能 5. 删除账单 5.1 监听账单项双击事件 5.2 实现”删除账单”功能 本教程假设你已熟悉 HTML, CSS, 对 Javascript, Java 有一定基础, 对数据库管理系统 (MySQL) 有所了解. 倘若以上假设不成立… 也不要紧, 跟着来, 遇到不明白的问下度娘, 或给我写信. ​ 1. 先看效果 怎么样, 还行吧 ?! 有没有兴趣继续跟着学? 本系列教程 (一) 至 (三) 节的运行效果相似, 均如上面的动图, 只是使用到的技术逐渐加深: 纯前端代码实现的记账本 客户端 (前端) + 服务器端 (后端) 模式的在线记账本 真正的在线记账本: 客户端 + 服务器 + 数据库 ​ 2. 构建前端静态页面本节内容虽然听上去有些 low, 只是一个纯前端实现, 但它是第 (二)、(三) 节那些更 “高大上” 的东西的基础. 前端页面的构建主要涉及的技术有: HTML, CSS, Javascript. 当然, 为了视觉效果上漂亮些, 我们加入了 bootstrap, 同时为了让我们的 Javascript 代码写的轻松些, 我们还用到了 jQuery, jquery-confirm, moment.js. 相对而言, 大多数同学对 HTML 和 CSS 的掌握还算不错. 请先试着自己完成如下图所示界面的制作: 本教程重点不在 HTML 和 CSS 代码的编写, 下面将直接给出代码, 只作简要解释. 若想偷懒, 直接复制或是下载 便是, 但index.html 和 index.css中的代码请仔细研读并弄懂. 下载到的压缩包里是不是少了 index.js 文件 ? 哈哈~ 我故意删掉的! 防止你直接解压运行一下, 看个开心就了事~ 本节的重点是前端业务逻辑的实现 ( index.js ), 千万别想着在这个环节上偷懒, 否则就失去本教程的意义了! Code-2.1 index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;在线记账本&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.css\"&gt; &lt;!-- jquery-confirm 的样式 --&gt; &lt;link rel=\"stylesheet\" href=\"css/jquery-confirm.3.3.min.css\"&gt; &lt;!-- 自定义样式 --&gt; &lt;link rel=\"stylesheet\" href=\"css/index.css\"&gt; &lt;!-- jQuery --&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;!-- jQuery Confirm, jQuery插件, 用于弹出消息框 --&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-confirm.3.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-confirm-bailey.js\"&gt;&lt;/script&gt; &lt;!-- Bootstrap --&gt; &lt;script type=\"text/javascript\" src=\"js/bootstrap.js\"&gt;&lt;/script&gt; &lt;!-- Moment, 处理时间/日期的第三方库 --&gt; &lt;script type=\"text/javascript\" src=\"js/moment.2.24.0.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/moment.locale.2.24.0.js\"&gt;&lt;/script&gt; &lt;!-- 本页面自定义 javascript 代码 --&gt; &lt;script type=\"text/javascript\" src=\"js/index.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt; &lt;div id=\"records\" class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;&lt;i class=\"icon glyphicon glyphicon-list\"&gt;&lt;/i&gt;记账本&lt;/h3&gt; &lt;a id=\"btn-add-bill\" title=\"打开/关闭记账面板\"&gt;&lt;i class=\"icon glyphicon glyphicon-menu-right\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul id=\"bill-items\"&gt; &lt;li class=\"record\"&gt; &lt;div class=\"date-time\"&gt; &lt;h2 class=\"date\" data-field=\"date\"&gt;05/13&lt;/h2&gt; &lt;p class=\"time\" data-field=\"time\"&gt;12:49:36&lt;/p&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;h4 class=\"media-heading io in\" data-field=\"amount\"&gt;+ 800.00&lt;/h4&gt; &lt;p class=\"memo\" data-field=\"memo\"&gt;老爸发生活费啦&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; &lt;img id=\"progress\" src=\"img/spinner.gif\"&gt; &lt;h4 id=\"balance\" style=\"color: green;\"&gt; 结余: &lt;span&gt;+ 800&lt;/span&gt; &lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"panel-bill-editor\" class=\"panel panel-info\" style=\"display: none;\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;&lt;i class=\"icon glyphicon glyphicon-pencil\"&gt;&lt;/i&gt;账单&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"input-group\"&gt; &lt;label&gt;金额&lt;/label&gt; &lt;input id=\"nb-amount\" type=\"number\" max=\"100000\" class=\"form-control\" placeholder=\"收入/支出金额\"&gt; &lt;/div&gt; &lt;div class=\"input-group\"&gt; &lt;label&gt;备注&lt;/label&gt; &lt;input id=\"nb-memo\" type=\"text\" maxlength=\"50\" class=\"form-control\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; &lt;button id=\"btn-confirm-add\" class=\"btn btn-sm btn-info\"&gt;&lt;i class=\"icon glyphicon glyphicon-floppy-save\"&gt;&lt;/i&gt;记一笔&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对以上代码作简要解释: head 部分: 引入各种 CSS 和 javascript 第 8 行 和 第 23 行引入bootstrap, 加入bootstrap 预定义样式和 boostrap 组件代码. 若对 bootstrap 知之甚少, 强烈建议课外自学. ( 现在别忙着去看 ) 第 10 行 和 第19 行引入了一个名为jquery-confirm的 jQuery 插件, 用于弹出漂亮的消息框. 第 16 行引入 jQuery 库, 这里我们使用的是 1.11.1 版本. 若你使用别的版本, 请注意兼容性问题. 第 13 行 和 第 30 行 引入的是针对 index.html 页面写的样式表和 javascript 脚本. body 部分: 页面主体部分的 HTML 代码 页面主体部分分作左、右两个部分: 左侧为账本记录列表 ( 35 ~ 60 行, div#records), 展示已登记的账单列表; 右侧为单条账单的编辑界面 ( 62 ~ 79 行, div#panel-bill-editor), 注意此面板初始时为隐藏状态. 注意其中的第 42 ~ 51 行 ( &lt;li class=&quot;record&quot;&gt; ... &lt;/li&gt;), 这是账单列表中的一条信息. ​ 篇幅所限, index.css 的代码就不直接附在本文中了. 若有需要参考, 可直接下载前端部分代码. ​ 3. 前端逻辑实现这一部分我们将编写index.js中的代码, 实现前端逻辑. 完成后你将得到一个 “纯前端代码实现的记账本”. ( 即: 没有服务器端, 也没有数据库 ) 本部分代码均放置于 index.js 深吸一口气~ 我们开始吧… 3.1 MVC 模式首先, 我们要强调一个重要的软件设计模式: MVC. MVC 模式是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码. 可以毫不夸张地说, MVC 模型指引着我们各种软件设计的大方向, 根据 MVC 模式思想, 我们可以把大到一个软件系统, 小到一个功能模块分解为 M (Model)、V (View) 和 C (Controller) 三个部分(层). 其中: Model - 数据模型层: 使用合适的数据结构存储着软件(模块)中的数据. View - 视图层: 粗浅来说, 它是用户看到的界面呈现. 更准确来说, 是软件(模块)中更靠近”用户”的那一层 (不一定是可视化的界面). View 是 Model 的表现. Controller - 控制层: 实现了 Model 到 View 的映射 ( 根据 Model 来呈现 View ), 以及 View 到 Model 的反馈 ( 根据 View 层的变化来更新 Model ). 也就是说, Controller 实现了 Model 和 View 之间的双向映射 (同步). 盗个图来说, 大概就是这样: 3.2 设计账本数据模型扯了半天 MVC, 你现在应该知道 Model 算是三兄弟中的老大了吧~ 所以, 我们可以先从数据模型 (Model) 设计开始, 代码如下: Code-3.2.1 12345678910111213141516171819202122// 账本数据模型var bills = [&#123; id: 3, // 账单ID time: new Date('2019-05-15 19:27:38'), // 记账时间 amount: 80000, // 金额, 单位:分 memo: '老爸发生活费了' // 备注&#125;, &#123; id: 2, time: new Date('2019-05-15 17:44:31'), amount: -1470, memo: '食堂打的饭, 味道还真是一般'&#125;, &#123; id: 1, time: new Date('2019-05-15 17:27:12'), amount: -1890, memo: '买本《小王子》, 补个童年'&#125;, &#123; id: 0, time: new Date('2019-05-14 18:19:34'), amount: -1200, memo: '今晚吃饺子'&#125;]; 我们使用一个数组来存储账本数据, 其中每一个数组元素为一条账单记录. 上面的代码是测试时初始的模拟数据(账单按时间降序排列) 第 3 ~ 6 行的注释说明了一条账单数据中各属性的含意 注意: 金额的单位为”分”, 即 amount: 80000 代表金额为 800.00 元. 使用 “分” 为单位可令金额数值表达为整型, 避免了计算过程中的精度问题. 不明白? 试试 alert( 1 - 0.7 );会出现什么… 3.3 展示账单列表接下来, 我们来实现账单列表的展示, 即最终运行效果图中左侧列表的显示. 在 3.2 节我们已经完成数据模型的设计, 这里将实现 Model → View 的映射. 先考虑一条账单数据的展示. 对于单条账单, 其数据模型大概是如下的样子: Code-3.3.1 123456&#123; id: 0, // 账单ID time: new Date(), // 记账时间 amount: 80000, // 金额, 单位:分 memo: '老爸发生活费了' // 备注&#125; 注意前文 index.html ( Code-2.1 ) 代码中第 42 ~ 51 行: Code-3.3.2 12345678910&lt;li class=\"record\"&gt; &lt;div class=\"date-time\"&gt; &lt;h2 class=\"date\" data-field=\"date\"&gt;05/13&lt;/h2&gt; &lt;p class=\"time\" data-field=\"time\"&gt;12:49:36&lt;/p&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;h4 class=\"media-heading io in\" data-field=\"amount\"&gt;+ 800.00&lt;/h4&gt; &lt;p class=\"memo\" data-field=\"memo\"&gt;老爸发生活费啦&lt;/p&gt; &lt;/div&gt;&lt;/li&gt; 有没有看出什么门道 ? 对了, 上面两块代码 ( Code-3.3.1 和 Code-3.3.2 ) 其实是对应的. 只是 Code-3.3.1 是 javascript 代码, 是所谓的数据模型. 而 Code-3.3.2 是 HTML 代码, 相对而言, 可称其为 View 层代码. 那现在我们的任务应该很明确了, 就是要根据 Code-3.3.1 所示的一坨数据 ( javascript对象 ) 形成 Code-3.3.2 所示的&lt;li&gt;….&lt;/li&gt; 的 DOM ( 文档对象模型 ). 注意: 不是生成 Code-3.3.2 所示的 HTML代码, 而是形成这块代码对应的 DOM DOM 其实是浏览器世界的 Model 层, 也就是说, 后续我们将操纵 DOM, 浏览器发现 DOM 变化后将自动刷新网页界面. ( 我们不是直接操纵网页上的元素, 而是操纵它们的 DOM, 从而间接改变网页的内容 ) Code-3.3.3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 一条账单的 HTML 模板// 对应 Code-3.3.2, 只是把其中类似 \"05/13\" 这样的信息删除了, 因为这些信息应是变量值, 而不是\"硬编码\"// 注意, 变量 billItemTemplete 的值是一个字符串var billItemTemplete = '&lt;li class=\"record\"&gt;' + '&lt;div class=\"date-time\"&gt;' + '&lt;h2 class=\"date\" data-field=\"date\"&gt;&lt;/h2&gt;' + '&lt;p class=\"time\" data-field=\"time\"&gt;&lt;/p&gt;' + '&lt;/div&gt;' + '&lt;div class=\"content\"&gt;' + '&lt;h4 class=\"media-heading io\" data-field=\"amount\"&gt;&lt;/h4&gt;' + '&lt;p class=\"memo\" data-field=\"memo\"&gt;&lt;/p&gt;' + '&lt;/div&gt;' + '&lt;/li&gt;';// 创建一条账单的 DOM// 参数 bill 是一条账单的数据, 即 Code-3.3.1 所示的一坨数据function createBillItemDom(bill) &#123; // 借助 jQuery 直接使用账单模板形成 DOM // $item 为一条账单的 DOM var $item = $(billItemTemplete); // 将账单时间构建成 moment 对象, 以便后续格式化输出 // moment() 来自第三方库 moment.js var dt = moment(bill.time); // 遍历所有含有 data-field 属性的元素 // 并使用数据模型 (bill) 中的值替换此元素的内容(innerText) $item.find('[data-field]').each(function (i, ele) &#123; // 针对每一个含有\"data-field\"属性的元素, 此匿名函数将被执行一次 // 其中参数 i 为顺序号, ele 为当前遍历到的元素 // 将 ele 这个普通的 DOM 元素封装成 jQuery 对象, 以便处理. var $ele = $(ele); // 读取当前元素的 data-field 属性值 var field = $ele.attr('data-field'); // 根据 data-field 属性值不同, 分别作不同的处理 switch (field) &#123; case 'date': // 若 data-field = date, 填入使用 moment.js 格式化后的 \"月/日\" $ele.text(dt.format('MM/DD')); break; case 'time': // 若 data-field = date, 填入使用 moment.js 格式化后的 \"时:分:秒\" $ele.text(dt.format('HH:mm:ss')); break; case 'amount': // 金额字段 $ele.text(bill.amount); // 若金额大于 0, 则给当前元素(金额字段)添加样式类 \"in\" (显示为绿色) if (bill.amount &gt; 0) &#123; $ele.addClass('in'); &#125; break; default: // 对于其余元素(如: memo), 直接使用 bill 中的相应属性值填充 $ele.text(bill[field]); &#125; &#125;); // 返回构建好的 DOM return $item;&#125; 妈呀, 看上去好复杂… 虽然代码中已经写满了注释, 但还是进一步解释一下: 第 20 行 var $item = $(billItemTemplete); , 这里借助 jQuery 来构建 DOM 模型. 若要动态创建一个&lt;p&gt;&lt;/p&gt; 的 DOM, 使用纯原生方法可以这样写: document.createElement(&quot;p&quot;);, 但若使用 jQuery, 则可以写成: $(&quot;&lt;p&gt;&quot;), 是不是很简单? 而如果我们要构建如 Code-3.3.2 那样一大块相对复杂的元素, 使用原生方法就太麻烦了… 此时借助 jQuery 显然就简单多了 ( 参见第 4 ~ 13 行和第 20 行代码 ) 第 24 行 var dt = moment(bill.time); , 使用账单时间 ( bill.time ) 构建一个 moment 对象, 第 41, 44 行分别用其格式化输出账单的日期和时间部分. moment.js 是一个很不错的专门处理日期时间型数据的工具包. 建议抽空自学: moment.js 官方网站 / moment.js 中文网站 现在, 暂时不要跑去看 moment.js 文档, 这里你知道我们使用它来格式化输出日期时间就行了, 以后再慢慢去看, 现在请继续… 第 28 ~ 56 行或许是上面这段代码中最难理解的部分, 我们慢慢来… 注意到 HTML 模板中, 凡是需要使用变量值填充的元素, 我们都添加了一个data-field属性, 这样便于我们找到这些元素. 并且, 我们将此元素应对应的数据字段名藏在了 data-field 属性值那里, 例如: &lt;p class=&quot;memo&quot; data-field=&quot;memo&quot;&gt;&lt;/p&gt; 表示此 &lt;p&gt;元素的内容对应的数据字段名为 memo 这样我们就可以使用 jQuery 的 .find()函数找到所有含有 data-field 属性的元素 如: $item.find(&quot;[data-field]&quot;) 即可找到 $item 元素中所有含 data-field 属性的子元素 对于找到的所有含有 data-field 属性的子元素集合, 使用.each()函数即可轻松遍历. 如: $item.find(&quot;[data-field]&quot;).each(function(i, element){ ...}) 注意 each()形参表中的匿名函数function(i, ele){...}, 此函数在遍历到每一个元素时将被自动回调一次, 参数 i 和 element 分别为顺序号(这是遍历到的第几个元素) 和当前遍历到的元素. 第 25 ~ 55 行的代码都是放在这个匿名函数里的. 第 36 行读取当前遍历到的元素的 data-field 属性中藏着的数据字段名信息, 并在第 39 ~ 55 行 分别进行了处理. 这段代码就不详细解释了, 参看一下注释. ​ 终于讲完了… 如果看 Code-3.3.3 的代码让你一脸迷惑, 千万不要丧失信心. 这段代码算是本节中最难理解的部分了, 挺过这一关, 你将轻松面对后面的内容. 放慢脚步, 结合注释和说明多思考, 你一定能理解! 代码里出现大量了jQuery 的东西, 抽空读一下本博客另一篇文章: jQuery入门精要, 或许会有帮助. ​ 接下来, 如果要生成整个账本数据 (bills数组) 的 DOM 元素, 那不就是一个循环吗? 看现在这段代码 Code-3.3.4 12345678910111213// 显示账本中所有账单function showBillItems() &#123; // 账单列表的容器, Code-2.1 中 41 行的那个 &lt;ul&gt; var $billItems = $('#bill-items'); // 清空账单列表 $billItems.empty(); // 遍历整个 bills 数组, 构建每一个账单的 DOM 模型, 并将其\"装入\" 账单列表容器 for (var i = 0; i &lt; bills.length; i++) &#123; $billItems.append(createBillItemDom(bills[i])); &#125;&#125; Code-3.3.4 中的showBillItems()函数实现了整个账本中所有账单的展示. 接下来的 Code-3.3.5 实现 “结余” 的展示: Code-3.3.5 12345678910111213// 显示结余function refreshBalance() &#123; // 计算 \"结余\" var balance = 0; for (var i = 0; i &lt; bills.length; i++) &#123; balance += bills[i].amount; &#125; // 刷新界面 var $balance = $(\"#balance\"); $balance.css('color', (balance &gt; 0) ? 'green' : '#ce4844'); $balance.find('span').text(balance);&#125; 还记得吗? 我们的金额的单位是 “分”, 这给用户看到了, 会显得很别扭, 于是补充如下一个函数, 用于格式化最终显示时的金额: Code-3.3.6 12345678910// 格式化金额显示// 参数说明// money - 金额, 单位 \"分\"// signed - 是否强制显示正负号, 例如: 账单列表中, 收入800要显示为 \"+ 800\", 而结余处则正数无须显示\"+\"function formatMoney(money, signed) &#123; // 换算成 \"元\" var m = money / 100.0; // 在数据前添加 \"+ / -\" return (m &gt; 0 ? (signed ? '+ ' : '') : ((m === 0) ? '' : '- ')) + Math.abs(m);&#125; 有了formatMoney()这个函数, 金额值显示出来就人性化多了… 当然, 我们需要把显示金额的地方都调整一下: 修改 Code-3.3.3 中的第 47 行为: $ele.text(formatMoney(bill.amount, true)); 修改 Code-3.3.5 中的第 12 行为: $balance.find(&#39;span&#39;).text(formatMoney(balance, false)); Code-3.3.6 中第 9 行的那个语句看着点有复杂, 可以展开为: 12345678910111213141516var rt;if (m &gt; 0) &#123; if (signed) &#123; // signed == true rt = '+ '; &#125; else &#123; rt = ''; &#125;&#125; else &#123; if (m == 0) &#123; rt = ''; &#125; else &#123; rt = '- '; &#125; rt += Math.abs(m); // Math.abs(m) 为求 m 的绝对值&#125;return rt; 最后帮你一次, 以后要自己学会分析, 并习惯 Code-3.3.6 中第 9 行 的写法. 好处嘛, (1) 很简洁 (2) 显示自己很牛! ​ 最后我们把上面这些代码(函数)组装起来, 借助 jQuery 在页面加载就绪时自动展示账单列表: Code-3.3.7 1234567$(document).ready(function () &#123; // 显示账单列表 showBillItems(); // 显示结余 refreshBalance();&#125;); 看不懂 $(document).ready(function(){ …. }); 是什么鬼的看另一篇文章: jQuery入门精要 快在浏览器中打开 index.html 看一下效果吧~ ​ 小结: 本节我们实现了 “根据一条账单的数据, 构建对应的 DOM 元素” ( 数据 → 视图 ) 本文开篇效果演示的动图中有两个细节还未实现: (a) 金额始终显示小数点后 2 位, 即: 即使是 800 元, 也会显示为 + 800.00 (账单列表), 或 800.00 (结余) (b) 结余数值在有变化时, 会快速显示数值变化过程. 例如: 结余从 600.00 变成 800.00 时, 会快速显示 620.00, 640.00, 660.00…. 直至 800.00 停止 这些花哨的效果只是为了挑逗你的兴趣, 与业务逻辑关系不大, 因此本文就不详述了. 你若有兴趣, 自己想办法完成吧. ​ 4. 新增账单本节将实现新增账单, 即 “记一笔”功能. 4.1 显示/隐藏”新账单编辑面板”最终完成的作品中, 右侧的 “账单编辑面板” 初始时是隐藏的, 当点击了 &gt; 图标才显示出来, 而点击 &lt; 图标则隐藏. 实现这个效果不难, 并不涉及数据模型的变化, 只是纯粹的界面效果. Code-4.1.1 12345678910// 打开/关闭账单编辑面板function toggleBillEditor() &#123; // 显示/隐藏\"账单编辑面板\" $(\"#panel-bill-editor\").toggle('fast'); // 切换展开(&gt;) 和 关闭(&lt;) 图标 var $btnIcon = $(this).find('i'); $btnIcon.toggleClass('glyphicon-menu-left'); $btnIcon.toggleClass('glyphicon-menu-right');&#125; 此外, 修改 Code-3.3.7 的代码如下(Code-4.1.2), 即添加其中的第 9 行代码. 监听 打开/关闭”账单编辑面板”按钮 (图标) 的点击事件, 触发 Code-4.1.1 中的 toggleBillEditor()函数. Code-4.1.2 12345678910$(document).ready(function () &#123; // 显示账单列表 showBillItems(); // 显示结余 refreshBalance(); // 注册 打开/关闭\"账单编辑面板\"按钮 的点击事件监听 $('#btn-add-bill').click(toggleBillEditor);&#125;); Code-4.1.1 中出现了两个 jQuery 函数: toggle() 和 toggleClass(), 如果不明白其含意, 参看 jQuery入门精要 中”复合事件”一节 打开/关闭”账单编辑面板”按钮中上图标并非使用图片标签 ( &lt;img&gt; ) 实现, 而是使用 “glyphicon 字体”, 即这个图标本质上是一个字符, 而非图片, 只是这个字符使用 glyphicon 字体显示出来就是&gt;/&lt;图标的样子. 使用字体呈现图标有诸多好处, 具体内容请查阅其它资料. 4.2 实现”新增账单”功能4.2.1 监听”记一笔”按钮点击事件在 Code-4.1.2 的基础上添加对 “记一笔” 按钮点击事件的监听, 以触发后续的 “新增账单” 逻辑. 即增加如下代码中的第 12 行. Code-4.2.1 12345678910111213$(document).ready(function () &#123; // 显示账单列表 showBillItems(); // 显示结余 refreshBalance(); // 注册 打开/关闭\"账单编辑面板\"按钮 的点击事件监听 $('#btn-add-bill').click(toggleBillEditor); // 注册 \"记一笔\" 按钮点击事件监听 $('#btn-confirm-add').click(addBillItem);&#125;); 至于上述代码中第 12 行涉及的 addBillItem 函数, 我们将在 4.2.3 节实现. 继续往下看就知道了… 4.2.2 更新账本数据模型现在假设用户已经填写了新账单的信息(金额和备注), 点击了”记一笔”按钮. 接下来程序应该干什么呢 ? 还记得 MVC 吗? 又来了… 我们应该先考虑用户的这一系列的操作会对数据模型 (Model, 数据层) 产生什么影响, 因此我们先来实现更新数据模型的逻辑: Code-4.2.2 123456789101112// 新增一条账单的数据到账本数据模型// 参数说明:// bill - 新账单的数据, 一个对象, 形如 Code-3.3.1 中展示的那样一坨// callback - 数据模型更新成功后的回调函数function addBillItemData(bill, callback) &#123; // 将新账单数据插入账本数据模型(账单数组)的开头 // array.push() 是在数组尾部新增元素, array.unshift() 则是在开头插入新元素 bills.unshift(bill); // 回调 callback(bill);&#125; 这段代码看似简单, 就定义了一个函数, 函数中就 2 行代码, 但似乎有点不容易看懂. 解释一下… 假设已经有了新账单的数据 (bill, 一个对象), 我们将bill作为输入参数传递给函数 addBillItemData() , 在上面代码的第 8 行将新账单数据 bill 插入到了账单数组bills的开头. (bills 数组为账本数据, 参看 Code-3.2.1) 函数 addBillItemData() 的第 2 个参数callback很特别, 它是一个函数, 由调用方传入. 在完成了数据模型的更新后, 我们在第 11 行执行这个函数, 并将 bill 作为参数传入, 以触发后续的逻辑 (如: 刷新界面, 参看 Code-4.2.3 第 24~36 行). 像 callback 这样意义的函数, 我们一般称作回调函数. 4.2.3 实现新增账单看完 4.2.2 节估计你是似懂非懂, 到底那个 callback 函数是什么鬼 ? 看完下面的代码 (Code-4.2.3) 你就明白了. 在 Code-4.2.1 中的第 12 行我们注册了 “记一笔” 按钮的点击事件监听, 当用户点击 “记一笔” 按钮时, 将执行如下的addBillItem()函数. 第 2 ~ 22 行主要是取得用户输入的账单信息, 并作校验, 将账单信息构建成一个 bill 对象 (第 17 ~ 22 行) 第 25 ~ 37 行就是传说中的那个回调函数 callback() . 可以看到, 这个函数只是在更新数据模型后更新界面: (a) 构建新账单的 DOM, 并将其插入到界面上账单列表的开头 (b) 清空金额和备注输入框 (c) 刷新”结余”显示 第 40 行, 调用上一节 ( 4.2.2 节 ) 中定义的那个addBillItemData()函数, 并将账单数据 (bill) 和 更新数据模型成功后的回调入口 (callback 函数) 作为参数传入. Code-4.2.3 1234567891011121314151617181920212223242526272829303132333435363738394041function addBillItem() &#123; // 找到金额和备注输入框 var $fAmount = $('#nb-amount'); var $fMemo = $('#nb-memo'); // 取得用户输入的金额值, 并做验证 var amount = parseFloat($fAmount.val()); if (!amount) &#123; // $.fail() 将弹出一个漂亮的消息框, 作用和 alert('金额不对哦~') 相同, 只是更漂亮 // $.fail() 借助了 jquery-confirm.3.3.min.js 提供的功能 // 并在 jquery-confirm-bailey.js 做了扩展, 可参看附件中的代码 $.fail('金额不对哦~'); return; &#125; // 新增账单的数据 var bill = &#123; id: Math.random(), // 取一个随机数作为账单ID (不太科学, 姑且先用, 第(三)节中此ID将由数据库自动生成) time: new Date(), // 取客户端当前系统时间 amount: Math.round(amount * 100), // 用户输入的金额乘以100后取整. 由\"元\"换算成\"分\" memo: $fMemo.val() &#125;; // 数据模型更新成功后的回调函数, 实现界面刷新 var callback = function (bill) &#123; // 创建新账单项的DOM var $billItemDom = createBillItemDom(bill); // 插入到账单列表(#bill-items) 的第 1 项之前 $('#bill-items').prepend($billItemDom); // 清空账单编辑面板中的\"金额\"和\"备注\"输入框 $fAmount.val(''); $fMemo.val(''); // 刷新结余显示 refreshBalance(); &#125;; // 添加账单数据模型, 成功后回调, 刷新界面 addBillItemData(bill, callback);&#125; 好了, 有点晕, 是吧~ 我帮你捋一下理路: 首先, 我们在 4.2.1 节注册了”记一笔”按钮的点击事件监听, 当此按钮被点击时, 触发4.2.3 节的 addBillItem() 函数 然后, 在 4.2.3 节的 addBillItem() 函数中获得用户输入的账单数据, 在进行了必要的输入验证后, 组装出了新账单数据对象 (bill) 接着, 在 Code-4.2.3 中第 40 行调用 4.2.2 节中定义的 addBillItemData() 函数, 完成账本数据的更新(更新数据模型) 最后, 在账本数据模型更新成功后回调刷新界面 ( Code-4.2.2 中第 11 行 回调 Code-4.2.3 中第 25 ~ 37 行定义的函数) 停下来, 想一想… ​ 现在, 在浏览器中打开 index.html, 你应该可以实现新增账单了, 赶快试试吧~ ​ 5. 删除账单本节将实现删除账单功能. 相对而言, 有了第 4 节的基础, 实现删除账单功能就简单得多了. 本例中, 将监听账单列表中的账单项的”双击”事件, 以触发删除账单逻辑. 即: 当用户双击已有的账单项时, 将删除此账单. 5.1 监听账单项双击事件修改一下 Code-3.3.3 中的代码, 在第 57 行位置插入如下第 5 ~ 8 代码, 以注册账单项双击事件监听. 修改后的代码大概如下: Code-5.1.1 123456789101112function createBillItemDom(bill) &#123; // ............ 前面的代码参见 Code-3.3.3, 此处省略 ........... // 注册账单项的双击事件监听 $item.dblclick(function () &#123; removeBillItem($item, bill); &#125;); // 返回构建好的DOM return $item;&#125; 其中, 第 7 行的removeBillItem()函数定义见下节. 5.2 实现”删除账单”功能“删除账单” 逻辑的实现与”新增账单”类似. 同样采用先更新数据模型, 再刷新界面的逻辑. 有了前面第 4 节 “新增账单” 的基础, 自己研究一下以下代码吧 ~ Code-5.2.1 123456789101112131415161718192021222324252627282930313233343536373839// 从账本中删除账单数据 (更新账本数据模型), 成功后回调刷新界面// 参数说明:// bill - 待删除的账单数据// callback - 删除成功(账本数据模型更新成功)后的回调函数function removeBillData(bill, callback) &#123; // 删除账本数据模型(账单数组)中的账单记录 for (var i = 0; i &lt; bills.length; i++) &#123; // 若遍历到的账单正是需要删除的账单(ID 相同), 则从账本(bills数组)中删除 if (bills[i].id === bill.id) &#123; // 从数组 bills 中移除从第 i 个元素开始的 1 个元素 (即当前遍历到的账单) bills.splice(i, 1); break; &#125; &#125; // 回调刷新界面 callback();&#125;// 删除一条账单// 此函数所需的两个参数 $item 和 bill 在 Code-5.1.1 第 7 行传入// $item 为用户双击的账单项的DOM// bill 双击的那个账单项对应的数据对象function removeBillItem($billItemDom, bill) &#123; // $.question() 将弹出一个漂亮的提示框 // $.question() 借助了 jquery-confirm.3.3.min.js 提供的功能 // 并在 jquery-confirm-bailey.js 做了扩展, 可参看附件中的代码 $.question('确定要删除此账单?', function () &#123; // 删除数据模型中的账单, 成功后回调刷新界面 removeBillData(bill, function () &#123; // 从 DOM 中移除当前账单项, 即从界面上移除当前账单 $billItemDom.remove(); // 刷新\"结余\"显示 refreshBalance(); &#125;); &#125;); &#125; ​ 好了, 现在你可以进行双击账单项删除已有账单的操作了, 赶快在浏览器中打开 index.html 试一下吧~ 现在, 在浏览器中打开 index.html, 你应该可以实现新增账单了, 赶快试试吧~ ​ ​ 意不意外? 开不开心? 你居然已经完成了一个记账本程序, 它可以实现新增账单(记账)和删除账单的操作. 但是…… 还有些问题需要完善…… 修改账单数据的功能未实现, 这留给你自己来完成吧! 给个小提示, 可以这样来玩: 让用户点击选择一条已有的账单, 然后在”账单详情面板”中显示出这条账单的信息, 即: 把用户选中的账单的金额和备注信息填充在相应的输入框中, 等待用户修改 用户点击”保存”按钮后, 执行更新账单数据操作. 记得先更新数据模型, 再刷新界面哦~ 一些花哨的效果 (如: 插入新账单时的动画, 删除账单时的动画, 结余数值变化时的递增/减动画) 只是吸引眼球, 让你有兴趣跟着我玩, 在上面的代码中未实现, 你可以自己想想怎么做到. 给个小提示: 新增账单: 在把新账单的 DOM 添到账单容器前先隐藏, 添加后再慢慢显示: $billItemDom.hide(); $(&#39;#bill-items&#39;).prepend($billItemDom); $billItemDom.show(500); 删除账单: 先用动画逐渐隐藏账单DOM, 动画结束后彻底移除: $billItemDom.hide(&#39;fast&#39;, function(){ $billItemDom.remove(); }); 结余值滚动: 计算前后两次的结余数值之差(delta), 使用 setInterval() 每隔 100 毫秒让结余显示递增 delta/10.0, 直到结余显示值大于或等于最终值时使用 clearInterval() 停止变化过程, 这样结余数值显示将在 1 秒内滚动完成. (结余由大变小时应是小于或等于终值时停止, 注意结余值在由正负变换时切换文字的颜色). 目前的记账本在用户刷新页面, 或者关闭浏览器后数据将丢失! 杯具啦~~ 因为我们只是把数据保存在前端 javascript 的变量里 ( bills 数组 ), 当然会如此… ​ 本系列教程的 第 (二) 部分, 我们将在目前记账本的基础上进一步完善, 加入服务器端, 将数据保存在服务器端. 实现一个真正意义上的 “在线记账本”, 敬请期待!","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"jQuery","slug":"jQuery","permalink":"https://baileykm.github.io/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"https://baileykm.github.io/tags/Ajax/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://baileykm.github.io/tags/Bootstrap/"}]},{"title":"Cayenne 起步 (Version 4.0) [译]","slug":"Cayenne入门指南4-0","date":"2019-05-11T05:59:51.000Z","updated":"2019-05-11T16:43:38.046Z","comments":true,"path":"2019/05/11/Cayenne入门指南4-0/","link":"","permalink":"https://baileykm.github.io/2019/05/11/Cayenne入门指南4-0/","excerpt":"Cayenne 是一个 Apache 下的持久层框架项目, 作用与 Hibernate / mybatis 之类的持久层框架类似. - 本文译自 Cayenne 4.0 版的官方文档 (Cayenne Getting Started Guide) - 译文的目的是为初学者快速了解 Cayenne 减少一些语言障碍. 若要深入研究和使用 Cayenne 建议至官方网站查阅更多相关文档.","text":"Cayenne 是一个 Apache 下的持久层框架项目, 作用与 Hibernate / mybatis 之类的持久层框架类似. - 本文译自 Cayenne 4.0 版的官方文档 (Cayenne Getting Started Guide) - 译文的目的是为初学者快速了解 Cayenne 减少一些语言障碍. 若要深入研究和使用 Cayenne 建议至官方网站查阅更多相关文档. 1. 设置环境 1.1 安装 Java 1.2 安装 IntelliJ IDEA 2. 学习映射基础 2.1 开始一个项目 2.2 开始对象关系映射 (ORM) 2.3 创建 Java 类 3. 学习 Cayenne API 3.1 从 ObjectContext 开始 3.2 开始使用持久层对象 3.3 检索对象 3.3 删除对象 4. 转换为Web应用程序 4.1 将 tutorial 项目转换为Web应用程序 1. 设置环境本章的目标是安装(或检查你是否已经安装)一个用于创建 Cayenne 应用程序的基本软件环境. 1.1 安装 Java显然, JDK 必须安装. Cayenne 4.0需要 JDK1.7 或更新版本. 1.2 安装 IntelliJ IDEA下载并安装IntelliJ IDEA Community Edition. 本教程基于版本2016.3, 仍然适用于任何最新的IntelliJ IDEA版本. 2. 学习映射基础2.1 开始一个项目本章的目标是在 IntelliJ IDEA 中创建一个包含基本 Cayenne 映射的新 Java 项目, 介绍 CayenneModeler 图形化工具, 展示了如何创建初始映射对象：DataDomain，DataNode，DataMap. 在 IntelliJ IDEA 中创建一个新项目在 IntelliJ IDEA 中选择File &gt; New &gt; Project…, 然后选择Maven并点击Next. 在如下截图所示的对话框中填写Group Id和Artifact Id, 点击Next. 在下一个对话框界面中你可以自定义项目存储路径并点击Finish. 现在你应该有了一个新的空项目. 下载并启动 CayenneModeler虽然稍后我们将使用 Maven 引入 Cayenne 运行时所需的 jar 文件到项目中, 这里你仍然需要下载 Cayenne 以使用 CayenneModeler 工具. 如果你已在使用 Maven, 你也可以从 Maven 启动 CayenneModeler. 这里我们将使用较传统的方式. 下载 最新版 CayenneModeler. 将分发包解压缩到文件系统中的某个位置, 然后按照特定于平台的说明启动 CayenneModeler. 在大多数平台上, 只需双击 CayenneModeler 图标即可启动. CaynenneModeler 的欢迎屏幕如下所示： 在 CayenneModeler 中创建新的映射项目单击欢迎屏幕上的 New Project按钮将出现一个包含单个DataDomain的新映射项目. DataDomain的含义将在用户指南的其他地方进行说明. 现在, 明白 DataDomain 是映射项目的根就足够了. 创建 DataNode下一个你需要创建的项目对象是DataNode. DataNode 是应用程序将连接到的单个数据库的描述. Cayenne映射项目可以连接多个数据库, 但现在, 我们只连接一个. 选择左侧的 “project”, 单击工具栏上的Create DataNode按钮图标 (或从菜单中选择Project &gt; Create DataNode), 一个新的 DataNode 就出现了. 现在你需要设置 JDBC 连接参数. 对于内存型数据库 Derby 你可以输入如下配置: JDBC Driver: org.apache.derby.jdbc.EmbeddedDriver DB URL: jdbc:derby:memory:testdb;create=true 这里我们创建了一个内存型数据库. 因此, 当你停止你的应用程序, 所有的数据将丢失. 在大多数实际的项目中, 你应该会连接一个实际将数据存储于磁盘的数据库, 但是对于这个简单的教程而言, 我们将使用内存数据库. 译注: 与传统的数据库 (如: mysql)不同, 内存型数据库可直接将数据加载到内存中来运行, 可理解为一个直接在内存中运行的关系型数据库. 本教程使用 Derby, 并在 DB URL 处配置 create=true, 这样可根据 CayenneModeler 建立的模型来自动生成数据库. 此外, 你需要改变 “Schema Update Strategy”. 从下拉菜列表中选择org.apache.cayenne.access.dbsync.CreateIfNoSchemaStrategy, 这样 Cayenne 将在应用程序启动时根据 ORM 映射在 Derby 中创建一个新的数据库. 译注: ORM - Object Relational Mapping, 对象关系模型 创建 DataMap现在你需要创建一个 DataMap. DataMap 是一个包含了所有映射信息的对象. 点击 “Create DataMap” 按钮 (或选择相应的菜单项). 注意, 新创建的 DataMap 将自动关联到你上一步创建的 DataNode. 若有多个 DataNode, 你可能需要手动选择一个合适的 DataNode. 换句话说, DataDomain 中的一个 DataMap 必须通过映射指向一个数据库描述. 除了其中的 “Java Package”, 你可以保留 DataMap 中的默认值. 在 “Java Package” 处输入org.example.cayenne.persistent`. 这个名称将应用于所有的持久层类. 保存项目在处理实际的映射前, 让我们来保存项目. 点击工具栏上的 “Save” 按钮, 指定存储路径到本节此前创建的tutorial IDEA 项目的src/main/resources子目录, 将项目保存在这里. 现在返回到 IDEA, 你将看到 2 个 Cayenne 的 XML 文件. 注意: XML 文件的存储路径并非随意. Cayenne 运行时将在应用程序的CLASSPATH中寻找cayenne-*.xml文件. 并且src/main/resources文件夹应是我们项目的 “类文件夹” (如果我们通过命令使用 Maven, 这里同样是 Maven 复制 jar 文件的位置). 2.2 开始对象关系映射 (ORM)本节的目标是学习如何使用 CayenneModeler 创建一个简单的对象关系模型. 我们将为如下的数据库模型创建一个完整的 ORM 模型. 在多数情况下, 你已经有一个数据库了. 此时可通过 “Tool &gt; Reengineer Database Schema” 来快速导入. 相对于手工映射, 这将节省你大量时间. 尽管如此, 明白如何手工创建映射也同样重要. 因此, 我们下面将演示”手工”方法. 译注: 关于如何使用 CayenneModel 逆向工程创建映射, 即上述的 “Reengineer Database Schema”, 可参看本博客的另一篇文章 “CayenneModeler 数据库逆向工程” 映射数据库表和列让我们回到 CayenneModeler, 在那里打开刚才新创建的项目, 然后添加 ARTIST 表。 数据库表在 Cayenne 映射中被称作 DbEntities（数据库实体, 可以是实际表或数据库视图）. 在左侧的项目树中选择 “datamap”, 点击 “Create DbEntity” 按钮 (或使用 “Project &gt; Create DbEntity” 菜单). 一个新的 DbEntity 即创建出来了. 在 “DbEntity Name” 字段中填入 “ARTIST”. 然后点击实体工具栏 (entity toolbar) 上的 “Create Attribute” 按钮, 将切换至 “Properties” 标签页并添加一个名为 “unitiledAttr” 的新属性 (这里属性即为数据库中表的列). 让我们将其重命名为 ID, 设置类型为INTEGER并标记为 PK (主键): 同样地, 添加 NAME VARCHAR(200) 和 DATA_OF_BIRTH DATE 属性. 重复以上步骤, 创建 PAINTING 和 CALLERY 实体, 以和本节开始部分的对象关系模型图一致. 映射数据库关系现在你需要指定 ARTIST, PAINTING, GALLERY 表之间的关系 (Relationship). 开始创建 ARTIST/PAINTING 表之间的一对多关系: 选择左边的 ARTIST DbEntity, 点击 “Properties” 标签页. 点击实体工具栏上的 “Create Relationship” 按钮, 将创建出一个名为 “untitledRel” 的关系. 选择 “Target” 为 “Painting” 点击 “Database Mapping” 按钮, 出现关系配置对话框. 在这里, 你可以为关系指定名称, 也可以指定其反向关系. 名称可以任意命名 (这其实是数据外键约束的名称), 但建议使用有效的 Java 标识符, 因为这将避免在以后的操作中重复输入. 我们将这个关系命名为 “paintings”, 而反向关系命名为 “artist” 点击右侧的 “Add” 按钮添加一个 Join “Source” 选择 “ID” 列, “target” 选择 “ARTIST_ID” 列. 现在, 关系信息将如下图所示: 点击 “Done” 按钮以确认更改并关闭对话框. 现在已经创建了两个关系: ARTIST -&gt; PAINTING 及其反向关系 ( PAINTING -&gt; ARTIST) . 你可能注意到 “paintings” 关系应该是 “to-many”, 但是 “To Many” 复选框未被选中. 让我们来调整一下: 选中 “paintings” 关系, 然后点击 PAINTING DbEntity, 取消选中 “artist” 关系的 “To Many” 使得反向关系变成 “to-one”. 重复以上步骤创建 PAINTING 到 GALLERY 的 many-to-one 关系, 把这两个关系分别命名为 “gallery” 和 “paintings”. 映射 Java 类现在数据库模式的映射已经完成. CayenneModeler 可以根据 DbEntities 来生成所有的 Java 类 (也称作 “ObjEntities”, 对象实体). 目前, 无法通过一次点击就生成整个 DataMap 的 Java 类. 因此, 我们将分别对每个表执行此操作. 选择 “ARTIST” DbEnity, 点击实体工具栏或主工具栏上的 “Create ObjEntity” 按钮. 一个名叫 “Artist” 的 ObjEntity 即被创建出来, 其 Java class 字段将设置为 “org.example.cayenne.persistent.Artist”. CayenneModeler 会将数据库中的名称转换为 Java 友好的名称 (例如, 如果单击 “属性” 选项卡, 你将看到 “DATE_OF_BIRTH” 列已转换为 “dateOfBirth” Java 类属性). 选择 “GALLERY” DbEntity 并再次点击 “Create ObjEntity” 按钮, 你将看到 “Gallery” ObjEntity 被创建出来了. 最后, 针对 “PAINTING” 执行相似的操作. 现在, 你需要同步关系. 在还没有相关的 “Painting” 实体之前, Artist 和 Gallery 实体就已经被创建了, 所以他们之间的关系还没有设置. 点击 “Artist” ObjEntity, 点击工具栏上的 “Sync ObjEntity with DbEntity” 按钮, 你将看到 “paintings” 关系出现了. 对 “Gallery” 实体做同样的操作. 除非你想要自定义 Java 类和属性名称 (你可以轻松搞定), 否则映射操作已经完成了. 2.3 创建 Java 类这里我们将从上一节中创建的模型生成 Java 类. CayenneModeler 也可用于生成数据库模式, 但由于我们在创建 DataNode 之前指定了 “CreateIfNoSchemaStrategy”，因此我们将跳过创建数据库模式步骤. 若有需要, 可通过 “Tools &gt;Create Database Schema” 来实现. 创建 Java 类 选择 “Tools &gt; Generate Classes” 菜单 “Type” 选中 “Standard Persistent Objects” (若未选中) “Output Directory” 选择你 IDEA 项目下的 “src/main/java” 文件夹 ( 这和我们此前选择的 cayenne-*.xml位置相关). 点击 “Classes” 选项卡, 选中 “Check All Classes” 复选框 ( 若已选中, 此复选框提示将变为 “Uncheck all Classes”). 点击 “Generate”. 现在回到 IDEA, 你应该看到每一个被映射的实体生成了一对类文件. 你可能还会看到 IDEA 中新生成的 Java 类旁边有一堆红色的波浪线. 这是因为我们的项目还没有将 Cayenne 加到 Maven 依赖. 让我们来将 “cayenne-server” 和 “cayenne-java8” artifacts 添加到 pom.xml文件的最后. 同样, 我们应该告诉 Maven 编译插件, 我们的项目需要 Java 8. 修改后的 POM 应像下面的样子: 12345678910111213141516171819202122232425262728293031&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example.cayenne&lt;/groupId&gt; &lt;artifactId&gt;tutorial&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;cayenne.version&gt;4.0.1&lt;/cayenne.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cayenne&lt;/groupId&gt; &lt;artifactId&gt;cayenne-server&lt;/artifactId&gt; &lt;version&gt;$&#123;cayenne.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- For java.time.* types you need to use this dependency--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cayenne&lt;/groupId&gt; &lt;artifactId&gt;cayenne-java8&lt;/artifactId&gt; &lt;version&gt;$&#123;cayenne.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; (1) 第 8 行: 指定你实际使用的 Cayenne 版本号 (2) 第 9 行: 告诉 Maven 支持 Java 8 你的计算机必须连接到 Internet. 一旦你编辑了pom.xml, IDEA 将下载所需的 Cayenne jar 文件并将其添加到项目构建路径. 此时, 所有的错误将消失了. 在 “控制台输出” 教程中, 我们使用 slf4j-simple 这个 logger 实现. 由于 Apache Cayenne 使用 SLF4J logger, 你可以通过桥接的方式使用你自己的 logger (例如: log4j 或 commons-logging). 译注: SLF4J 可理解为抽象的日志工具 ( logger ), 相对而言, slf4j-simple, log4j, commons-logging 等是更具体日志系统实现. 因 Cayenne 使用 SLF4J API 来输出日志, 所以在实际项目中你可以通过配置灵活地桥接不同的具体日志工具 (如: log4j) 来输出 Cayenne 日志. 现在让我们来检视一下实体类. 每一个实体生成了一个父类 (superclass, 如: _Artist) 和一个子类 (subclass, 如: Artist). 你不应该编辑那些以 “_” (下划线) 开头的父类, 因为它们将在后续重新运行生成命令时被覆盖. 所有的自定义逻辑应被放在org.example.cayenne.persistent包里的子类中 - 它们在生成类文件时不会被覆盖. 类生成提示: 通常你会从 CayenneModeler 开始生成类文件. 但是在后续的项目开发阶段, 通常会由 Ant cgen task 或 Maven cgen mojo 自动完成. 所有的这些方法都是可互相替代的, 但是使用 Ant 和 Maven 的方法可确保你不会忘记在映射发生变化时重新生成类文件, 因为他们被集成在了 build 阶段 3. 学习 Cayenne API3.1 从 ObjectContext 开始本节我们将写一个简单的 Main 类, 运行我们的程序, 以简要介绍 Cayenne ObjectContext. 创建 Main 类 在 IDEA 中创建一个名为 “Main” 的类, 将其置于 “org.example.cayenne” 包. 创建一个标准的 “main” 方法, 以使其成为一个可运行的类: 1234567package org.example.cayenne;public class Main &#123; public static void main(String[] args) &#123; &#125;&#125; 要访问数据库, 你要做的第一件事情是创建一个ServerRuntime对象 ( 它是 Cayenne 栈的一个基本封装 ) , 并使用它获得一个ObjectContext的实例. 1234567891011121314package org.example.cayenne;import org.apache.cayenne.ObjectContext;import org.apache.cayenne.configuration.server.ServerRuntime;public class Main &#123; public static void main(String[] args) &#123; ServerRuntime cayenneRuntime = ServerRuntime.builder() .addConfig(\"cayenne-project.xml\") .build(); ObjectContext context = cayenneRuntime.newContext(); &#125;&#125; 在 Cayenne 中ObjectContext是一个独立的 “会话 (session)”, 它提供了所有和数据打交道的 API. ObjectContext 拥有执行查询和管理持久层对象的方法. 我们将在后面的章节讨论它们. 当程序中的第一个 ObjectContext 被创建时, Cayenne 将加载 XML 映射文件并创建一个共享的访问栈, 它将在此后被其他 ObjectContext 重用. 运行程序让我们看看运行程序时会发生什么. 但在此之前我们需要添加其它的依赖到pom.xml: Apache Derby, 我们的嵌入式数据库引擎. 把下面的 XML 片段添加到&lt;dependencies&gt;…&lt;/dependencies&gt;部分 ( 那里已经有我们此前针对 Cayenne 的配置了 ). 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.derby&lt;/groupId&gt; &lt;artifactId&gt;derby&lt;/artifactId&gt; &lt;version&gt;10.13.1.1&lt;/version&gt;&lt;/dependency&gt; 现在我们已经可以运行程序了. 在 IDEA 中右键点击 “Main” 类, 选择 “Run ‘Main.main()’”. 在控制台中你将看到类似现在这样的输出, 这意味着 Cayenne 已经被启动了. 123456INFO: Loading XML configuration resource from file:/.../cayenne-project.xmlINFO: Loading XML DataMap resource from file:/.../datamap.map.xmlINFO: loading user name and password.INFO: Connecting to 'jdbc:derby:memory:testdb;create=true' as 'null'INFO: +++ Connecting: SUCCESS.INFO: setting DataNode 'datanode' as default, used by all unlinked DataMaps&lt;/screen&gt; 如何配置 Cayenne 日志按照 “日志” 一章中的说明调整日志的输出的详细程度. 译注: 这里所说的 “日志”一章并不在此教程中. 3.2 开始使用持久层对象本章我们将学习持久层对象, 如何自定义他们, 以及如何创建并将他们保存到数据库. 检视和自定义持久层对象Cayenne 中的持久层类实现了 DataObject 接口. 如果你检视本教程前面生成的任何类 (如: org.example.cayenne.persistent.Artist), 你将看到它继承了一个名称以下划线开头的类 (org.example.cayenne.persistent.auto._Artist), 而_Artist 又继承了 org.apache.cayenne.CayenneDataObject. 将每个持久化类拆分为用户可自定义的子类（Xyz）和 自动生成的父类（_Xyz）是一种很有用的技术, 可以避免在从建模工具中刷新类文件时覆盖自定义代码. 例如, 让我们在 Artist 类中添加一个实用的方法, 用于设置 Artist 的出生日期, 并为日期提供字符串参数. 即使映射模型稍后有变更, 它也将会被保留： 1234567891011121314151617181920212223242526public class Artist extends _Artist &#123; static final String DEFAULT_DATE_FORMAT = \"yyyyMMdd\"; /** * Sets date of birth using a string in format yyyyMMdd. */ public void setDateOfBirthString(String yearMonthDay) &#123; if (yearMonthDay == null) &#123; setDateOfBirth(null); &#125; else &#123; LocalDate date; try &#123; DateTimeFormatter formatter = DateTimeFormatter .ofPattern(DEFAULT_DATE_FORMAT); date = LocalDate.parse(yearMonthDay, formatter); &#125; catch (DateTimeParseException e) &#123; throw new IllegalArgumentException( \"A date argument must be in format '\" + DEFAULT_DATE_FORMAT + \"': \" + yearMonthDay); &#125; setDateOfBirth(date); &#125; &#125;&#125; 创建新对象现在我们将创建一些对象并将它们保存到数据库中. 使用 “newObject” 方法创建一个对象并将其注册到ObjectContext. 对象必须被注册到DataContext才能被持久化, 并允许设置与其他对象的关系. 将此代码添加到Main 类的 “main” 方法： 123Artist picasso = context.newObject(Artist.class);picasso.setName(\"Pablo Picasso\");picasso.setDateOfBirthString(\"18811025\"); 请注意，此时 “picasso” 对象仅存储在内存中, 还未保存在数据库中. 让我们继续添加大都会博物馆 (Gallery) 对象和一些毕加索的画作 (Paintings)： 12345678Gallery metropolitan = context.newObject(Gallery.class);metropolitan.setName(\"Metropolitan Museum of Art\");Painting girl = context.newObject(Painting.class);girl.setName(\"Girl Reading at a Table\");Painting stein = context.newObject(Painting.class);stein.setName(\"Gertrude Stein\"); 现在我们可以将这些对象联系起来, 建立关系. 注意, 以下每个语句都将自动地建立双向的关系 (如: picasso.addToPaintings(girl)与girl.setToArtist(picasso)有相同的效果). 12345picasso.addToPaintings(girl);picasso.addToPaintings(stein);girl.setGallery(metropolitan);stein.setGallery(metropolitan); 现在, 让我们调用 1 个方法来同时保存 5 个新对象: 1context.commitChanges(); 现在你可以按前一节介绍的方法来运行程序. 新的输出将显示一些实际的数据库操作: 1234567891011121314151617181920212223242526272829...INFO: --- transaction started.INFO: No schema detected, will create mapped tablesINFO: CREATE TABLE GALLERY (ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE ARTIST (DATE_OF_BIRTH DATE, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE PAINTING (ARTIST_ID INTEGER, GALLERY_ID INTEGER, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (ARTIST_ID) REFERENCES ARTIST (ID)INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (GALLERY_ID) REFERENCES GALLERY (ID)INFO: CREATE TABLE AUTO_PK_SUPPORT ( TABLE_NAME CHAR(100) NOT NULL, NEXT_ID BIGINT NOT NULL, PRIMARY KEY(TABLE_NAME))INFO: DELETE FROM AUTO_PK_SUPPORT WHERE TABLE_NAME IN ('ARTIST', 'GALLERY', 'PAINTING')INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES ('ARTIST', 200)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES ('GALLERY', 200)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES ('PAINTING', 200)INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:'ARTIST']INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:'GALLERY']INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:'PAINTING']INFO: INSERT INTO GALLERY (ID, NAME) VALUES (?, ?)INFO: [batch bind: 1-&gt;ID:200, 2-&gt;NAME:'Metropolitan Museum of Art']INFO: === updated 1 row.INFO: INSERT INTO ARTIST (DATE_OF_BIRTH, ID, NAME) VALUES (?, ?, ?)INFO: [batch bind: 1-&gt;DATE_OF_BIRTH:'1881-10-25 00:00:00.0', 2-&gt;ID:200, 3-&gt;NAME:'Pablo Picasso']INFO: === updated 1 row.INFO: INSERT INTO PAINTING (ARTIST_ID, GALLERY_ID, ID, NAME) VALUES (?, ?, ?, ?)INFO: [batch bind: 1-&gt;ARTIST_ID:200, 2-&gt;GALLERY_ID:200, 3-&gt;ID:200, 4-&gt;NAME:'Gertrude Stein']INFO: [batch bind: 1-&gt;ARTIST_ID:200, 2-&gt;GALLERY_ID:200, 3-&gt;ID:201, 4-&gt;NAME:'Girl Reading at a Table']INFO: === updated 2 rows.INFO: +++ transaction committed. Cayenne 首先创建了所需的表 (记住, 我们使用了 “CreateIfNoSchemaStrategy”). 然后, 它执行了许多 insert 语句, 即时生成了主键. 仅仅几行代码就完成了这些操作, 还不赖. 3.3 检索对象本节展示如何使用ObjectSelect从数据库中检索对象. ObjectSelect 介绍前面已经展示了如何持久化新对象. Cayenne 查询用来访问已存储的对象. 用于检索对象的主要查询类是ObjectSelect.它可以使用 CayenneModeler 进行映射或使用 API 创建. 本节我们将使用后一种方法. 虽然数据库中没有太多数据, 但我们仍然可以演示主要的方法, 如下: 检索所有的画作 (paintings), 代码及输出日志如下: 1List&lt;Painting&gt; paintings1 = ObjectSelect.query(Painting.class).select(context); 12INFO: SELECT t0.GALLERY_ID, t0.ARTIST_ID, t0.NAME, t0.ID FROM PAINTING t0INFO: === returned 2 rows. - took 18 ms. 检索名字以 “gi” 开头的作品, 忽略大小写 12List&lt;Painting&gt; paintings2 = ObjectSelect.query(Painting.class) .where(Painting.NAME.likeIgnoreCase(\"gi%\")).select(context); 123INFO: SELECT t0.GALLERY_ID, t0.NAME, t0.ARTIST_ID, t0.ID FROM PAINTING t0 WHERE UPPER(t0.NAME) LIKE UPPER(?) [bind: 1-&gt;NAME:&apos;gi%&apos;] - prepared in 6 ms.INFO: === returned 1 row. - took 18 ms. 检索所有出生成于 100 年前的画家的作品: 123List&lt;Painting&gt; paintings3 = ObjectSelect.query(Painting.class) .where(Painting.ARTIST.dot(Artist.DATE_OF_BIRTH).lt(LocalDate.of(1900,1,1))) .select(context); 123INFO: SELECT t0.GALLERY_ID, t0.NAME, t0.ARTIST_ID, t0.ID FROM PAINTING t0 JOIN ARTIST t1 ON (t0.ARTIST_ID = t1.ID) WHERE t1.DATE_OF_BIRTH &lt; ? [bind: 1-&gt;DATE_OF_BIRTH:&apos;1911-01-01 00:00:00.493&apos;] - prepared in 7 ms.INFO: === returned 2 rows. - took 25 ms. 3.3 删除对象本节介绍如何建模关系删除规则, 以及如何删除单个对象和对象集. 还将演示使用 Cayenne 类来执行查询. 设置删除规则在我们讨论对象删除的 API 之前, 让我们回到 CayenneModeler 进行一些删除规则设置. 这样做是可选 (并非必须) 的, 但可以简化已删除对象相关联的对象的处理. 在 CayenneModeler 中转到 “Artist” ObjEntity, “Relationships” 选项卡, 为 “paintings” 关系选择 “Cascade” 删除规则: 重复这个步骤设置其它关系: 针对 Gallery, 设置 “paintings” 关系为 “Nullify”, 因为可存在未在任何画廊展出的画作. 对于 Painting, 设置其两个关系规则均为 “Nullify”. 现在, 保存映射文件. 删除对象虽然可限定一个或多个 ID, 通过 SQL 删除对象. 但在 Cayenne (或一般的ORM) 中, 更常见的做法是先获取对象, 然后通过 context 删除它. 让我们使用工具类找到一位艺术家: 12Artist picasso = ObjectSelect.query(Artist.class) .where(Artist.NAME.eq(\"Pablo Picasso\")).selectOne(context); 现在删除这个艺术家: 1234if (picasso != null) &#123; context.deleteObject(picasso); context.commitChanges();&#125; 因为我们为 Artist.paintings 关系设置了 “Cascade” (级联) 删除规则, Cayenne 将自动删除所有此艺术家的作品. 因此, 当运行些程序时将看到如下输出: 12345678910111213INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 WHERE t0.NAME = ? [bind: 1-&gt;NAME:&apos;Pablo Picasso&apos;] - prepared in 6 ms.INFO: === returned 1 row. - took 18 ms.INFO: +++ transaction committed.INFO: --- transaction started.INFO: DELETE FROM PAINTING WHERE ID = ?INFO: [batch bind: 1-&gt;ID:200]INFO: [batch bind: 1-&gt;ID:201]INFO: === updated 2 rows.INFO: DELETE FROM ARTIST WHERE ID = ?INFO: [batch bind: 1-&gt;ID:200]INFO: === updated 1 row.INFO: +++ transaction committed. 4. 转换为Web应用程序本章介绍如何在Web应用程序中使用Cayenne. 4.1 将 tutorial 项目转换为Web应用程序此部分教程的 Web 部分是在 JSP 中完成的, 而 JSP 是 Java Web 技术中最常见的实现方法. 本教程在 UI 方面尽可能地简单, 主要专注于 Cayenne 集成, 而不是界面. 一个典型的 Cayenne Web 应用程序像下面这样工作： 在应用程序上下文启动时, 使用一个特定的 Servlet 过滤器加载 Cayenne 的配置 用户请求被过滤器拦截, 并将 DataContext 绑定到请求线程, 因此应用程序可以从任何地方轻松访问它. 同一个 DataContext 实例在单个用户会话 ( Session ) 中被重用; 不同的会话使用不同的 DataContexts ( 以及不同的对象集). 根据具体情况, 可以使用不同作用域的上下文 (Context). 本教程中我们将使用会话作用域上下文 ( session-scoped context) . 让我们将我们此前创建的 tutorial 项目转换为一个 Web 应用程序: 在 IDEA 中的 “tutorial” 项目文件夹下创建一个新的文件夹 src/main/webapp/WEB-INF. 在 WEB-INF 下创建一个新文件 web.xml ( 一个标准的Web应用程序描述文件 ): web.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt;&lt;web-app&gt; &lt;display-name&gt;Cayenne Tutorial&lt;/display-name&gt; &lt;!-- This filter bootstraps ServerRuntime and then provides each request thread with a session-bound DataContext. Note that the name of the filter is important, as it points it to the right named configuration file. --&gt; &lt;filter&gt; &lt;filter-name&gt;cayenne-project&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.cayenne.configuration.web.CayenneFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;cayenne-project&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 创建艺术家浏览页面 src/main/webapp/index.jsp, 包含如下内容: webapp/index.jsp 12345678910111213141516171819202122232425262728293031323334&lt;%@ page language=\"java\" contentType=\"text/html\" %&gt;&lt;%@ page import=\"org.example.cayenne.persistent.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.query.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.exp.*\" %&gt;&lt;%@ page import=\"java.util.*\" %&gt;&lt;% ObjectContext context = BaseContext.getThreadObjectContext(); List&lt;Artist&gt; artists = ObjectSelect.query(Artist.class) .orderBy(Artist.NAME.asc()) .select(context);%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Main&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Artists:&lt;/h2&gt; &lt;% if(artists.isEmpty()) &#123;%&gt; &lt;p&gt;No artists found&lt;/p&gt; &lt;% &#125; else &#123; for(Artist a : artists) &#123; %&gt; &lt;p&gt;&lt;a href=\"detail.jsp?id=&lt;%=Cayenne.intPKForObject(a)%&gt;\"&gt; &lt;%=a.getName()%&gt; &lt;/a&gt;&lt;/p&gt; &lt;% &#125; &#125; %&gt; &lt;hr&gt; &lt;p&gt;&lt;a href=\"detail.jsp\"&gt;Create new artist...&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 创建艺术家编辑页面 src/main/webapp/detail.jsp, 包含如下内容: webapp/detail.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%@ page language=\"java\" contentType=\"text/html\" %&gt;&lt;%@ page import=\"org.example.cayenne.persistent.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.query.*\" %&gt;&lt;%@ page import=\"java.util.*\" %&gt;&lt;%@ page import=\"java.text.*\" %&gt;&lt;%@ page import=\"java.time.format.DateTimeFormatter\" %&gt;&lt;% ObjectContext context = BaseContext.getThreadObjectContext(); String id = request.getParameter(\"id\"); // find artist for id Artist artist = null; if(id != null &amp;amp;&amp;amp; id.trim().length() &gt; 0) &#123; artist = SelectById.query(Artist.class, Integer.parseInt(id)).selectOne(context); &#125; if(\"POST\".equals(request.getMethod())) &#123; // if no id is saved in the hidden field, we are dealing with // create new artist request if(artist == null) &#123; artist = context.newObject(Artist.class); &#125; // note that in a real application we would so dome validation ... // here we just hope the input is correct artist.setName(request.getParameter(\"name\")); artist.setDateOfBirthString(request.getParameter(\"dateOfBirth\")); context.commitChanges(); response.sendRedirect(\"index.jsp\"); &#125; if(artist == null) &#123; // create transient artist for the form response rendering artist = new Artist(); &#125; String name = artist.getName() == null ? \"\" : artist.getName(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMdd\"); String dob = artist.getDateOfBirth() == null ? \"\" :artist.getDateOfBirth().format(formatter);%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Artist Details&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Artists Details&lt;/h2&gt; &lt;form name=\"EditArtist\" action=\"detail.jsp\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%= id != null ? id : \"\" %&gt;\" /&gt; &lt;table border=\"0\"&gt; &lt;tr&gt; &lt;td&gt;Name:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\" value=\"&lt;%= name %&gt;\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Date of Birth (yyyyMMdd):&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"dateOfBirth\" value=\"&lt;%= dob %&gt;\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align=\"right\"&gt;&lt;input type=\"submit\" value=\"Save\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行 Web 应用程序我们需要为应用程序提供 javax servlet-api. pom.xml 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 为运行这个 web 应用程序, 我们将使用 “maven-jetty-plugin”. 译注: jetty 是一个 Web 应用程序容器, 作用类似 Tomcat. 为激活他, 让我们添加如下代码片段到 pom.xml 文件, 跟在”dependencies” 节的后面, 然后保存 POM: pom.xml 123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.14.v20161028&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 转到 “Select Run/Debug Configuration” 菜单, 然后 “Edit Configuration…” 点击 + 按钮并选择 “Maven”. 按如下截图输入 “Name” 和 “Command line”: 点击 “Apply” 和 “Run”. 在首次运行时, 可能需要花费几分钟为 Jetty 插件下载所有的依赖, 最终你将看到如下日志输出: 1234567891011121314151617181920[INFO] ------------------------------------------------------------------------[INFO] Building tutorial 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------...[INFO] Configuring Jetty for project: tutorial[INFO] webAppSourceDirectory not set. Trying src/main/webapp[INFO] Reload Mechanic: automatic[INFO] Classes = /.../tutorial/target/classes[INFO] Logging initialized @1617ms[INFO] Context path = /[INFO] Tmp directory = /.../tutorial/target/tmp[INFO] Web defaults = org/eclipse/jetty/webapp/webdefault.xml[INFO] Web overrides = none[INFO] web.xml file = file:/.../tutorial/src/main/webapp/WEB-INF/web.xml[INFO] Webapp directory = /.../tutorial/src/main/webapp[INFO] jetty-9.3.0.v20150612[INFO] Started o.e.j.m.p.JettyWebAppContext@6872f9c8&#123;/,file:/.../tutorial/src/main/webapp/,AVAILABLE&#125;&#123;file:/.../tutorial/src/main/webapp/&#125;[INFO] Started ServerConnector@723875bc&#123;HTTP/1.1,[http/1.1]&#125;&#123;0.0.0.0:8080&#125;[INFO] Started @2367ms[INFO] Started Jetty Server&lt;/screen&gt; 这样 Jetty 容器就成功启动了. 现在, 打开 http://localhost:8080/ . 你应该在浏览器中看到 “No artists found message” 页面, 并在 IDEA 的控制台中看到如下输出: 1234567891011121314151617181920INFO: Loading XML configuration resource from file:/.../tutorial/target/classes/cayenne-project.xmlINFO: loading user name and password.INFO: Connecting to &apos;jdbc:derby:memory:testdb;create=true&apos; as &apos;null&apos;INFO: +++ Connecting: SUCCESS.INFO: setting DataNode &apos;datanode&apos; as default, used by all unlinked DataMapsINFO: Detected and installed adapter: org.apache.cayenne.dba.derby.DerbyAdapterINFO: --- transaction started.INFO: No schema detected, will create mapped tablesINFO: CREATE TABLE GALLERY (ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE ARTIST (DATE_OF_BIRTH DATE, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE PAINTING (ARTIST_ID INTEGER, GALLERY_ID INTEGER, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (ARTIST_ID) REFERENCES ARTIST (ID)INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (GALLERY_ID) REFERENCES GALLERY (ID)INFO: CREATE TABLE AUTO_PK_SUPPORT ( TABLE_NAME CHAR(100) NOT NULL, NEXT_ID BIGINT NOT NULL, PRIMARY KEY(TABLE_NAME))...INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 ORDER BY t0.NAMEINFO: === returned 0 rows. - took 17 ms.INFO: +++ transaction committed.&lt;/screen&gt; 你可以点击 “Create new artist” 链接以来创建一个艺术家. 点击已存在的艺术家的名字可以编辑他: 你已完成本教程!","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"持久层","slug":"持久层","permalink":"https://baileykm.github.io/tags/持久层/"},{"name":"Cayenne","slug":"Cayenne","permalink":"https://baileykm.github.io/tags/Cayenne/"}]},{"title":"使用 GitHub + Hexo 搭建个人博客","slug":"使用GitHub+Hexo搭建个人网站","date":"2019-05-01T14:00:00.000Z","updated":"2019-05-10T20:01:22.382Z","comments":true,"path":"2019/05/01/使用GitHub+Hexo搭建个人网站/","link":"","permalink":"https://baileykm.github.io/2019/05/01/使用GitHub+Hexo搭建个人网站/","excerpt":"您现在所看到的这个博客即是使用 GitHub + Hexo 搭建的, 本文介绍如何使用 GitHub + Hexo 搭建个人博客.","text":"您现在所看到的这个博客即是使用 GitHub + Hexo 搭建的, 本文介绍如何使用 GitHub + Hexo 搭建个人博客. 搭建流程 安装 Git 安装 Node.js 创建 GitHub 个人仓库 生成 SSH密钥并添加到 GitHub 安装 Hexo 使用 Hexo 创建个人网站并发布到 GitHub 配置参数 撰写博文 预览 生成静态网站 将静态网站发布到 GitHub 后记 先做几个名词解释: Git : 目前流行的的分布式版本控制系统, 由 Linux 之父 Linus 开发. GitHub : 知名的 Git 仓库, 世界各地的程序猿(媛)可以将自己编写的代码分享到 GitHub 以供别人下载使用, 当然 GitHub 上也有很多优秀的项目可供我们下载研究或使用, 总之, GitHub 对于程序猿(媛)而言是一个非常不错的资源. 国内用户访问 GitHub 往往较慢, 有时甚至无法连接, 可以使用国内的 Git 托管服务: 码云. Hexo : 一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。关于 Hexo的详细介绍及使用方法参见Hexo 官方网站 Markdown : 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML/HTML文档. (摘自维基百科) 搭建流程 安装 Git 安装 Nodejs 安装 Hexo 创建 GitHub 个人仓库 生成 SSH密钥并添加到 GitHub 使用 Hexo 创建网站 使用 Markdown 语法编写文章 使用 Hexo 将 Markdown 语法编写的文章转换成静态网站 使用 Hexo 将网站发布到 GitHub 安装 GitGit 工具用于本地电脑与 GitHub 进行文件同步, 安装方法如下: Windows： 下载并安装 Git. Linux: sudo apt-get install get Mac：使用 Homebrew, MacPorts ：brew install git; 或下载 安装程序 安装. Mac 环境下顺道安装一下 xcode-select , xcode 安装好后终端下执行如下代码即可 xcode-select –install 安装 Node.jsHexo 是基于 Node.js 编写的, 所以需要安装一下 Node.js 及其 npm工具. Node.js 可使用直接下载 安装程序 来安装. 选择一个 LTS 版本安装, Hexo 需要 Node.js 为 6.9 或更高版本. 当然, Node.js 绝非只是为 Hexo 而生, 它还有很多大用途. 建议自学一下 Node.js 创建 GitHub 个人仓库登录到 GitHub , 若没有 GitHub 账号自行注册一个即可. 登录GitHub 后创建一个新仓库, 仓库名应为: 用户名.github.io , 例如本网站创建的仓库名为: baileykm.github.io 仓库名必须按上述要求命名. 用户名即为 GitHub 账号名, 因此您只能在 Github 上创建一个个人网站 生成 SSH密钥并添加到 GitHub这里我们需要生成 SSH 密钥并添加到 GitHub 它才能让你从远程通过工具访问 GitHub 中的仓库. Windows 环境打开git bash, Mac 打开终端, 执行如下命令: 12git config --global user.name \"yourname\"git config --global user.email \"youremail\" yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱. 可以用以下两条，检查一下你有没有输对 12git config user.namegit config user.email 然后创建SSH 1ssh-keygen -t rsa -C \"youremail\" 这个时候它会告诉你已经生成了.ssh 的文件夹, 在你的电脑中找到这个文件夹. 而后在 GitHub 的 Setting 中，找到SSH keys 的设置选项，点击 New SSH key, 把你的id_rsa.pub里面的信息复制进去。 SSH，简单来讲，就是一个密钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到 GitHub 上。 安装 Hexo安装 Hexo 前，您必须检查电脑中是否已安装下列应用程序： Node.js (6.9版本或以上) Git 完成上述两个必要程序的安装后, 执行如下命令即可完成 Hexo 的安装: 1$ npm install -g hexo-cli Mac 下可能由于权限问题提示安装失败, 可执行 sudo npm install -g hexo-cli –unsafe-perm 使用 Hexo 创建个人网站并发布到 GitHub初始化完成 Hexo 安装后, 在任意位置创建一个文件夹(名称随意), 在命令行下进入所创建的文件夹, 执行如下命令, Hexo 将创建网站所需的文件及子文件夹: 12$ hexo init$ npm install 配置参数修改根目录中的 _config.yml 文件, 可更改大部分的网站配置. 注意对_config.yml 文件中的如下部分进行配置: #Site 部分 : title : 网站标题 subtitle : 副标题 author : 作者 #URL 部分： url : 设置为您网站的 url. 例如本网站配置为: url: https://baileykm.github.io #Deployment 部分: type : git repo : 配置为访问个人仓库的 url. 例如本网站配置为: repo: https://github.com/baileykm/baileykm.github.io.git branch : master 其他配置可参见 https://hexo.io/zh-cn/docs/configuration 撰写博文执行如下命令将会在 source/_posts 文件夹下创建 一个新的 Markdown 文件 (.md), 文件名默认为命令中指定的 &quot;文章标题&quot;. 编辑此新生成的 Markdown 文件以撰写你的博文. 1$ hexo new \"文章标题\" 本文不涉及 Markdown 语法的介绍, 如有必须请查阅其他资料. 网上有大量介绍 Markdown 的文章, Markdown 语法本身并不复杂, 找个教程看看, 跟着实践一下很快就可上手. 很多 IDE 自带 Markdown 编辑功能, 如: IntelliJ IDEA, VSCode 等, 也有很多专门的 Markdown 编辑工具. 有工具的助力, 撰写博文可能更方便和直观. 预览执行 hexo server 将在本地启动个人网站 (默认使用 4000 端口), 你可以打开浏览器访问 http://localhost:4000 以预览网站效果. 如果不满意, 修改 Markdown 文件后重新预览即可. 生成静态网站执行 hexo generate 或 hexo g 将在 public 文件夹中生成静态的个人网站 将静态网站发布到 GitHub执行hexo deploy 或 hexo d 即可将生成的静态网站发布到 GitHub. 发布过程中会要求输入 GitHub 用户名和密码. 后记Hexo 支持丰富的配置、 插件与主题, 本文由于篇幅所限未作详细介绍. 如果希望把你的个人博客建得更漂亮而富有个性, 建议浏览 Hexo 官方网站. 网上不乏关于如何使用 GitHub + Hexo 搭建个人博客的优秀教程, 本人之所以重复”造轮子”, 写这篇博文主要是为了将自己的搭建过程记录下来, 算是做个笔记. 人老了就是这样, 过几天自己做过的事情都忘记了~","categories":[{"name":"杂项","slug":"杂项","permalink":"https://baileykm.github.io/categories/杂项/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://baileykm.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://baileykm.github.io/tags/GitHub/"}]},{"title":"Web-lighter 简介","slug":"Web-lighter-一个小型的-Java-Web-服务器端封装","date":"2018-05-31T18:54:04.000Z","updated":"2019-05-17T04:25:00.093Z","comments":true,"path":"2018/06/01/Web-lighter-一个小型的-Java-Web-服务器端封装/","link":"","permalink":"https://baileykm.github.io/2018/06/01/Web-lighter-一个小型的-Java-Web-服务器端封装/","excerpt":"web-lighter 是笔者实现的一个小型 Java Web 应用程序的服务端封装, 曾在多个项目中应用, 对于小型 Web 项目开发而言, 实践证明确实可以省不少事. 因此, 将其共享出来, 若有需要, 拿去用便是.","text":"web-lighter 是笔者实现的一个小型 Java Web 应用程序的服务端封装, 曾在多个项目中应用, 对于小型 Web 项目开发而言, 实践证明确实可以省不少事. 因此, 将其共享出来, 若有需要, 拿去用便是. web-lighter 能做什么? 先来个例子 安装 Web-lighter Web-lighter 使用方法概要 Web-lighter 配置与使用详述 web-lighter.xml @Request @Param @Inject ActionResult @Upload @Download 取名 web-lighter 有 2 个意图: 作为一个称谓, 便于文中叙述. 此项目的初衷想为 Java Web 项目开发添把火, 力图让小型的 Web 项目开发变得更轻松一些, 故名web-lighter. web-lighter 项目源代码可至 https://github.com/baileykm/web-lighter 下载. 本文内容基于 web-lighter 1.1.0 版本 web-lighter 能做什么? 分发 HTTP Request : 接收Http请求并分发给用户自定义的 Action-Method 进行处理, 并将处理结果发回前端 HTTP Request 参数的自动解析与注入( 支持 text / json ) Action 类自动实例化与执行 ( Action 为用户自定义逻辑的封装 ) 基于Java注解 ( Annotation ) 的注入配置 多文件上传支持 文件下载支持 ( 可添加下载鉴权逻辑 ) 先来个例子为了尽快能对 web-lighter 有一个初步的认识, 我们举个简单的例子, 了解一下 web-lighter 的基本用法, 以及它的基本功能. 为了让例子变得尽可能地简单, 其间省略了部分安装与配置 web-lighter 的过程, 如果看完本例仍有兴趣继续尝试使用 web-lighter 请继续阅读本文后续内容, 否则, 直接关闭本页面便是. OK, 开始吧… 使用你喜欢的 IDE 创建一个动态 Java Web 项目 (步骤略) 将 Web-lighter 的 Jar 文件及其依赖添加到项目构建路径 (参见下节 “Web-lighter 安装”, 支持 Maven) 创建一个 Java 类 (ActionExample.java), 代码如下: 1234567891011121314151617181920212223242526272829303132333435import com.bailey.web.lighter.action.ActionResult;import com.bailey.web.lighter.action.ActionSupport;import com.bailey.web.lighter.annotation.Param;import com.bailey.web.lighter.annotation.Request;import java.util.List;public class ActionExample extends ActionSupport &#123; // 继承 ActionSupport, 后文称这样的类为 Action 类 @Request(url = \"/doSomeThing\") // Request注解标注此方法可以接收的 url, 后文称这样的方法为 Action 方法 (Action-Method) public ActionResult doSomeThing( @Param(name = \"intParam\") Integer id, // 上行参数, 整型 @Param(name = \"strParam\") String str, // 上行参数, 字符串类型 @Param(name = \"voParam\") VO vo, // 上行参数, 值对象, 可用于接收前端传来的对象数据 @Param(name = \"voArrParam\") List&lt;VO&gt; voArr // 上行参数, List&lt;VO&gt;, 可用于接收前端传来的数组数据 ) &#123; try &#123; System.out.println(\"intParam = \" + id); System.out.println(\"strParam = \" + str); System.out.println(\"vo = &#123;id : \" + vo.getId() + \", name : \" + vo.getName() + \"&#125;\"); for (int i = 0; i &lt; voArr.size(); i++) &#123; System.out.println(\"voArr[\" + i + \"] = &#123;id : \" + voArr.get(i).getId() + \", name : \" + voArr.get(i).getName() + \"&#125;\"); &#125; // ... 执行其它业务 // 成功, 直接将前端传来的voParam回传 return ActionResult.success(vo); &#125; catch (Exception ex) &#123; // 抛出异常时向前端返回错误信息 return ActionResult.failure(\"Something wrong\"); &#125; &#125;&#125; 上述代码中涉及的 VO 类可根据实际业务需要定义为一个普通的 JavaBean 类, 例如: 123456789public class VO &#123; private Integer id; private String name; public void setId(Integer id) &#123; this.id = id;&#125; public void getId() &#123; return id;&#125; public void setName(String name) &#123; this.name = name;&#125; public void getName() &#123; return name;&#125;&#125; 创建 HTML 页面 exmaple.html , 引入 jQuery, 并嵌入如下 javascript 脚本: 1234567891011121314151617181920212223242526272829var params = &#123; \"intParam\" : 1, \"strParam\" : \"This is a string.\", \"voParam\" : &#123; \"id\" : 999, \"name\" : \"Peter\" &#125;, \"voArrParam\": [&#123; \"id\" : 10, \"name\" : \"John\" &#125;,&#123; \"id\" : 20, \"name\" : \"Joanna\" &#125;]&#125;;$.ajax(&#123; type : \"post\", url : \"wl/doSomeThing\", // 注意 url 前缀 \"wl\" contentType: \"application/json\", // 注意contentType取值 dataType : 'json', data : JSON.stringify(params), // 将 js 对象转为 JSON 字符串上行 success : function(data)&#123; alert(JSON.stringify(data)); // 输出服务器返回的信息 &#125;, error : function() &#123; alert('error!'); &#125;&#125;); 启动 Web 项目, 在浏览器中打开 exmaple.html, 如: 在地址栏中输入 运行结果: 服务器控制台输出: 12345intParam = 1strParam = This is a string.vo = &#123;id : 999, name : Peter&#125;voArr[0] = &#123;id : 10, name : John&#125;voArr[1] = &#123;id : 20, name : Joanna&#125; 前端浏览器输出: 1&#123;\"code\":0,\"result\":&#123;\"id\":999,\"name\":\"Peter\"&#125;&#125; 小结 通过上例可以看到 web-lighter 可通过简单地继承 com.bailey.web.lighter.action.ActionSupport 并配合必要的注解即可将一个普通的 Java 类转化为可接收并处理前端请求的 Action 类. 这也是 web-lighter 的基本功能. web-lighter 可将前端发来的数据作为 Action 方法的形参注入, 以便使用. (若上行数据为 JSON 格式则自动进行解析, 并注入) web-lighter 可自动将服务器端需要反馈给前端的数据封装后返回前端 (通过在 Action 方法中返回 ActionResult 的实例 ). 若有必要将自动序列化为 JSON 格式字符串. 如前所述, 上例仅简单展示了 web-lighter 的基本功能, 关于 web-lighter 的安装与详细使用方法, 请继续阅读后文. 安装 Web-lighter可使用 maven 方式安装 web-lighter, 或手动安装: Maven 安装web-lighter 已发布至 Maven Central Repository , 如果你的项目使用 Maven 则可将下面的代码复制到 pom.xml 文件中的 &lt;dependencies&gt;...&lt;/dependencies&gt; 一节即可. 12345&lt;dependency&gt; &lt;groupId&gt;com.github.baileykm&lt;/groupId&gt; &lt;artifactId&gt;web-lighter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 手动安装: 下载 web-lighter.jar 及第3方资源, 复制到 Web 项目的 WEB-INF/lib 下, 并将其添加至项目构建路径. web-lighter 依赖于如下第3方资源: commons-fileupload-1.3.3.jarcommons-io-2.2.jarcommons-lang3-3.7.jargson-2.8.4.jarslf4j-api-1.7.25.jarUserAgentUtils-1.2.4.jarweb-lighter-1.1.0.jar Web-lighter 使用方法概要 安装 web-lighter 及依赖资源 定义 Action 类, 以封装你的业务逻辑. ( Action 类须继承 com.bailey.web.lighter.action.ActionSupport ) 在 Action 类中添加必要的 HTTP Request 处理方法 ( Action方法 )3.1 在 Action方法 上添加 @Request 注解, 以标注该方法可以响应的特定的 HTTP 请求3.2 为 Action方法 形参表中的参数添加 @Param注解 或 @Inject注解, 以说明参数值的来源3.3 在 Action方法 体中编写你的业务处理代码, 并最终返回 ActionResult实例 若需要支持文件上传或下载, 可同时在 Action方法 上添加 @Upload和@Download 注解 Web-lighter 配置与使用详述web-lighter.xml此文件为 web-lighter 的主配置文件, 可自定义关于 web-lighter 的一些通用配置. web-lighter.xml 配置文件并非必需, 也就是说, 若上述默认配置已满足你的需求, 则可省去 web-lighter.xml . web-lighter.xml 中可配置的信息包括: 参数 默认值 取值 说明 urlPrefix /wl String url 前缀web-lighter 将按路径匹配方式拦截需要处理的请求, 即默认状态下, web-lighter 将拦截所有 url 以 “/wl” 开头的 HTTP 请求. 因此, 编写前端代码时应注意为 url 加上前缀, 例如: http://localhost:8080/wl/doSomething 你可以直接创建一个 XML 文件或从 web-lighter_xxx.jar 中复制一份放到 src 根目录即可. web-lighter.xml 文件格式如下:1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;configuration&gt; &lt;urlPrefix&gt;/wl&lt;/urlPrefix&gt;&lt;/configuration&gt; @Request@Request 注解应用于 Action 方法上, 以标注该方法用于接收并处理 HTTP 请求 Action 为用户自定义 HTTP 请求处理逻辑的封装, 应继承 com.pr.web.lighter.action.ActionSupport 参数 默认值 取值 说明 url null String 可接收并处理的请求 url支持通配符和参数, 如:/{param1}/*.action/{param2}其中, * 代表匹配任意个任意字符, {param1} 表示此为参数占位, 其中的 param1为参数名 注意- web-lighter 使用路径匹配方式拦截前端请求, 默认情况下, 若请求的 url 匹配模式 “/wl/“ 时将被 web-lighter 拦截并处理. 若需要更改拦截匹配模式, 请在 web-lighter.xml 配置文件中进行设置.- 前端访问路径记得添加路径前缀 ( 默认为”/wl” ), 如: http://localhost:8080/wl/doSomething.action- 本注解的 url 参数无需添加路径前缀, 如: /doSomething, 运行时 web-lighter 将会匹配 /wl/doSomething- 虽然 url 中支持类似 RESTful Web 风格的参数, 但 web-lighter 暂未完全支持 RESTful Web 的标准方法 format ParamFormat.json ParamFormat.jsonParamFormat.text HTTP 请求中参数的格式, 默认为 JSON 格式Content-Type = “application/json” 时此参数无效 ( 始终被理解为JSON 格式数据) @Param@Param 注解应用于 Action 方法的形参, 以说明该形参对应 HTTP 请求中的哪一个参数 ( 属性 ) 参数 默认值 取值 说明 name data String HTTP 请求中的参数名 web-lighter 会自动从 HTTP 请求中获取参数值并在方法调用时自动注入.若 HTTP 请求中参数为 JSON 格式, 同时 @Request 的 format 取值为 ParamFormat.json ( 默认值 ), 则将自动解析此 JSON 数据, 并封装为形参所需要的对象. 特别地, 若 @Request 中 url 设置带有参数占位, 则调用 Action 方法时亦将同时注入从 HTTP 请求的 url 中解析得到的参数. 例如: Action 方法为: 12345@Request(url=\"/&#123;p1&#125;/doSomething/&#123;p2&#125;\")public ActionResult doSomething( @Param(name = \"p1\") String str, @Param(name = \"p2\") Integer id)) &#123; ... &#125; 此时若 HTTP 请求的 url 为: http://localhost:8080/test/doSomething/999，则在 doSomething 方法内参数 str 和 id 的值将分别为 “test” 和 999 @Inject@Inject 注解应用于 Action 方法的形参. 此注解可用于在方法执行时, 将其它对象作为参数注入.例如, 如下代码可在调用 doSomething 方法时自动实例化一个 Service 对象, 并注入. 1public ActionResult doSomething( @Inject Service service ) &#123; ... &#125; Service通常用于封装一些具体的业务功能, 而 Action主要负责接收前端请求, 实现业务调度. 使用@Inject时要求 Service类可以通过new Service()或 Service.getInstance()的方式获得Service对象. ActionResult每一个 Action 方法 (带@Request的方法) 均必须返回一个 ActionResult 对象, 其中封装了欲向前端回传的数据. ActionResult 对象将最终被序列化为 JSON 格式, 并返回前端. ActionResult 包含如下属性: 属性 数据类型 含意 code int 状态码, 标识业务处理结果. 默认情况下, 正确 ( 成功 ) 为 0, 错误 ( 失败 ) 为 -1 result Object 回传的业务数据. 若非 String 类型则自动序列化为 JSON 字符串 message String 附加消息, 用于将提示信息带回前端, 例如: 出错原因 total Long 全部记录数. 通常用于分页查询时返回符合条件的记录总数 上述属性均为私有 ( private ) 属性, ActionResult 类定义了数个静态方法 ( static ), 用于返回 ActionResult 实例. 例: 如下为 Action 类代码 1234567891011121314151617181920public class ExampleAction extends ActionSupport &#123; @Request(url = \"/doSomething\") public ActionResult doSomething() &#123; List&lt;Map&lt;String, Object&gt;&gt; users = new ArrayList&lt;&gt;(); Map&lt;String, Object&gt; user; user = new HashMap&lt;&gt;(); user.put(\"id\", 1); user.put(\"name\", \"Peter\"); users.add(user); user = new HashMap&lt;&gt;(); user.put(\"id\", 2); user.put(\"name\", \"John\"); users.add(user); return ActionResult.success(users, \"It's Ok!\", 100L); &#125;&#125; 前端访问 http://localhost:8080/wl/doSomething 时将收到如下JSON 字符串: 123456789101112&#123; \"code\": 0, \"result\": [&#123; \"id\": 1, \"name\": \"Peter\" &#125;, &#123; \"id\": 2, \"name\": \"John\" &#125;], \"message\": \"It's Ok!\", \"total\": 100&#125; @Upload@Upload 注解应用于 Action 方法上, 以标注该方法可支持文件上传 ( 单个 / 多个文件 ) 参数 默认值 取值 说明 uploadDir upload String 上传文件的保存路径. 默认为网站根目录下的 upload 子目录 nameRule * String 文件在服务器端的命名规则规则中的星号 ( “*“ ) 表示此部分使用 UUID 替换如: “ tmp_* “ 表示使用 “ tmp_ “ + 32位UUID 作为文件名文件扩展名始终与原文件一致 maxFileSize 1024 * 1024 * 40 int 单个文件的最大字节数. 默认40M maxRequestSize 1024 * 1024 * 50 int 请求的最大字节数. 默认50M 注意: HTML 中文件上传 form 的 enctype 属性应为 multipart/form-data @Download@Download 注解应用于 Action 方法上, 以标注该方法用于支持前端文件下载 可在 Action 方法中添加必要的逻辑, 以判定是否允许下载指定的资源. Action 处理方法应始终返回一个 ActionResult 实例. 若禁止下载指定资源, 应返回标记为”失败”的 ActionResult 实例, 如: return ActionResult.failure(&quot;您无权下载此资源&quot;); 若允许下载指定资源, 则应返回标记为”成功”的 ActionResult 实例, 同时将资源信息带回, 例如: 12345678// ...File file = new File(\"C:\\\\serverFile.docx\"); // 待下载的文件. 亦可是 InputStream String clientFileName = \"你的文档.docx\"; // 客户端保存时的默认文件名// 返回标记为\"成功\"的 ActionResult 实例// DownloadFileInfo 对象用于封装待下载文件的信息// 亦可直接使用输入流构造 DownloadFileInfo 对象return ActionResult.success(new DownloadFileInfo(file, clientFileName)); 关于 web-lighter 的介绍到这里就结束了, 叙述中有不妥之处欢迎指正. 当然也欢迎提出宝贵意义或参与到本项目中来, 让我们一直努力将她变得更好.","categories":[{"name":"Web开发","slug":"Web开发","permalink":"https://baileykm.github.io/categories/Web开发/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"Web-lighter","slug":"Web-lighter","permalink":"https://baileykm.github.io/tags/Web-lighter/"}]},{"title":"CayenneModeler 数据库逆向工程","slug":"CayenneModeler-数据库逆向工程","date":"2018-05-07T19:08:18.000Z","updated":"2019-05-10T19:59:15.244Z","comments":true,"path":"2018/05/08/CayenneModeler-数据库逆向工程/","link":"","permalink":"https://baileykm.github.io/2018/05/08/CayenneModeler-数据库逆向工程/","excerpt":"实际的项目开发中, 我们可能需要根据已有的数据库模型来创建Cayenne的配置文件和相关的实体类. 此时可以使用CayenneModeler的Reengineer工具来直接生成相关的文件. 下面将演示如何使用CayenneModeler Reengineer 来进行数据库逆向工程.","text":"实际的项目开发中, 我们可能需要根据已有的数据库模型来创建Cayenne的配置文件和相关的实体类. 此时可以使用CayenneModeler的Reengineer工具来直接生成相关的文件. 下面将演示如何使用CayenneModeler Reengineer 来进行数据库逆向工程. Reengineer Database Schema 创建 DataNode 保存配置信息 生成实体类文件 Reengineer Database Schema 启动CayenneModeler, 新建一个工程 ( File &gt; New Project ) 选择 Reengineer Database Schema 菜单 ( Tools &gt; Reengineer Database Schema ) 点击如下图中红色箭头所示的按键, 创建一个数据源 (DataSource) 在 “Edit Preferences” 窗口中点击 “New”, 创建一个本地数据源 (Local DataSource). 填写数据源名称 (Name), 并选择要使用的适配器 (Adapter). 若连接的是MySQL数据库, 可选择如下图所示的 “org.apache.caynne.dba.mysql.MySQLAdapter” 适配器.本教程以MySQL数据库为例 在 “Local DataSources” 标签页中, 填写 JDBC Driver, DB URL, User Name 和 Password, 如下图所示: 同时注意检查如下配置: (1) General 标签页中 File Encoding 选择 UTF-8 (2) ClassPath 标签页中, 点击 “Add Jar/Zip”, 选择数据库驱动程序 (如: mysql-connector-java-xxx.jar) 点击 “Save”, 返回上一窗口, 选择刚才新建的本地数据源. 此时可再次点击 “Saved DataSources” 后面的 “…” 按钮, 并点击弹出窗口中的 “Test” 按钮来测试数据源配置信息是否正确, 是否能成功连接数据库 点击 “Continue”, 在弹出的 “Reengineer DB Schema: Select Options” 窗口 (如下图) 中可配置要映射哪些数据库表/视图. (Table Name Pattern 为 “%” 表示映射所有表/视图, 本例保留默认值, 未作更改) 点击 “Continue”, CayenneModeler 即会根据数据库模型自动生成 Cayenne 的 DbEntity 和 objEntity. 同时, 外键关系等信息也一同被映射回来了. (展开project节点, 可看到映射结果, 如下图所示) 创建 DataNode DataNode 中保存了我们的程序与特定的某一个数据库连接的信息. 右键点击上图中的 “datamap” 节点, 选择 “create Data Node”, 创建一个DataNode. 在出现的如下图所示的界面中配置 DataNode 信息. 其中 DataNode Configuration 中保持默认值, 主要进行JDBC Configuration的配置. Cayenne自带数据库连接池, 下图中 Min Connections 和 Max Connections 即分别是连接池的最小连接数与最大连接数的配置. 再次选择 “datamap” 节点, 并对 datamap 进行配置, 可按如下步骤操作 (参看下图): (1) 在左侧树状视图中选中 “datamap”(2) “DataMap Configuration” 中的 “DataNode” 选择刚才创建的DataNode(3) “Entity Defaults” 中的 “Java Package” 填写实体类的包名 (最终生成的实体类将自动生成于此包中)(4) 点击 “Java Package” 后的 “Update” 按钮. 至此 CayenneModeler 中的配置即算初步完成了. 保存配置信息 点击 CayenneModeler 工具栏中的保存按钮 (或选择菜单 File &gt; Save) 将配置信息保存在 Java 工程的 src 目录下 (注意保存位置应在Java工程的src根目录) 生成实体类文件 选择主菜单项 Tools &gt; Generate Classes, 生成实体类文件 在弹出的如下图所示的窗口中注意检查如下内容: (1) Output Directory 应指向 Java 工程的 src 目录(2) Classes 标签页中选中了所示实体类 下图箭头所指的 “SuperClass Package” 处为会在 “datamap” 的 “Java Package” 设置的包名后加上 .auto, 这并非错误. Cayenne会为实体类自动创建一个父类, 此处的SuperClass Package为父类包名 ( 参看: “Cayenne入门指南” ) 点击 “Generate” 按钮即完成实体类文件的创建. (若你使用Eclipse, 则回到Eclipse, 刷新Java工程即可看到生成的配置文件和实体类文件) 好了, 现在快写一个测试程序, 测试一下Cayenne是否正常工作吧! 参看: “Cayenne入门指南”, 3.3 学习Cayenne API PS: 若数据库中表的主键为”自增长(Auto-incremented)”型, 注意在CayenneModeler中设置相应数据库对象 (DbEntity) 的 “PK Generation Strategy” 为 “Database-Generated”. 如下图: CayenneModeler生成的实体对象 (objEntity) 并未将主键字段直接映射为 objAttribute, 若程序中需直接通过类似 user.getId() 的方式获得主键值, 可在 CayenneModeler 中手动添加主键字段的映射. 如下图:","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"持久层","slug":"持久层","permalink":"https://baileykm.github.io/tags/持久层/"},{"name":"Cayenne","slug":"Cayenne","permalink":"https://baileykm.github.io/tags/Cayenne/"}]},{"title":"持久层框架 Cayenne 推介","slug":"持久层框架Cayenne推介","date":"2018-04-21T01:02:47.000Z","updated":"2019-05-10T14:24:59.536Z","comments":true,"path":"2018/04/21/持久层框架Cayenne推介/","link":"","permalink":"https://baileykm.github.io/2018/04/21/持久层框架Cayenne推介/","excerpt":"说起持久层框架, Hibernate 和 mybatis (早期版本名为 ibatis) 应该不少人都听过或使用过, 虽然无从考证上述两个持久层框架的市场份额, 但在国内应算是较为流行的两个框架. 本文推荐另一系出名门 ( The Apache Software Foundation ) 的持久层框架 Cayenne, 经过本人在几个项目中的试用, 个人觉得不错.","text":"说起持久层框架, Hibernate 和 mybatis (早期版本名为 ibatis) 应该不少人都听过或使用过, 虽然无从考证上述两个持久层框架的市场份额, 但在国内应算是较为流行的两个框架. 本文推荐另一系出名门 ( The Apache Software Foundation ) 的持久层框架 Cayenne, 经过本人在几个项目中的试用, 个人觉得不错. 大名鼎鼎的 Hibernate 可能是很多人接触的第一个持久层框架. 它与Struts、 Spring 组成的SSH组合对于程序猿而言就如偶像团体SHE对于追星族般如雷贯耳. 介绍Hibernate的书籍和资料几乎已经到了泛滥成灾的地步. 本人也曾在多个项目中使用过Hibernate, 其强大的功能确实为程序开发带来了不少便利. 找一本入门的书或网上下载一个入门教程, 跟随教程的步骤相信运行起一个简单的例程估计不是什么大问题, 但随着项目复杂度的增加, 配置和使用也同样变得复杂, 偶尔可能还需要应用一些性能优化方面的”技巧”. 面对如此庞大的框架, 不经意间抛出的运行时异常着实让人无从下手.另一持久层框架:mybatis 同样也拥有不少粉丝, 本人也一度是其拥趸者. 相对于Hibernate, 其拥有另一种风格的配置和使用方式, 但面对那密密麻麻的XML配置文件, 以及事必躬亲的查询配置, 本人开始犯懒了…… 当然, 一些配套的工具或插件可以帮我们干不少繁重的工作, 也许还有一些优秀的辅助工具本人未尝见识, 不敢枉加评论.说了这么多, 并无贬低上述两个持久层框架的意思, 无论什么工具总有其优缺点, 《人月神话》中有句话叫做“没有银弹”, 这里只是想向大家介绍一个我认为被国人雪藏的优秀持久层框架: Cayenne. (至少就相关的文档和教程而言, 相对前两个框架要少得多), 初步使用后有些体会, 仅供参考. 关于配置配置文件与Hibernate和mybatis类似, 使用XML文件(Hibernate也支持注解方式配置), 里面虽然也是令人头大的密密麻麻的映射关系说明, 但官方提供了可视化的建模工具CayenneModeler, 可自动生成XML配置文件和Java持久层的实体类. 此工具支持数据库反向工程(根据已有的数据库提取表/视图结构和外键关系, 自动生成映射文件), 同样也支持在建模工具中直接创建数据模型后将表和关系生成到数据库中. 这个工具还是比较强大的, 至少在目前本人实践的几个小项目中很少出现需要手动去修改XML文档的情况. 关于查询Cayenne提供了多种查询方式: SelectQuery 最常用的方式, 例如: 要查询满足条件的Artist集合 12SelectQuery query = new SelectQuery(Artist.class, qual);List artists = ctxt.performQuery(query); 其中条件由参数qual (Expression类型) 带入, qual 则可由Cayenne提供的ExpressionFactory来生成.ExpressionFactory提供很多静态方法来生成Expression, 例如: 12Expression.fromString(\"artistName = $aname\"); // 根据字符串来生成带参数的查询条件ExpressionFactory.matchExp(\"artistNae\", \"Picasso\") // artistName = \"Picasso\" 当然, 如果你有很多个Expression 组成的List, 现在需要将它们使用And连接起来, 那可以这样: 1Expression qual = ExpressionFactory.joinExp(Expression.AND, list); 总之, ExpressionFactory 还是相当强大的, 这有点类似mybatis的Criterion, 但似乎更胜一筹. 本人比较懒, 就不再一一列举了, 请各位看官方文档. SQLTemplate Query 这种方式可以支持设定目标数据库方言(SQL Dialect), 也就是使用目标数据库原生的SQL语法来查询. 例如:SQLTemplate rawSelect = new SQLTemplate(Artist.class, “select * from ARTIST”);注意, 大写的ARTIST是数据库中的表名, 而非Java类名. 如果我们要使用数据库提供的一些函数, 那这种方式再合适不过了.当然, 它还可以相对灵活地配置从数据库查来的数据怎么转化成Java实体对象. EJBQLQuery 使用EJBQL 语法的查询. 呵呵, 什么是EJBQL语法? 看例子……1EJBQLQuery query = new EJBQLQuery(\"select p from Painting p WHERE p.estimatedPrice &gt; 3000\"); 呵呵, 是不是很像标准的SQL, 只是注意 from 后面的Painting是Java实体类名. 严格的定义请参阅 JPA 吧…… NamedQuery 顾名思义, 命名查询, 先定义好查询语句, 取个名字, 然后在程序中调用. ObjectIdQuery 根据实体的ID查 RelationshipQuery 根据关联实体查 ProcedureQuery 不用说了吧, 面向存储过程查 呵呵, 越来越懒了…… 总之查询方式很灵活. 对于大多数的情况, 其实第1种方式已经足够了. 其他 一般而言在Cayenne里, 查询总会有一个称为 Root 的东东. 回头看一下前面的代码, 例如: 通过 new SelectQuery(Artist.class, qual); 来构造SelectQuery时, 参数Artist.class就告诉Cayenne把查询结果封装成Artist类型的实体对象集合. 然后, 我们就可以拎着一个Java 实体对象, 通过它 getter 方法方便地得到与之关联的主表和从表数据, 如果关联表的数据尚未提取到内存Cayenne会自动从数据库中获取. 如果你担心所谓的 “N+1”查询问题, 那可在执行查询之前使用addPrefetch方法设定预提取的主表或从表. 对于分页、提取前N行数据、Distinct这样的查询要求, Cayenne也提供了现成方法, 执行查询之前调用一下就行, 它会根据目标数据库自行处理. 数据缓存支持. 这对查询性能改善不小, Hibernate当然也有这个东东. 这里多说一句, 要维持缓存中的数据与数据库中数据的一致性, 以及保持缓存中同一行数据的唯一性是一个不小的问题. 特别是后者, 如果一个持久层框架不能很好地保证同ID的实体对象在缓存中的唯一性, 那当我们引入MVC后, 再把持久层框架提供的实体对象用作Module你就去哭吧…… PS: 之前使用Hibernate的时候遇到过Hibernate抛出异常提示存在多个同ID实体, 然后…… 就没有然后的情况, 当然我只能说肯定是我代码的问题了, 不然要被Hibernate粉丝的口水淹死, 但这种运行时异常确实难Debug. 可配置拦截器和监听器.不晓得什么是拦截器和监听器?OK, 科普一下…… 它们是设计模式里的东东, 这里的拦截器可以简单理解为当Cayenne要向数据库发指令之前你可以把指令截获, 然后做一些判断或处理, 如果你愿意还可以阻止指令的执行. 监听器那就是根据你的配置, Cayenne在向数据库发指令之前或之后会调用你指定的监听函数, 当然监听器不会干扰Cayenne的工作, 人家只是干活之前或之后知会你一声, 并不是要征求你的意见 (这一点不像拦截器).好了, 科普完了. 那支持这两个东东有什么好处呢? 我们可以干些底层一点的事情, 举个例子: 我们要记录下是谁在什么时候修改了员工信息, 如果有监听机制,我们只需要监听员工这个实体类的Update事件, 然后调用写日志功能就行, 代码只需要写一个地方; 但如果没有监听机制, 那就得在所有可能修改员工信息的地方调用写日志的函数. 再比如…… MVC模型下作为Module层的东东向Control层发通知. 另外, 写在Cayenne监听器里也是个不错的选择. 好吧, 码字真的很累, 头上开始冒小星星了… 还有一些其它的优点, 各位自己玩吧~ 相对Hibernate和mybatis而言, Cayenne的中文资料要少得多, 百度一下Cayenne这个单词, 大多出来的结果都是关于卡宴车的介绍, 本人愚见, 由此多少可以看出这个框架在国内程序猿中的普及程度并不是很高. 如果能有个小项目具体实践一下, 相信你会有自已的看法. 谁用谁知道, 呵呵~ 提供2个学习材料: [1] Cayenne官方网站, 里面有Tutorial, Guide 等最权威的文档. [2] Cayenne入门指南, 本人翻译自Cayenne官方入门教程(Cayenne Getting Started Guide)","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"持久层","slug":"持久层","permalink":"https://baileykm.github.io/tags/持久层/"},{"name":"Cayenne","slug":"Cayenne","permalink":"https://baileykm.github.io/tags/Cayenne/"}]},{"title":"Cayenne 起步 (Version 3.1) [译]","slug":"Cayenne入门指南","date":"2018-04-20T17:37:12.000Z","updated":"2019-05-11T17:10:44.577Z","comments":true,"path":"2018/04/21/Cayenne入门指南/","link":"","permalink":"https://baileykm.github.io/2018/04/21/Cayenne入门指南/","excerpt":"Cayenne 是一个 Apache 下的持久层框架项目, 作用与 Hibernate / mybatis 之类的持久层框架类似. - 本文译自 Cayenne 3.1 版的官方文档 (Cayenne Getting Started Guide) - 译文的目的是为初学者快速了解 Cayenne 减少一些语言障碍. 若要深入研究和使用 Cayenne 还是建议直接阅读官方原版文档. - Apache Cayenne 官方已发布了 Cayenne 4.0 版本, 为方便小伙伴们学习, 我同样将 4.0 版的 “Cayenne Getting Started Guide” 译成中文了, 若没有特殊原因, 就别看这个教程了, 去看 “Cayenne 起步 (Version 4.0)“吧","text":"Cayenne 是一个 Apache 下的持久层框架项目, 作用与 Hibernate / mybatis 之类的持久层框架类似. - 本文译自 Cayenne 3.1 版的官方文档 (Cayenne Getting Started Guide) - 译文的目的是为初学者快速了解 Cayenne 减少一些语言障碍. 若要深入研究和使用 Cayenne 还是建议直接阅读官方原版文档. - Apache Cayenne 官方已发布了 Cayenne 4.0 版本, 为方便小伙伴们学习, 我同样将 4.0 版的 “Cayenne Getting Started Guide” 译成中文了, 若没有特殊原因, 就别看这个教程了, 去看 “Cayenne 起步 (Version 4.0)“吧 1. 配置环境 1.1 安装Java 1.2 安装Eclipse IDE 和 Maven插件 2. 映射(mapping)基础 2.1. 开始一个项目 2.2. 对象关系映射入门（ORM） 2.3. 创建Java类 3. 学习Cayenne API 3.1. ObjectContext 入门 3.2. 开始使用持久层对象 3.3. 检索对象 3.4. 删除对象 4. 转换为Web应用程序 4.1. 将 tutorial 项目转换为 Web应用程序 - 另附对Cayenne的相关知识阐述更全面的 Cayenne Guide 链接: https://cayenne.apache.org/docs/3.1/cayenne-guide 1. 配置环境本章的目标是安装（或检查您是否已安装）构建Cayenne应用程序所需的最低软件环境. 1.1 安装Java显然，JDK 必须安装. Cayenne 3.1需要 JDK 1.5 或 更高版本. 1.2 安装Eclipse IDE 和 Maven插件 译注: Maven是一个项目管理工具, 本教程主要使用它来进行项目所依赖的 jar 的管理(自动下载) 下载Eclipse. 本教程基于Galileo JEE版本的Eclipse(Eclipse 3.5), 但它同样适用于最新的其它Eclipse通用版本. Eclipse下载完后, 解压并运行之. 对本教程而言, 你唯一需要安装的插件是m2eclipse. 选择Eclipse菜单 “Help &gt; Install New Software”, 然后点击 “Add…” 添加一个新的下载站点(download site), 在 “Name” 输入框中输入 “Maven”, “Location”框中输入http://m2eclipse.sonatype.org/sites/m2e. 你可以选择任何你想要的可选组件, 但是对本教程而言, 你只需要选择最少的基本组件即可, 如下图: 按照Eclipse对话框中的提示, 完成安装. 2. 映射(mapping)基础2.1. 开始一个项目本章目标是创建一个包含基本Cayenne映射(Cayenne mapping)的Java项目. 其中展示 CayenneModeler 图形化工具的使用,演示如何创建初始的映射对象: DataDomain, DataNode, DataMap. 译注: CayenneModeler 是 Cayenne的一个图形化建模工具, 使用此工具可比较直观且自动化地创建 Cayenne 持久层对象模型所需各类文件 在Eclipse中创建一个新项目在Eclipse中选择 “File &gt; New &gt; Other…​”, “Maven &gt; Maven Project”.点击 “Next”. 在接下来的界面中选中 “Create a simple project” 复选框, 再次点击 “Next”.对话框中显示如下图所示内容, 填写 “Group Id” 和 “Artifact Id” 并点击 “Finish”. 现在, 在Eclipse的workspace里应该有一个空的项目. 检查一下这个项目的Java编译设置是否正确.右键单击 “tutorial” 项目, 选择 “Properties &gt; Java Compiler”, 确保 “Compiler compliance level”至少为 “1.5” (一些版本的Maven插件似乎会默认将其设置为1.4) 下载并运行CayenneModeler尽管在本教程中稍后我们将使用Maven来导入Cayenne的运行时所需的jar文件到项目中, 你仍然需要下载Cayenne 以便可以使用 CayenneModeler 工具. 如果你直接使用Maven, 你也可以从Maven直接启动CayenneModeler. 这里我们使用更传统的文件来做. 下载最新的发布版. 解压到任意位置, 根据特定操作系统平台的要求启动 CayenneModeler. 在大多数平台下, 只需要简单地双击 Modeler 的图标即可.Modeler的欢迎界面如下图: 在 CayenneModeler 中创建一个新的映射项目(Mapping Project)在欢迎界面中点击 New Project 按钮即会出现一个新的 Mapping 项目, 并包含一个DataDomain. DataDomain 的含意将会在本教程的其他地方解释.现在你只需要知道 DataDomain 是你的Mapping项目的根. 创建一个DataNode你需要创建的下一个项目对象是 DataNode. DataNode 是你应用程序将要连接的单个数据库的描述.Cayenne 的 mapping 项目可应用于多于一个数据库的情况, 但是现在我们仅使用一个数据库. 选中左侧的 “project”, 点击工具栏上的 Create DataNode 按钮 ( 或者在菜单中选择Project &gt; Create DateNode ), 一个新的DataNode就出现了. 现在你需要指定JDBC连接参数.如果使用内存型数据库 Derby, 那你可以输入如下的配置: JDBC Driver: org.apache.derby.jdbc.EmbeddedDriver DB URL: jdbc:derby:memory:testdb;create=true 这里我们创建了一个内存型数据库(in-memory database). 因此, 当你停止你的程序时, 所有的数据将会丢失. 在更多实际的项目中, 你应该会连接一个实际将数据存储于磁盘的数据库, 但是对于这个简单的教程而言, 我们将使用内存数据库. 译注: 与传统的数据库(如mysql)不同, 内存型数据库可直接将数据加载到内存中来运行, 可理解为一个直接在内存中运行的关系型数据库. 本教程使用 Derby, 并在 DB URL 处配置 create=true, 这样可根据 CayenneModeler 建立的模型来自动生成数据库. 同时, 你需要更改 “Schema Update Strategy”. 在下拉列框中选择 org.apache.cayenne.access.dbsync.CreateIfNoSchemaStrategy,这样当程序启动时, Cayenne 将会根据对象关系模型映射(ORM mapping)信息在Derby中创建一个新的数据库模式(Schema). 创建一个DataMap现在, 你将要创建一个 DataMap. DataMap 是一个包含了所有映射信息的对象. 点击工具栏上的 “Create DataMap” 按钮 (或选择相应的菜单项). 注意, 新创建的 DataMap 将自动关联到上一步骤中创建的 DataNode. 如果有多于一个DataNode, 你应该手动关联 DataMap 到正确的 DataNode. 也就是说, 在 DataDomain 中的一个 DataMap 必须通过指定关联来指向一个数据库描述. 在DataMap的配置中, 除了 “Java Package”, 你都可以保留DataMap的默认配置. 在 “Java Package” 框中输入 “org.example.cayenne.persistent”. 这个包名将在随后应用于所有的持久层类. 保存项目在你进行实际的映射配置之前, 让我们先保存一下这个项目. 点击工具栏上的 “Save” 按钮, 并指定保存路径到本章前面创建的名为 “tutorial” 的 Eclipse 项目的文件夹中的子文件夹 “src/main/resources”, 并将项目保存在这里. 现在, 回到 Eclipse, 右键点击 “tutorial” 项目, 并选择 “Refresh(刷新)”, 你将看到3个 Cayenne 的 XML 文件. ( 译注: 原文为3个, 但我只看到2个) 注意, XML文件的存放位置不是随意的. Cayenne 运行时将在应用程序的 CLASSPATH 寻找 cayenne-*.xml 文件. src/main/resources 文件夹应成为Eclipse中我们项目的”class folder”.( 如果我们以命令行方式使用Maven, 那上述位置也是 Maven 复制 jar 文件的标准目标位置 ) 译注: 按前面一段的步骤保存项目文件到 “src/main/resources” 就行了, 对于 Eclipse 中创建的 Maven 项目 “src/main/resources” 默认就是在CLASSPATH中的. 如果你没有使用 Maven, 可直接保存到 src 根目录即可. 2.2. 对象关系映射入门（ORM）本节的目标是学会怎么使用 CayenneModeler 来创建一个简单的对象关系模型 ( Object-Relational model, ORM ). 我们将为以下数据库模式创建一个完整的 ORM 模型： 通常情况下, 你已经有创建好了的数据库, 那你可以通过菜单 “Tools &gt; Reengineer Database Schema” 将其快速导入到 Cayenne 中. 相比手工映射, 这将节省你很多时间. 但是, 懂得如何手工创建映射同样重要,因此, 我们下面将演示手工操作的方法. 映射数据库表和列让我们回到 CayenneModeler, 打开新我们新创建的项目, 并开始添加 ARTIST 表. 在 Cayenne 映射中, 数据库表被称作 DbEntities ( 可以是实际的表或视图 ). 在左边项目树中选中 “datamap”, 点击工具栏上的 “Create DbEntity” 按钮 ( 或使用菜单 “Project &gt; Create DbEntity” ), 一个新的 DbEntity 即被创建出来了. 在 “DbEntity Name” 字段输入 “ARTIST”. 然后点击实体工具栏(entity toolbar, 译注:就是下图右侧详情区域上方的二级工具栏 ) 上的 “Create Attribute” 按钮切换到 “Attribute” 标签页, 并新增一个名叫 “untitledAttr” 的属性( Attribute, 这里的 attribute 对应一个表中的列 ). 让我们将其重命名为ID, 并设置为 INTEGER 和 ‘PK’ ( 主键 ): 类似地, 增加 NAME VARCHAR(200) 和 DATE_OF_BIRTH DATE 属性. 然后, 重复上述过程, 创建如前面数据库模式图中所示的 PAINTING 和 GALLERY 实体. 不要忘记定期保存你的项目, 以免丢失你所做的工作.因为 Eclipse 默认情况下并不会自动感知建模工具中所做的修改, 所以, 每次 CayenneModeler 保存后,你都应该在 Eclipse 中刷新项目. 映射数据库关系现在我们需要指定 ARTIST, PAINTING 和 GALLERY 表之间的 ( 外键 ) 关系. 首先创建一对多的 ARTIST/PAINTING 关系: 选择左边的 ARTIST DbEntity, 并点击 “Relationship” 标签页 点击实体工具栏上的 “Create Relationship” 按钮 , 一个名为 “untitledRel” 的关系即被创建出来. 选择 “Target” 为 “PAINTING” 点击右侧工具栏上的 “Database Mapping” 按钮, 即会弹出关系配置对话框.在这里你可以给关系取个名字, 同样也可以给反向关系取名. 这个名字可以任取 ( 这实际上是数据库参考约束的一个符号名称 ), 但是, 更推荐使用 Java 标识符, 因为稍后这个名字将被以同样的拼写方式保存下来. 我们将这个关系称作”paintings”, 反向关系称作 “artist”.译注: 这里的关系即 ARTIST 表和 PAINTING 表之间一对多的外键约束, 关系名称即对于一个 ARTIST 来说 PAINTING 表的数据是它的什么, 而反向关系即: 对于一个 PAINTING 来说, ARTIST 是它的什么. 呵呵, 有点绕~ 简单说, 对于一个艺术家( ARTIST ) 而言PAINTING 表中的数据是它的画作, 而对于 PAINTING 表中的一条数据而言, ARTIST 表的对应数据是这幅画的作者 点击右边的 “Add” 按钮 “Source” 选择 “ID” 列, “Target” 选择 “ARTIST_ID” 列 关系信息应如下图所示: 点击 “Done” 以确认所做的修改并关闭对话框. 两个关系已经被创建: 从 ARTIST 到 PAINTING 的关系, 以及反向的关系. 不过你可能注意到有件事忘记了: “paintings” 关系应该是 to-many, 但是 “To Many” 复选框并没有选中.让我们来改一下: 选中 “paintings” 关系的 “To Many” 复选框, 同时, 点击 PAINTING DBEntity, 取消 “artist” 关系的 “To Many” 复选框以设置反向关系, 因为反向的 PAINTING 指向 ARTIST 的关系应该是多对一(to-one). 重复前面的步骤, 以建立从 PAINTING 到 GALLERY 的多对一关系, 让我们将这对关系命名为 “gallery” 和 “paintings”. 映射 Java 类现在, 数据库模式已经映射完成, CayenneModeler 可以根据DbEntity中的所有内容来创建Java类的映射(又称作 “ObjEntity”). 目前还不能直接通过一次点击就完所有的 DataMap 映射, 因此我们将逐个表来做. 选择 “ARTIST” DbEntity 并点击实体工具栏或主工具栏上的 “Create ObjEntity” 按钮, 一个名为 “Artist” 的 ObjEntity 即被创建出来, 同时 Java class 输入框的值被设置为 “org.example.cayenne.Artist”. 建模工具会将数据库中的名称转换为 Java 风格的名称 ( 例如: 如果你点击 “Attributes” 标签页, 将看到 “DATA_OF_BIRTH” 列被转换为 Java 类属性 “dateOfBirth” ). 选择 “GALLERY” DbEntity 并再次点击 “Create ObjEntity” 按钮, 你将看到一个 “Gallery” ObjEntity 被创建出来. 最后, 为 “PAINTING” 做同样的操作. 现在, 你需要同步关系. 因为在还没有相关联的 “Painting” 实体 ( objEntity ) 之前, Artist 和 Gallery 实体就已经被创建出来了. 因此, 他们之间的关系并未被自动设置. 点击 “Artist” ObjEntity. 点击工具栏上的 “Sync ObjEntity with DbEntity” 按钮, 你会看到出现了 “paintings” 关系 对 “Gallery” 实体做同样的操作. 除非你想要自定义 Java 类和属性名 ( 你可以很容易地做到 ), 映射已经完成了. 2.3. 创建Java类这里我们将根据前面章节中创建的模型生成 Java 类. CayenneModeler 同样可用来生成数据库模式, 因为在我们先前创建 DataNode 的时候指定了 “CreateIfNoSchemaStrategy”, 因此我们将跳过创建数据库模式的步骤. ( 译注: 因为设置了CreateIfNoSchemaStrategy策略, 建模工具会自动创建相应的数据库模式 ) 如果你有需要, 可通过 “Tools &gt; Create Database Schema” 做到这一点 ( 生成数据库模式 ). 创建 Java 类 选择 “Tools &gt; Generate Classes” 菜单 “Type” 选择 “Standard Persistent Objects” ( 如果没有选中的话 ) “Output Directory” 选择你项目下的 “src/main/java” 文件夹 ( 这是与之前我们为 cayenne-*.xml 选择的位置同等的位置 ) 点击 “Classess” 标签, 选中 “Check All Classes” 复选框 点击 “Generate” 现在回到 Eclipse, 右键点击 “tutorial” 项目选择 “Refresh” - 你应该看到每个被映射的实体生成了两个类.你可能也注意到, 有一堆红色的波浪线在 Eclipse 中新出现的 Java 类旁边. 译注: 应该是红色的小叉叉吧~ 这是因为我们的项目还没有将 Cayenne 作为 Maven 的依赖包含进来.让我们来修复它, 在 pom.xml 文件的最下面插入 “cayenne-server” artifact.最终的POM应该像这样:123456789101112131415&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example.cayenne&lt;/groupId&gt; &lt;artifactId&gt;tutorial&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cayenne&lt;/groupId&gt; &lt;artifactId&gt;cayenne-server&lt;/artifactId&gt; &lt;!-- 在这里指定你实际想使用的 Cayenne 版本. 译注: 建议使用3.1.1这样的RELEASE版本, 而不是SNAPSHOT版本 --&gt; &lt;version&gt;3.1.3-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 你的电脑必须连上Internet.一旦你保存了 pom.xml, Eclipse 会自动下载 Cayenne 所需的 jar 文件, 并将其添加到项目构建路径 ( build path ). 最终, 所有的错误就消失了. 现在, 让我们来看一下实体类. 每个实体都有一个父类 ( 如: _Artist ) 和一个子类 ( 如: Artist ). 你不应该修改名称以”_” ( 下划线 ) 开头的父类, 因为他们将会在后续生成器运行的时候被覆盖. 应该把所有的自定义逻辑放在 “org.example.cayenne.persistent” 包的子类中(Artist), 这些子类不会被类生成器覆盖. 类生成提示通常你会先从 CayenneModeler 生成类, 但是在项目的后期阶段, 通常通过Ant cgen task 或 Maven cgen mojo 自动生成代码. 这三种方法均可, 但 Ant 和 Maven 方法可以确保您不会忘记在映射更改时重新生成类, 因为它们已集成到构建周期中. 3. 学习Cayenne API3.1. ObjectContext 入门本节我们将写一个简单的 main 类来运行我们的应用程序, 并对 Cayenne ObjectContext 作简单的介绍. 创建 Main 类 Eclipse中, 在 “org.example.cayenne” 包中创建一个新的类, 命名为 “Main” 创建一个标准的 “main” 方法, 以使其成为一个可运行的类: 1234567package org.example.cayenne;public class Main &#123; public static void main(String[] args) &#123; &#125;&#125; 要访问数据库首先要做的是创建一个 ServerRuntime 对象 ( 这实质上是对Cayenne的一个封装 ), 并使用它获得一个 ObjectContext 的实例. 12345678910111213package org.example.cayenne;import org.apache.cayenne.ObjectContext;import org.apache.cayenne.configuration.server.ServerRuntime;public class Main &#123; public static void main(String[] args) &#123; ServerRuntime cayenneRuntime = new ServerRuntime( \"cayenne-project.xml\"); ObjectContext context = cayenneRuntime.getContext(); &#125;&#125; 在 Cayenne 中, ObjectContext 是一个独立的 “Session”, 它提供了处理数据所需的所有API. ObjectContext 拥有执行查询和管理持久层对象的方法. 我们将在后续的章节中讨论它们. 当应用程序中的第一个 ObjectContext 被创建时, Cayenne 将加载 XML 映射文件, 并创建共享的访问接口, 这将可被后续创建的其它 ObjectContext 重用. 运行应用程序让我们来看一下运行程序时发生了什么. 但是在此之前, 我们需要添加其它的依赖 ( Apache Derby - 我们的嵌入式数据库引擎 ) 到 pom.xml. 下面这段XML代码需要添加到 &lt;dependencies&gt;…​&lt;/dependencies&gt; 部分, 在这里我们之前已经添加过 Cayenne 所需的 jar:12345&lt;dependency&gt; &lt;groupId&gt;org.apache.derby&lt;/groupId&gt; &lt;artifactId&gt;derby&lt;/artifactId&gt; &lt;version&gt;10.8.1.2&lt;/version&gt;&lt;/dependency&gt; 现在我们可以运行了. 在 Eclipse 中右键单击 “Main” 类, 选择”Run As &gt; Java Application”. 在控制台你将看到类似如下的输出. 这表示 Cayenne 已经被启动起来了:123456INFO: Loading XML configuration resource from file:cayenne-project.xmlINFO: loading user name and password.INFO: Created connection pool: jdbc:derby:memory:testdb;create=true Driver class: org.apache.derby.jdbc.EmbeddedDriver Min. connections in the pool: 1 Max. connections in the pool: 1 如何配置Cayenne的日志按照日志一章中的介绍, 调整日志记录输出的详尽程度. 译注: 我没找到所谓”日志一章” 3.2. 开始使用持久层对象本节我们将学习关于持久层对象的知识, 如何定义它们, 如何创建并将其保存到数据库. 检视和定义持久层对象在 Cayenne 中持久层类实现了一个数据对象 ( DataObject ) 接口. 如果你查看本教程此前生成的任何一个类 ( 如:org.example.cayenne.Artist ), 你会看到它继承了一个名称以下划线开头的类( 如: org.example.cayenne._Artist), 而这个类又继承了 org.apache.cayenne.CayenneDataObject. 将每一个持久层类分解为一个用户自定义子类 ( Xyz ) 和一个自动生成的父类 ( _Xyz ) 是一个很有用的技术, 它将避免在刷新映射模型时覆盖自定义的代码. 让我们来举个例子, 添加一个工具方法到 Artist 类中, 用于设置出生日期. 此方法接收一个字符型的日期参数. 即使后续模型发生变化, 这个方法亦将被保护 ( 避免被建模工具修改 ) :123456789101112131415161718192021222324public class Artist extends _Artist &#123; static final String DEFAULT_DATE_FORMAT = \"yyyyMMdd\"; /** * Sets date of birth using a string in format yyyyMMdd. */ public void setDateOfBirthString(String yearMonthDay) &#123; if (yearMonthDay == null) &#123; setDateOfBirth(null); &#125; else &#123; Date date; try &#123; date = new SimpleDateFormat(DEFAULT_DATE_FORMAT) .parse(yearMonthDay); &#125; catch (ParseException e) &#123; throw new IllegalArgumentException( \"A date argument must be in format '\" + DEFAULT_DATE_FORMAT + \"': \" + yearMonthDay); &#125; setDateOfBirth(date); &#125; &#125;&#125; 创建新对象现在我们将创建一组对象, 并将其保存到数据库. 使用 ObjectContext 的”newObject”方法可创建并注册一个对象. 对象必须被注册到 DataContext 才能被持久化, 也才能被允许设置与其它对象的关系. 添加如下代码到 Main 类的 “main” 方法中:123Artist picasso = context.newObject(Artist.class);picasso.setName(\"Pablo Picasso\");picasso.setDateOfBirthString(\"18811025\"); 注意, 此时对象 picasso 仅被存储于内存中, 还未被保存到数据库. 让我们继续添加一个名为 Metropolitan Museum 的 “Gallery” 对象, 和一些毕加索的画作( Paintings ).12345678Gallery metropolitan = context.newObject(Gallery.class);metropolitan.setName(\"Metropolitan Museum of Art\");Painting girl = context.newObject(Painting.class);girl.setName(\"Girl Reading at a Table\");Painting stein = context.newObject(Painting.class);stein.setName(\"Gertrude Stein\"); 现在我们可以把这些对象关联起来, 建立关系. 注意, 在下面的每一个例子里, 双向的关系均被自动建立起来. ( 例如: picasso.addToPaintings(girl) 完全等效于 girl.setToArtist(picasso) ).12345picasso.addToPaintings(girl);picasso.addToPaintings(stein);girl.setGallery(metropolitan);stein.setGallery(metropolitan); 现在, 让我们使用一个方法来同时保存所有的5个对象:1context.commitChanges(); 现在, 你可以使用前面章节中所述的方法的来再次运行程序. 新的输出将显示一些实际的数据库操作:12345678910111213141516171819202122232425262728293031323334353637...org.apache.cayenne.configuration.XMLDataChannelDescriptorLoader loadINFO: Loading XML configuration resource from file:cayenne-project.xml...INFO: Opening connection: jdbc:derby:memory:testdb;create=true Login: null Password: *******INFO: +++ Connecting: SUCCESS.INFO: Detected and installed adapter: org.apache.cayenne.dba.derby.DerbyAdapterINFO: --- transaction started.INFO: No schema detected, will create mapped tablesINFO: CREATE TABLE GALLERY (ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE ARTIST (DATE_OF_BIRTH DATE, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE PAINTING (ARTIST_ID INTEGER, GALLERY_ID INTEGER, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (ARTIST_ID) REFERENCES ARTIST (ID)INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (GALLERY_ID) REFERENCES GALLERY (ID)INFO: CREATE TABLE AUTO_PK_SUPPORT ( TABLE_NAME CHAR(100) NOT NULL, NEXT_ID BIGINT NOT NULL, PRIMARY KEY(TABLE_NAME))INFO: DELETE FROM AUTO_PK_SUPPORT WHERE TABLE_NAME IN (&apos;ARTIST&apos;, &apos;GALLERY&apos;, &apos;PAINTING&apos;)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES (&apos;ARTIST&apos;, 200)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES (&apos;GALLERY&apos;, 200)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES (&apos;PAINTING&apos;, 200)INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:&apos;ARTIST&apos;]INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:&apos;GALLERY&apos;]INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:&apos;PAINTING&apos;]INFO: INSERT INTO GALLERY (ID, NAME) VALUES (?, ?)INFO: [batch bind: 1-&gt;ID:200, 2-&gt;NAME:&apos;Metropolitan Museum of Art&apos;]INFO: === updated 1 row.INFO: INSERT INTO ARTIST (DATE_OF_BIRTH, ID, NAME) VALUES (?, ?, ?)INFO: [batch bind: 1-&gt;DATE_OF_BIRTH:&apos;1881-10-25 00:00:00.0&apos;, 2-&gt;ID:200, 3-&gt;NAME:&apos;Pablo Picasso&apos;]INFO: === updated 1 row.INFO: INSERT INTO PAINTING (ARTIST_ID, GALLERY_ID, ID, NAME) VALUES (?, ?, ?, ?)INFO: [batch bind: 1-&gt;ARTIST_ID:200, 2-&gt;GALLERY_ID:200, 3-&gt;ID:200, 4-&gt;NAME:&apos;Gertrude Stein&apos;]INFO: [batch bind: 1-&gt;ARTIST_ID:200, 2-&gt;GALLERY_ID:200, 3-&gt;ID:201, 4-&gt;NAME:&apos;Girl Reading at a Table&apos;]INFO: === updated 2 rows.INFO: +++ transaction committed. Cayenne 创建了必要的表 ( 记住, 我们使用了 “CreateIfNoSchemaStrategy”). 然后它运行一些插入, 即时生成了主键. 就这么几行代码就搞成这样还不赖. 3.3. 检索对象本节演示如何使用 ObjectSelect 来从数据库中检索 ( 查询 ) 对象. ObjectSelect 介绍前面已经展示了如何持久化新的对象. Cayenne 的 query 被用来访问已经保存的对象. 用于检索对象的主要查询类型是 ObjectSelect. 它可以直接在 CayenneModeler 中进行映射, 也可以通过 API 创建. 本节我们将使用后一种方法. 虽然我们还没有太多的数据在数据库中, 但是我们仍可以演示如下的主要方法. 检索所有的画作 ( 代码 及 产生的日志输出 ): 12SelectQuery select1 = new SelectQuery(Painting.class);List paintings1 = context.performQuery(select1); 12INFO: SELECT t0.GALLERY_ID, t0.ARTIST_ID, t0.NAME, t0.ID FROM PAINTING t0INFO: === returned 2 rows. - took 18 ms. 检索以 “gi” 开头的画作, 忽略大小写: 12345Expression qualifier2 = ExpressionFactory.likeIgnoreCaseExp( Painting.NAME_PROPERTY, \"gi%\");SelectQuery select2 = new SelectQuery(Painting.class, qualifier2);List paintings2 = context.performQuery(select2); 123INFO: SELECT t0.GALLERY_ID, t0.NAME, t0.ARTIST_ID, t0.ID FROM PAINTING t0 WHERE UPPER(t0.NAME) LIKE UPPER(?) [bind: 1-&gt;NAME:&apos;gi%&apos;] - prepared in 6 ms.INFO: === returned 1 row. - took 18 ms. 检索所有100年前出生的艺术家的画作 ( 演示使用 Expression.fromString(..) 而不是 ExpressionFactory ): 1234567Calendar c = new GregorianCalendar();c.set(c.get(Calendar.YEAR) - 100, 0, 1, 0, 0, 0);Expression qualifier3 = Expression.fromString(\"artist.dateOfBirth &lt; $date\");qualifier3 = qualifier3.expWithParameters(Collections.singletonMap(\"date\", c.getTime()));SelectQuery select3 = new SelectQuery(Painting.class, qualifier3);List paintings3 = context.performQuery(select3); 123INFO: SELECT t0.GALLERY_ID, t0.NAME, t0.ARTIST_ID, t0.ID FROM PAINTING t0 JOIN ARTIST t1 ON (t0.ARTIST_ID = t1.ID) WHERE t1.DATE_OF_BIRTH &lt; ? [bind: 1-&gt;DATE_OF_BIRTH:&apos;1911-01-01 00:00:00.493&apos;] - prepared in 7 ms.INFO: === returned 2 rows. - took 25 ms. 3.4. 删除对象本节解释如何建立关系的删除约束模型, 如何删除单个对象和一组对象. 同时, 也将演示执行查询时 Cayenne 类的使用. 设置删除约束在我们讨论删除对象的 API 前, 让我们回到 CayenneModeler, 进行一些删除约束的设置. 这样做是可选的 ( 不是必须的 ) , 但它将使得我们可以以简单的方式正确处理与被删除对象相关联的其它对象. 在建模工具中转到 “Artist” ObjEntity 的 “Relationships” 标签页, 为 “paintings” 关系选择 “Cascade” ( 级联 ) 删除约束: 为其它关系重复上述步骤: 为 Gallery 设置 “paintings” 关系为 “Nullify”, 因为可以存在一副画作未在任何画廊展出的情况. 为 Painting 设置其两个关系的删除约束均为 “Nullify”. 现在, 保存映射. 删除对象虽然可以通过SQL删除对象. 但在Cayenne（ 或一般的ORM ）中更常用的方法是首先获取对象, 然后通过 context 删除它. 让我们使用 Cayenne 的工具类找到一个艺术家: 123Expression qualifier = ExpressionFactory.matchExp(Artist.NAME_PROPERTY, \"Pablo Picasso\");SelectQuery select = new SelectQuery(Artist.class, qualifier);Artist picasso = (Artist) Cayenne.objectForQuery(context, select); 现在, 让我们删除这个艺术家:1234if (picasso != null) &#123; context.deleteObject(picasso); context.commitChanges();&#125; 因为我们为 Artist.paintings 关系设置了 “Cascade” 删除约束, Cayenne会自动删除这个艺术家所有的画作. 因此, 当我们运行这个程序时, 你将会看到如下输出:12345678910111213INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 WHERE t0.NAME = ? [bind: 1-&gt;NAME:&apos;Pablo Picasso&apos;] - prepared in 6 ms.INFO: === returned 1 row. - took 18 ms.INFO: +++ transaction committed.INFO: --- transaction started.INFO: DELETE FROM PAINTING WHERE ID = ?INFO: [batch bind: 1-&gt;ID:200]INFO: [batch bind: 1-&gt;ID:201]INFO: === updated 2 rows.INFO: DELETE FROM ARTIST WHERE ID = ?INFO: [batch bind: 1-&gt;ID:200]INFO: === updated 1 row.INFO: +++ transaction committed. 4. 转换为Web应用程序本章将展示 Cayenne 如何在Web应用程序中工作 4.1. 将 tutorial 项目转换为 Web应用程序Web应用程序教程的 Web 部分是在 JSP 中完成的, 而 JSP 是 Java Web 技术中最常见的实现方法. 本教程在 UI 方面尽可能地简单, 主要专注于 Cayenne 集成, 而不是界面. 一个典型的 Cayenne Web 应用程序像下面这样工作： 在应用程序上下文启动时, 使用一个特定的 Servlet 过滤器加载 Cayenne 的配置 用户请求被过滤器拦截, 并将 DataContext 绑定到请求线程, 因此应用程序可以从任何地方轻松访问它. 同一个 DataContext 实例在单个用户会话 ( Session ) 中被重用; 不同的会话使用不同的 DataContexts ( 以及不同的对象集). 根据应用的具体情况, 上下文可以有不同的范围. 本教程中我们将使用会话范围的上下文 ( Context ). 让我们将我们此前创建的 tutorial 项目转换为一个 Web 应用程序: 在Eclipse中的 “tutorial” 项目下创建一个新的文件夹 “src/main/webapp/WEB-INF”. 在 WEB-INF 下创建一个新文件 web.xml ( 一个标准的Web应用程序描述文件 ): web.xml1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt;&lt;web-app&gt; &lt;display-name&gt;Cayenne Tutorial&lt;/display-name&gt; &lt;!-- This filter bootstraps ServerRuntime and then provides each request thread with a session-bound DataContext. Note that the name of the filter is important, as it points it to the right named configuration file. --&gt; &lt;filter&gt; &lt;filter-name&gt;cayenne-project&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.cayenne.configuration.web.CayenneFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;cayenne-project&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 创建一个艺术家浏览页面 src/main/webapp/index.jsp, 包含如下内容: webapp/index.jsp12345678910111213141516171819202122232425262728293031323334&lt;%@ page language=\"java\" contentType=\"text/html\" %&gt;&lt;%@ page import=\"org.example.cayenne.persistent.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.query.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.exp.*\" %&gt;&lt;%@ page import=\"java.util.*\" %&gt;&lt;% SelectQuery query = new SelectQuery(Artist.class); query.addOrdering(Artist.NAME_PROPERTY, SortOrder.ASCENDING); ObjectContext context = BaseContext.getThreadObjectContext(); List&lt;Artist&gt; artists = context.performQuery(query);%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Main&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Artists:&lt;/h2&gt; &lt;% if(artists.isEmpty()) &#123;%&gt; &lt;p&gt;No artists found&lt;/p&gt; &lt;% &#125; else &#123; for(Artist a : artists) &#123; %&gt; &lt;p&gt;&lt;a href=\"detail.jsp?id=&lt;%=Cayenne.intPKForObject(a)%&gt;\"&gt; &lt;%=a.getName()%&gt; &lt;/a&gt;&lt;/p&gt; &lt;% &#125; &#125; %&gt; &lt;hr&gt; &lt;p&gt;&lt;a href=\"detail.jsp\"&gt;Create new artist...&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 创建一个艺术家编辑页面 src/main/webapp/detail.jsp, 包含如下内容: webapp/detail.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@ page language=\"java\" contentType=\"text/html\" %&gt;&lt;%@ page import=\"org.example.cayenne.persistent.*\" %&gt;&lt;%@ page import=\"org.apache.cayenne.*\" %&gt;&lt;%@ page import=\"java.util.*\" %&gt;&lt;%@ page import=\"java.text.*\" %&gt;&lt;% ObjectContext context = BaseContext.getThreadObjectContext(); String id = request.getParameter(\"id\"); // find artist for id Artist artist = null; if(id != null &amp;&amp; id.trim().length() &gt; 0) &#123; artist = Cayenne.objectForPK(context, Artist.class, Integer.parseInt(id)); &#125; if(\"POST\".equals(request.getMethod())) &#123; // if no id is saved in the hidden field, we are dealing with // create new artist request if(artist == null) &#123; artist = context.newObject(Artist.class); &#125; // note that in a real application we would so dome validation ... // here we just hope the input is correct artist.setName(request.getParameter(\"name\")); artist.setDateOfBirthString(request.getParameter(\"dateOfBirth\")); context.commitChanges(); response.sendRedirect(\"index.jsp\"); &#125; if(artist == null) &#123; // create transient artist for the form response rendering artist = new Artist(); &#125; String name = artist.getName() == null ? \"\" : artist.getName(); String dob = artist.getDateOfBirth() == null ? \"\" : new SimpleDateFormat(\"yyyyMMdd\").format(artist.getDateOfBirth());%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Artist Details&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Artists Details&lt;/h2&gt; &lt;form name=\"EditArtist\" action=\"detail.jsp\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%= id != null ? id : \"\" %&gt;\" /&gt; &lt;table border=\"0\"&gt; &lt;tr&gt; &lt;td&gt;Name:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\" value=\"&lt;%= name %&gt;\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Date of Birth (yyyyMMdd):&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"dateOfBirth\" value=\"&lt;%= dob %&gt;\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align=\"right\"&gt;&lt;input type=\"submit\" value=\"Save\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行Web应用程序为了运行这个Web应用程序, 我们将使用 “maven-jetty-plugin”. 译注: jetty 是一个 Web 应用程序容器, 作用类似 Tomcat. 为了激活它, 让我们添加如下的代码到 “pom.xml” 中, 跟在 “dependencies” 部分的后面, 保存POM. pom.xml123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.14.v20161028&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 打开 “Run &gt; Run Configurations…​” 菜单, 选择 “Maven Build”, 点击右键并选择 “New” 确定你填写了 “Name”, “Base directory” 和 “Goals”, 如下图: 依次点击 “Apply” 和 “Run”. 首次运行时可能会花费几分钟下载Jetty插件所有的依赖, 但是最终你将看到如下的日志:123456789101112131415161718192021[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building tutorial 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------...[INFO] Configuring Jetty for project: tutorial[INFO] Webapp source directory = /.../tutorial/src/main/webapp[INFO] Reload Mechanic: automatic[INFO] Classes = /.../tutorial/target/classes[INFO] Context path = /tutorial[INFO] Tmp directory = determined at runtime[INFO] Web defaults = org/mortbay/jetty/webapp/webdefault.xml[INFO] Web overrides = none[INFO] web.xml file = /.../tutorial/src/main/webapp/WEB-INF/web.xml[INFO] Webapp directory = /.../tutorial/src/main/webapp[INFO] Starting jetty 6.1.22 ...INFO::jetty-6.1.22INFO::No Transaction manager found - if your webapp requires one, please configure one.INFO::Started SelectChannelConnector@0.0.0.0:8080[INFO] Started Jetty Server 至此, Jetty 容器已经启动了. 现在, 在浏览器中打开网址 http://localhost:8080/tutorial/. 你应该在浏览器中看到 “No artists found message”, 同时在 Eclipse 的控制台中可看到如下输出: 12345678910111213141516171819202122232425262728INFO: Loading XML configuration resource from file:/.../tutorial/target/classes/cayenne-project.xmlINFO: loading user name and password.INFO: Created connection pool: jdbc:derby:memory:testdb;create=true Driver class: org.apache.derby.jdbc.EmbeddedDriver Min. connections in the pool: 1 Max. connections in the pool: 1INFO: Opening connection: jdbc:derby:memory:testdb;create=true Login: null Password: *******INFO: +++ Connecting: SUCCESS.INFO: Detected and installed adapter: org.apache.cayenne.dba.derby.DerbyAdapterINFO: --- transaction started.INFO: No schema detected, will create mapped tablesINFO: CREATE TABLE GALLERY (ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE ARTIST (DATE_OF_BIRTH DATE, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: CREATE TABLE PAINTING (ARTIST_ID INTEGER, GALLERY_ID INTEGER, ID INTEGER NOT NULL, NAME VARCHAR (200), PRIMARY KEY (ID))INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (ARTIST_ID) REFERENCES ARTIST (ID)INFO: ALTER TABLE PAINTING ADD FOREIGN KEY (GALLERY_ID) REFERENCES GALLERY (ID)INFO: CREATE TABLE AUTO_PK_SUPPORT ( TABLE_NAME CHAR(100) NOT NULL, NEXT_ID BIGINT NOT NULL, PRIMARY KEY(TABLE_NAME))INFO: DELETE FROM AUTO_PK_SUPPORT WHERE TABLE_NAME IN (&apos;ARTIST&apos;, &apos;GALLERY&apos;, &apos;PAINTING&apos;)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES (&apos;ARTIST&apos;, 200)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES (&apos;GALLERY&apos;, 200)INFO: INSERT INTO AUTO_PK_SUPPORT (TABLE_NAME, NEXT_ID) VALUES (&apos;PAINTING&apos;, 200)INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 ORDER BY t0.NAME - prepared in 43 ms.INFO: === returned 0 rows. - took 56 ms.INFO: +++ transaction committed. 你可以点击 “Create new artist” 链接去新建艺术家. 对于已存在的艺术家的可以通过点击他的名字来进行编辑. 你已完成了本教程! 注: 目前 Apache 已发布了 Cayenne 的 4.0 版本, 相对而言 4.0 版本更好用些, 当然使用方法上也有些变化. 请参阅: Cayenne 起步 (Version 4.0).","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"持久层","slug":"持久层","permalink":"https://baileykm.github.io/tags/持久层/"},{"name":"Cayenne","slug":"Cayenne","permalink":"https://baileykm.github.io/tags/Cayenne/"}]},{"title":"Apache + Tomcat 集群配置","slug":"Apache-Tomcat集群 ","date":"2014-08-29T17:47:22.000Z","updated":"2019-05-10T20:32:39.554Z","comments":true,"path":"2014/08/30/Apache-Tomcat集群 /","link":"","permalink":"https://baileykm.github.io/2014/08/30/Apache-Tomcat集群 /","excerpt":"本文首先介绍集群与负载均衡的简单概念, 然后以 Apache + Tomcat 为例简介如何进行集群配置.","text":"本文首先介绍集群与负载均衡的简单概念, 然后以 Apache + Tomcat 为例简介如何进行集群配置. Apache 配置 Tomcat 配置 Session 同步 先讲一个故事： 从前, 有一个小公司，就一个员工，自然地他包揽的所有工作，包括接听客户电话，然后进行处理。 后来……，公司业务扩大了，又新增了几名员工。但是，公司电话就只有一部电话，于是老板选出了一位员工 A 专门负责接电话，而其它员工负责业务处理。在这种情况下，我们可以姑且称除 A 以外的其它员工组成了业务处理“集群”，而员工 A 就要负责把客户的要求转发给合适的员工来处理。 这就带来一个问题，A 按什么原则来转发客户要求呢？ 一个基本的想法是，谁闲着就给谁干，谁能力强就让他多干点，别让某些人累死，而另一些是闲死，最终的目的当然是让客户要求能够得到最高效的处理。而员工 A 就可以称为 “负载均衡” 调度员。 ​ 现在, 应该大概知道到什么是集群和负载均衡了吧~ ​ 对于网站而言，情形与之类似。 最初的阶段, 我们可能直接用一个 Tomcat 就既干了监听客户端请求和处理请求两项工作，后来… 访问量大了，于是我们雇一位专门的接线员（ Apache ），启动更多的 Tomcat 形成集群系统，由 Apache 来接收并转发请求给合适的 Tomcat 来处理, 待业务处理完成再反馈给 Apache, 最后由 Apache 封装后再返回给客户端。 ​ 这样做的好处至少有两点： （1）业务处理能力提高了（我们可以在一台服务器上启动多个 Tomcat 进程，也可以把多个 Tomcat 部署到多台服务器上, 实现分布式部署） （2）系统更稳定了：万一哪个 Tomcat 挂了，Apache 就让别的 Tomcat 来处理请求就行了 Tomcat 主要的工作就是处理客户端请求，而 Apache 主要负责接收并转发请求，这其实才是他们真正应有的分工 当然, 如果客户端请求的只是一些静态资源 (如: 图片), 对于这样一些粗浅的工作, Apache 就直接干了, 就不到再劳烦 Tomcat 了, 这样也有利于减轻 Tomcat 的压力. Apache 也可以用 IIS、nginx 或者别的软件替代，使用 IIS 和 nginx 的配置集群不在本文讨论范围内, 感兴趣的话请查阅别的资料。( 本人近年更偏爱 nginx ) 等一下…… IIS 的角色不应该更像 Tomcat 吗？ NO！ IIS 之所以可以 “处理请求” 那是因为它调用了后端的一个 COM+ 组件。当然，如果你要认为那个处理请求的COM+ 组件是IIS的一部分也行，那 IIS 就成“杂种”了，微软的很多软件都是如此，比如 Access，哎 ~ ​ 开始实战 ~ ​ Apache 配置先安装一个 Apache（接线员），不同版本的 Apache 可能配置不同，这里我们使用的是 2.2.25 版本。 假设 Apache 安装于 D:\\Apache2.2\\conf 安装之前注意让其它软件把 80 端口让出来，这里要特别注意一下，如果你已经安装了IIS，它默认是占据了80 端口的，这就需要配置一下，叫 IIS 把80端口交出来（怎么配置，问度娘） 80 端口是 HTTP 协议的默认端口, 也就是说当我们访问http://xxxx时其实等同于访问http://xxxx:80 ​ Apache 安装完成后，我们来配置请求转发和负载均衡。 常用的方法有2种：代理方式（ Proxy ）或 使用 JK ， 下面仅介绍代理方式，使用JK的方式也不复杂，读者可自行查阅其它资料。 （1）打开文件 D:\\Apache2.2\\conf\\httpd.conf ，这是 Apache 最重要的配置文件。在文件最后添加如下代码： 1234567891011121314LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_ajp_module modules/mod_proxy_ajp.soLoadModule proxy_balancer_module modules/mod_proxy_balancer.soLoadModule proxy_connect_module modules/mod_proxy_connect.soLoadModule proxy_ftp_module modules/mod_proxy_ftp.soLoadModule proxy_http_module modules/mod_proxy_http.soProxyRequests Off &lt;proxy balancer://cluster&gt; BalancerMember ajp://127.0.0.1:9091 loadfactor=1 route=tomcat1 BalancerMember ajp://127.0.0.1:9092 loadfactor=1 route=tomcat2&lt;/proxy&gt;Include conf/extra/httpd-vhosts.conf 其中： 1 ~ 6 行的那些代码用来启动一些所需的 Apache 模块 8 ~ 12 行使用代理 ( proxy ) 方式进行负载均衡配置。 可以看到，我们的集群里有两个干活的（BalancerMember），它们都在本机上，名称分别叫tomcat1和tomcat2，按 1:1 的权重 (loadfactor) 分配给它工作，两个 tomcat 分别从9091和9092端口接收请求 ( 监听 9091 和 9092 端口 )。 如果 Tomcat 部署在别的机器上，那把127.0.0.1换成对应服务器的IP地址就可以了。 若要改变工作分配的权重，调整 loadfactor 后面的值就可以了。 当然，如果 Tomcat 们不在同一台机器上，可以使用相同的端口。 第 14 行引入了一个配置文件，在这个配置文件中将告诉 Apache, 应该将什么样的请求转给上述配置的代理. ​ （2）打开文件 D:\\Apache2.2\\conf\\extra\\httpd-vhosts.conf ，添加如下代码： 12345678&lt;VirtualHost *:80&gt; ServerAdmin webmaster@mysite.com ServerName mysite.com ProxyPass / balancer://cluster/ stickysession=jsessionid nofailover=On ProxyPassReverse / balancer://cluster/ ErrorLog \"|bin/rotatelogs.exe -l logs/cluster-error-%Y-%m-%d.log 86400\" CustomLog \"|bin/rotatelogs.exe -l logs/cluster-access-%Y-%m-%d.log 86400\" common&lt;/VirtualHost&gt; 其中： 第 3 行的 “mysite.com” 应替换成你网站网址中紧跟在 http:// 之后的那一段. 例如：若网站首页是 http://127.0.0.1/index.html，则第 3 行的mysite.com应替换为127.0.0.1，而如果你的网站域名是 www.mysite.com 则应是上述代码中的写法。 这一部分说明了什么样的请求使用本转发规则. 第 4 ~ 5 行说明了满足上述转发规则的情况下，把请求转发给我们在 httpd.conf 文件中配置的代理来处理。 也许你已经注意到配置中的VirtualHost了，是的，这里是通过在 Apache 中创建虚拟主机来转发请求的。（不明白? 呵呵，没关系，当我没说就行了, 关键是前面 2 点） ​ OK， 至此，Apache 的配置就完成了，它已经可以把客户端请求把 1:1 的比例转发到本机的 9091 和 9092 端口了，后面就是要配置 2 个Tomcat，让他们分别监听 9091 和 9092 端口, 然后把它们同时启动起来。 ​ Tomcat 配置 不同的 Tomcat 版本配置方法也不尽相同，本例使用的是7.0.52版本, 建议使用解压版本。 （1）把下载到的 Tomcat 压缩包解压 2 份，假设分别放在 D:\\TomcatCluster\\tomcat1 和 D:\\TomcatCluster\\tomcat2 下 以下配置以Tomcat1为例，至于 Tomcat2 使用相同的方法配置即可，不再赘述。 （2）打开 D:\\TomcatCluster\\tomcat1\\conf\\server.xml 文件，找到下面呈现的这几行： 123456789&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; ........... &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; ........... &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt; ........... &lt;Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"tomcat1\"&gt; 第 7 行的代码, 将 8009 改成 Apache 配置第（1）步中的设置值 9091 关键是 Apache 和 Tomcat 的配置一致，至于用什么端口号只要不被别的程序占用就行 本例中我们将 2 个 Tomcat 放在了同一台机器上，所以应让两个 Tomcat 使用不同的端口. 例如：第 1 行 和 第 3 行 将 8005 8080 在 tomcat1 的配置文件中设置为 9011 9081， 而在 tomcat2 中配置为 9012 9082. 如果两个 Tomcat 没有部署在同一台机器上, 那这一步的配置可以不用做, 因为两个 Tomcat 不会端口冲突 注意添加第 9 行的 jvmRoute=&quot;tomcat1&quot;，这里的 tomcat1 可以认为是这个 tomcat 的名字，要与 Apache 配置第（1）步中的 route 后面的值对应. tomcat2 的配置类似. ​ 通常我们还需要让不同的 Tomcat 共用同一个网站程序位置, 这样可以保证一个网站程序只有一个版本，便于维护。在某些情况下网站还可能接收用户上传的文件，如果多个 Tomcat 各自使用自己的路径来存放，那用户上传的文件就被到处乱丢了，不便于管理。试想，当用户要下载的文件的时候，还得先确定文件在哪个 Tomcat 那里，这不给自己添麻烦吗? 因此，我们做如下配置: （3）在 D:\\TomcatCluster\\tomcat1\\conf\\server.xml 文件中找到如下部分： 12345&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; ....... &lt;Context path=\"\" docBase=\"D:/webroot/root\" reloadable=\"true\"/&gt; .......&lt;/Host&gt; 注意第 3 行，告诉 Tomcat，网站程序的根目录在 D:/webroot/root 如果每个 Tomcat 都这样配置的话，那大家就共享同一个程序位置了。 path 的值不一定是 “”，根据情况，如果你网站的访问地址是 http://www.xxx.com/yyy，那这里应该是 path = &quot;/yyy&quot; ​ 到此为止，如果你的两个 Tomcat 都已经配置好了，它们已经可以正确处理由 Apache 转发来的请求了。 ​ Session 同步有一个关键问题亟待解决： 通常我们会使用 Session 对象来保存一些会话信息, 例如：用户的登录状态. 此时，因为 Apache 可能将来自同一个客户端的多次请求转发到不同的 Tomcat，而不同的两个 Tomcat 的 Session 并不共享(不在同一个存储空间). 假若你的网站是使用 Session 来保存用户登录状态，那么就会出现用户登录后登录状态信息可能被保存在了 tomcat1 的 Session 中，而 Tomcat2 的 Session 中并未保存此信息, 此时若新的请求被转发到了 tomcat2, 则Tomcat2 并不知道客户已经登录了, 从而要求客户登录。 当然，两个 Tomcat 的 Session 不同步导致的问题不止于此… ​ 怎么办? 两个方法： 方法1： 让 Apache 将同一个客户端发来的请求总是转发给同一个 Tomcat，这样对于同一客户来说，它总是和同一个Tomcat 交互，所以也就不会存在上述问题了。 但是，试想，如果某一个客户一直和 Tomcat1 打交道，而 Tomcat1 好死不死就挂了呢? 那此客户的 Session 也就自然丢失了。 这种方式 “部分” 解决了负载分配的问题，但始终使用的是单个 Tomcat 为特定的客户服务。 按方法1的思路只需在 Apache 中改变一下配置即可，具体方法请查阅其它资料。 方法2： 让每个 Tomcat 都保存一个 Session 的复本，这样即使某个或某几个 Tomcat 挂了，只要不是全部挂了，那客户的 Session 信息仍不至于丢失。 当然，这就需要解决一个问题：多个 Tomcat 之间的 Session 同步 ​ OK，下面就来看如何实现 Session 同步…… ​ （4）在第 1 个Tomcat 的配置文件 D:\\TomcatCluster\\tomcat1\\conf\\server.xml 中找到 &lt;Engine&gt; .... &lt;/Engine&gt;部分，上面的步骤我们为节点添加了 jvmRoute=&quot;tomcat1&quot; 属性，现在在 &lt;Engine&gt;节点中插入代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"tomcat1\"&gt; ....... &lt;Cluster className=\"org.apache.catalina.ha.tcp.SimpleTcpCluster\" channelSendOptions=\"6\"&gt; &lt;Manager className=\"org.apache.catalina.ha.session.BackupManager\" expireSessionsOnShutdown=\"false\" notifyListenersOnReplication=\"true\" mapSendOptions=\"6\"/&gt; &lt;Channel className=\"org.apache.catalina.tribes.group.GroupChannel\"&gt; &lt;Membership className=\"org.apache.catalina.tribes.membership.McastService\" address=\"228.0.0.4\" port=\"45564\" frequency=\"500\" dropTime=\"3000\"/&gt; &lt;Receiver className=\"org.apache.catalina.tribes.transport.nio.NioReceiver\" address=\"auto\" port=\"4001\" selectorTimeout=\"100\" maxThreads=\"6\"/&gt; &lt;Sender className=\"org.apache.catalina.tribes.transport.ReplicationTransmitter\"&gt; &lt;Transport className=\"org.apache.catalina.tribes.transport.nio.PooledParallelSender\"/&gt; &lt;/Sender&gt; &lt;Interceptor className=\"org.apache.catalina.tribes.group.interceptors.TcpFailureDetector\"/&gt; &lt;Interceptor className=\"org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor\"/&gt; &lt;Interceptor className=\"org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor\"/&gt; &lt;/Channel&gt; &lt;Valve className=\"org.apache.catalina.ha.tcp.ReplicationValve\" filter=\".*\\.gif|.*\\.js|.*\\.jpeg|.*\\.jpg|.*\\.png|.*\\.htm|.*\\.html|.*\\.css|.*\\.txt\"/&gt; &lt;Deployer className=\"org.apache.catalina.ha.deploy.FarmWarDeployer\" tempDir=\"/tmp/war-temp/\" deployDir=\"/tmp/war-deploy/\" watchDir=\"/tmp/war-listen/\" watchEnabled=\"false\"/&gt; &lt;ClusterListener className=\"org.apache.catalina.ha.session.ClusterSessionListener\"/&gt; &lt;/Cluster&gt; ..............&lt;/Engine&gt; &lt;Cluster....&gt;.....&lt;/Cluster&gt; 部分 ( 3 ~ 42 行 ) 是插入的内容，你可以把上述部分的代码复制并插入到你 server.xml 文件的 &lt;Engine&gt;...&lt;/Engine&gt;中 第 18 行的端口号4001 对于同一台机器上的两个 Tomcat 应设置为不同值。( 例如: 可把 Tomcat2 设置为 4002 ) 其余地方无须更改 上面这么一大段代码是告诉 Tomcat，你现在要以群集方式工作了，你的状态应该以广播的方式通知其他 Tomcat，至于细节暂时无须理会。 ​ （5）最后，千万记得在你的项目的 web.xml 文件的 &lt;web-app ... &gt;...&lt;/web-app&gt; 中插入 &lt;distributable/&gt;, 告诉 Web 容器，这个项目是工作在分布式模式下的。 ​ 最后的最后…… 提醒那些对网站服务器进行了安全配置的同学，记得把上述第（4）步配置代码中第 18 行的端口 4001 开放，别被防火墙或安全策略挡住了，不然的话，各个 Tomcat 之间是无法通信的。 按上述同样的方法配置第 2 个 Tomcat, 注意端口! ​ ​ 华丽丽的分隔线之后，开始测试~ （1）新建一个名为 test.jsp 的文件，把它放在：D:/webroot/root 文件夹下， 代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;%@ page contentType=\"text/html; charset=GBK\" %&gt; &lt;%@ page import=\"java.util.*\" %&gt; &lt;html&gt;&lt;head&gt;&lt;title&gt;Cluster App Test&lt;/title&gt;&lt;/head&gt; &lt;body&gt; Server Info: &lt;% // 输出当前Session的ID out.println(\"Session ID ＝ \" + session.getId() + \"&lt;br/&gt;\"); // 如果有新的键值对，则将其保存到 Session 属性 String dataName = request.getParameter(\"dataName\"); if (dataName != null &amp;&amp; dataName.length() &gt; 0) &#123; String dataValue = request.getParameter(\"dataValue\"); session.setAttribute(dataName, dataValue); &#125; // 列出当前Session中所有的键值对 out.println(\"&lt;h3&gt;Session 列表&lt;/h3&gt;\"); System.out.println(\"============================\"); Enumeration e = session.getAttributeNames(); while (e.hasMoreElements()) &#123; String name = (String)e.nextElement(); String value = session.getAttribute(name).toString(); out.println( name + \" = \" + value+\"&lt;br/&gt;\"); System.out.println( name + \" = \" + value); &#125; %&gt; &lt;form action=\"test.jsp\" method=\"POST\"&gt; 键:&lt;input type=text size=20 name=\"dataName\"/&gt;&lt;br/&gt; 值:&lt;input type=text size=20 name=\"dataValue\"/&gt;&lt;br/&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 这个网页提供了一个表单，可以输入一个键值对，服务器端脚本把键值对保存在Session中，并列表输出当前所有已保存的键值对。 ​ （2）新建一个名为 web.xml 的文件，把它放在：D:/webroot/root/WEB-INF 文件夹下。 代码如下: 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; ....... &lt;distributable/&gt; .......&lt;/web-app&gt; 这其实是你网站项目的配置文件， 关键是第 8 行。 ​ OK，把 Apache 和 所有的 Tomcat 都启动起来吧……（ 若 Apaceh 在此前已经启动，那重启一下 ） 在浏览器中打开 http://localhost/test.jsp 如果一切正常 ( 但愿 RP 没问题 )，应该可以看到： （1）无论刷新多少次，网页中显示的 Session ID 应该不会变，这说明无论 Apache 把你的请求转给了哪个 Tomcat，你的 Session 都被保持住了。 另外，在 Session ID 值的后缀部分可以看到你的第一次请求是由哪个 Tomcat 来处理的。 （2）试着填一下键值对，提交，应该可以保存下来 （3）只保留一个 Tomcat，把其它的全部停掉，再刷新页面，应该可以看到网页仍然可以打开，并且 Session 的值没有丢失 （4）启动另一个 Tomcat，启动完成之后，把原先未停止的 Tomcat 关闭，应该可以看到网页仍然可以打开，并且 Session 的值没有丢失 ​ 呵呵，这回爽了吧，只要还有一个 Tomcat 活着，那你的网站都可以正常访问，并且 Session 不会丢失。 当然，如果有很多个 Tomcat 一起工作，那负载会被分配到不同的 Tomcat 上，实现负载均衡。 ​ 谢谢观赏! 花絮更精彩…… ​ ​ 迫不及待地把你之前做好的项目部署上去玩集群了吧? 呵呵，是不是发现你的项目弄上去后 Session 中存储的东西会丢啊? 这回彻底崩溃了…… 为什么上面的例子正常，偏偏就自己的项目出问题…… 难道是 RP 问题 ? ​ 嘿嘿，Tomcat 7 的官方文档中关于集群配置有这样一段话，翻译过来大意是： 使用集群配置时，放进 Session 里的对象必须实现 java.io.Serializable 接口。 如若不然，Session 其实也没丢失，只是取出来的对象的属性值就会全部变成 null …… 因为 Tomcat 在进行 Session 广播的时候会对 Session 中存储的对象进行序列化操作，别的 Tomcat 接收到之后再反序列化还原出原来的对象。若存储进 Session 的对象不能正确序列化，自然就不能正确的广播给别人。前面的测试之所以可以成功，是因为放进 Session 里的是 String，而 String 是实现了 Serializable 接口的。 ​ 哈哈，这还不简单，我们都知道 java.io.Serializable 接口其实是个空接口，声明一下不就行了嘛！ 呵呵，举个例子，你的修改后的代码可能很像下述样子： 1234567891011121314151617181920import java.io.Serializable;public class UserInfo implements Serializable &#123; private String id; private String name; public void setId(String id) &#123; this.id = id; &#125; public String getId() &#123; return this.id; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125;&#125; ​ 把用户信息 ( userInfo ) 存入 Session： 123456&lt;% UserInfo userInfo = new UserInfo(); userInfo.setId(\"001\"); userInfo.setName(\"Zhang\"); request.getSession().setAttribute(\"userInfo\", userInfo);%&gt; ​ 从 Session 中取出userInfo（通常下列代码不会跟上面的代码放在一个页面吧，呵呵~）： 123&lt;% UserInfo userInfo = request.getSession().getAttribute(\"userInfo\");%&gt; ​ 这行了吧，再试…… 晕…… 还是不对…… 仍然有问题，可以从 Session 中取出原先存储的 userInfo 对象（并不为 null )，但是似乎又不是原来那个, id, name 的值变成 null 了…… 呃…… 再研读一下 JDK 的说明书，人家说了，即使实现了Serializable接口，但出于安全性考虑，序列化过程只对 public 属性进行处理，而那些 protected, private 的属性统统不理会. 这回知道了吧，得把 id 和 name 变成 public 的…… 修改一下，再试，这回总行了吧…… 呵呵，如果 RP 真的没问题，应该 OK 了~ 也许你在想，如果把所有的属性都变成 public 不是有失封装性原则嘛…… 嘿! 谁让你全部变成 public 了，你可以只把 id 声明为 public 的嘛，如果需要name则根据id去数据库里取嘛，呵呵…… 这里需要考虑性能和安全的平衡，自己考量吧…… ​ 跟你说了花絮更精彩了吧，很多人估计是被最后这步坑死的，呵呵~ ​ 再次谢谢观赏~ 小二，上字幕! ​ 如果一个接线员忙不过来，能不能再多雇几个呢？ 当然可以，但是，多个接线员的关系应该是树状层次的关系，而非平级关系。也就是说，对外只有一个接线员，而这个接线员负责把请求转发给别的接线员，然后再转发…… Why? 因为…… 网站用户访问某个网页时，请求的目的地是非常明确的，客户端发来的请求只会发送到某一个 IP 地址的某个端口上。 也就是说，对于客户，它只知道唯一的一个客服电话号码，而公司也只有一部对外的电话，所以，只能把接线员们架构成树状形式，由顶层接线员来接电话，然后再转接给别的接线员。 怎么弄? 自己想…","categories":[{"name":"杂项","slug":"杂项","permalink":"https://baileykm.github.io/categories/杂项/"}],"tags":[{"name":"集群","slug":"集群","permalink":"https://baileykm.github.io/tags/集群/"},{"name":"Apache","slug":"Apache","permalink":"https://baileykm.github.io/tags/Apache/"}]},{"title":"CSS入门精要 (四)","slug":"CSS入门精要-4","date":"2014-05-03T16:04:38.000Z","updated":"2019-05-10T20:32:02.785Z","comments":true,"path":"2014/05/04/CSS入门精要-4/","link":"","permalink":"https://baileykm.github.io/2014/05/04/CSS入门精要-4/","excerpt":"本节将用一个简单的示例演示如何综合应用前面三节所学的知识构建一个静态网页. 如果你对如何综合运用我们之前讲述的知识完成一个实际的网页设计还感到无从下手，相信仔细研读这个例子后会有所帮助，并可以学到一些未提到的知识和技巧。","text":"本节将用一个简单的示例演示如何综合应用前面三节所学的知识构建一个静态网页. 如果你对如何综合运用我们之前讲述的知识完成一个实际的网页设计还感到无从下手，相信仔细研读这个例子后会有所帮助，并可以学到一些未提到的知识和技巧。 综合示例 例子中的代码并不一定是最佳的写法, 在写代码的路上, 没有最好, 只有更好! 例子中没有使用任何图片，所使用的颜色也只是黑、白、灰三色，一切力求精简。 最终效果如下图： 以下是 HTML文档代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;DIV+CSS布局示例&lt;/title&gt;&lt;link type=\"text/css\" rel=\"stylesheet\" href=\"example.css\"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"m-body\"&gt; &lt;div id=\"title\"&gt;DIV + CSS布局示例&lt;/div&gt; &lt;div id=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;导航菜单&lt;/li&gt; &lt;li&gt;导航菜单&lt;/li&gt; &lt;li&gt;导航菜单&lt;/li&gt; &lt;li&gt;导航菜单&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;div id=\"side\"&gt; &lt;div class=\"item\"&gt; &lt;p class=\"title\"&gt;侧边栏标题&lt;/p&gt; &lt;ul&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p class=\"title\"&gt;侧边栏标题&lt;/p&gt; &lt;ul&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;li&gt;菜单名称&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"content\"&gt; &lt;div class=\"item\"&gt; &lt;p class=\"title\"&gt;栏目标题&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p class=\"title\"&gt;栏目标题&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p class=\"title\"&gt;栏目标题&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p class=\"title\"&gt;栏目标题&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;栏目中文章的标题&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=\"footer\"&gt;版权声明 2013.6&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ​ 样式统一写在一个外联样式表文件中，文件名为 example.css，与HTML文档放置于同一文件夹下： 1234567891011121314151617181920212223242526272829303132* &#123;font-size:12px; margin:0px; padding:0px;&#125;body &#123;margin:0px;&#125;li &#123;list-style:none;&#125;a &#123;color:black;text-decoration:none;&#125;a:hover &#123;color:#C00; text-decoration:underline;&#125;.clear &#123;clear:both;&#125;#m-body &#123;width:960px; margin:0px auto; border:1px dashed silver; border-width:0px 1px; background-color:#EEE;&#125;#title &#123;height:100px; font-size:32px; font-family:黑体,sans-serif; line-height:100px; padding-left:50px;background-color:#CCC;&#125;#nav &#123;height:30px; line-height:30px; background-color:#333; color:#FFF; margin:5px 0px;&#125;#nav ul &#123;margin-left:20px;&#125;#nav li &#123;float:left; margin:0px 10px;&#125;#side &#123;float:left; width:200px; padding:0px 5px;&#125;#side .item &#123;border:1px solid #CCC; margin-bottom:20px;&#125;#side .item .title &#123;height:30px; line-height:30px; background-color:#CCC; font-size:14px; padding-left:10px;&#125;#side .item ul &#123;margin-left:15px;&#125;#side .item li &#123;margin:10px 0px;&#125;#content &#123;float:left; width:720px; margin-left:10px; padding-left:10px; border-left:1px dotted #CCC; min-height:500px;&#125;#content .item &#123;width:320px; margin:7px; padding:10px; float:left; background-color:#FFF;&#125;#content .item .title &#123;line-height:16px; font-size:16px; padding-left:8px; margin-bottom:10px; font-family:黑体,sans-serif;&#125;#content .item ul &#123;margin-left:10px;&#125;#content .item li &#123;line-height:22px;&#125;#footer &#123;height:20px; line-height:20px; padding:5px 15px; margin:5px 0px; background-color:#333; color:#FFF; text-align:right; &#125; ​ 建议使用 Chrome 浏览器, 打开”开发者工具”，一边查看效果, 一边研究代码. 好了，就到这里.","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"https://baileykm.github.io/tags/CSS/"}]},{"title":"CSS入门精要 (三)","slug":"CSS入门精要-3","date":"2014-05-03T16:02:07.000Z","updated":"2019-05-10T20:31:58.002Z","comments":true,"path":"2014/05/04/CSS入门精要-3/","link":"","permalink":"https://baileykm.github.io/2014/05/04/CSS入门精要-3/","excerpt":"本节介绍 CSS 选择符的使用. 在实际开发中, 我们只会偶尔在某些特殊情况下直接将样式表嵌在标签的 style 属性里 (就像前几节的做法), 因为这样做有诸多的弊端 (长大了你就会懂的) . 本节将讨论一种更好的样式表写法.","text":"本节介绍 CSS 选择符的使用. 在实际开发中, 我们只会偶尔在某些特殊情况下直接将样式表嵌在标签的 style 属性里 (就像前几节的做法), 因为这样做有诸多的弊端 (长大了你就会懂的) . 本节将讨论一种更好的样式表写法. 4. CSS选择符 4.1 标签名选择符 4.2 ID选择符 4.3 类选择符 4.4 伪类 4.5 属性选择符 4.6 组合 外联样式表 之所以把这部分内容放在第（三）部分，迟迟不讲，主要考虑到代码直观性，也尽量让初学者循序渐进，避免一开始就接触一大堆新的概念，徒增学习难度。 4. CSS选择符考虑这样一个问题，如果网页中有数十个段落 &lt;p&gt;，所有段落的文字都需要显示为红色，按此前的写法, 那岂不是要在所有&lt;p&gt;标签里都写 style=&quot;color:red&quot;，这不累死个人了吗? 更崩溃的是，如果你的老板叫你把所有段落文字都改成绿色，估计你脸也绿了吧~。 能不能像提取公因式一样，把这些重复的代码放到一个位置，统一描述? 这样既省力，而且当老板叫你把所有段落文字都改成绿色的时候就只需要改一个地方的代码，也不至于崩溃了吧！ 答案是：YES ! 那……把这些重复的样式描述代码提取到哪里（放哪里）呢? 有两种做法： (1) 放在HTML文档里, 使用一对&lt;style&gt;&lt;/style&gt;标签装起来 (2) 干脆放在一个独立的外部文件里 对于之前我们把样式写在标签的style属性的做法，如：&lt;p style=&quot;color:red&quot;&gt;&lt;/p&gt;，叫做内嵌样式表，作用于一个具体的标签。 把样式表写在HTML文档里, 使用一对&lt;style&gt;&lt;/style&gt;标签装起来的做法叫做内联样式表，作用于当前网页。 放在独立文件中的做法叫做外联样式表，可作用于多个网页。 ​ 说了这么半天，到底怎么做，LOOK！ 别着急试！之所以放个图片，而不是直接放代码，就是怕你复制了去试。 难道没发现，这样写的话浏览器岂不很迷惑，你到底是想让段落文字显示为红色，还是让span里的文字显示为红色，亦或是别的要求。 是的，既然我们把样式描述提到了一个公共的位置，而不是直接写在标签里，那就得有个机制告诉浏览器，每个样式是修饰哪个元素的。这就是我们这一节要讨论的内容: CSS选择符。 有些资料上翻译为CSS选择器，我们就不再纠结到底该叫什么了，本文统一叫 CSS选择符 如果我们想仅让上图中的段落1和段落2显示为红色，正确的代码应该如下： 例4.1： 1234567891011&lt;head&gt; &lt;title&gt;学习CSS&lt;/title&gt; &lt;style type=&quot;text/css&quot; &gt; p &#123;color : red;&#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;段落1&lt;/p&gt; &lt;p&gt;段落2&lt;/p&gt; &lt;span&gt;span里的内容&lt;/span&gt;&lt;/body&gt; 例4.1 中， p {color : red;} 说明网页中所有的&lt;p&gt;标记中的文字均显示为红色，除此之外保持默认样式。 语法: 选择符 { 样式描述1; 样式描述2; ...} 可以看到，选择符的作用就是从HTML文档中挑出要进行修饰的那些元素，而{ }中的部分为样式说明，这和嵌入式样式表中的用法相同。 下面我们来讨论常用的选择符… 4.1 标签名选择符如例4.1所示，可以使用标签名来选出指定名称的元素(标签)，如：p、div、img、a等，甚至还包括 html 标签。（快实验吧~） 这里要隆重介绍一个特别的选择符 — “*” ，它可以代表任意标签。好好用它，可以省不少事！ 比如，我们若需要将整个网页中所有的文字字号设置为12px，那可以写成： ​ * { font-size : 12px; } 是不是很省事? ​ 4.2 ID选择符我们可以为标签指定一个ID，如：&lt;p id=”p1”&gt;&lt;/p&gt;，这样在内联样式表或外联样式表中即可使用 #p1 选中该元素。注意ID值前面的”#”。 例4.2： 样式表 HTML #p1 {color : red;} &lt;p id=”p1”&gt;段落1&lt;/p&gt;&lt;p&gt;段落2&lt;/p&gt; 结果: 只有”段落1”为红色文字 注意，在一个网页中，ID应该唯一，即不应出现多个元素相同ID。 ​ 4.3 类选择符例4.3： 样式表 HTML .classA {color : red;}.classB {color : green;} &lt;p class=”classA”&gt;段落1&lt;/p&gt;&lt;p class=”classB”&gt;段落2&lt;/p&gt;&lt;p class=”classA”&gt;段落3&lt;/p&gt;&lt;span class=”green”&gt;SPAN&lt;/span&gt; 结果：”段落1”和”段落3”为红色，”段落2”和”SPAN”为绿色 我们可以把HTML标签分为多个类别（类名自己定义），然后在标签中使用class属性说明该标签属于哪个分类 注意样式表中，类名最前面有个句点”.” 一个 class 属性中可以有多个样式类名, 使用空格分隔即可, 如: class=&quot;classA classB&quot; ​ 4.4 伪类对于诸如超链接 &lt;a&gt; 这样的标签，根据状态不同，它可能显示不同的显示外观。例如下面4个图分别是超链接处于普通链接状态（link）、鼠标处于其上方（hover）、鼠标按住（active）和已访问过（visited）4个不同状态 我们可以如下例更改其外观： 1234567891011样式表:a:link &#123; color : black; text-decoration:none;&#125;a:hover &#123; color : red; text-decoration:underline;&#125;a:active &#123; color : green; &#125;a:visited &#123; color : blue; &#125;HTML:&lt;a href=&quot;http://www.cctv.com&quot;&gt;超链接&lt;/a&gt;结果:自己试试吧…… 使用伪类可以指定的是元素在不同状态或上下文环境下的样式 伪类需要与别的选择符组合使用，如上例中与 a 选择符组合a:hover。 还有更多的伪类可以使用，如: :first-child、:last-child、:before、:after …, 用好伪类可以让我们在做选择元素时更灵活, 请自行查阅别的资料。 ​ 4.5 属性选择符所谓属性选择器是根据元素标签中的属性来进行选择，直接看例子： 12345678910111213样式表:a[title]&#123; color: red;&#125;a[href=&quot;http://www.cctv.com&quot;]&#123;color: green;&#125;a[href=&quot;http://www.cctv.com&quot;][title=&quot;cctv&quot;]&#123;color: blue;&#125;HTML:&lt;a href=&quot;http://www.163.com&quot; title=&quot;163&quot;&gt;超链接1&lt;/a&gt;&lt;a href=&quot;http://www.cctv.com&quot;&gt;超链接2&lt;/a&gt;&lt;a href=&quot;http://www.cctv.com&quot; title=&quot;中央电视台&quot;&gt;超链接3&lt;/a&gt;&lt;a href=&quot;http://www.cctv.com&quot; title=&quot;cctv&quot;&gt;超链接4&lt;/a&gt;结果:超链接1为红色，超链接2、3为绿色，超链接4为蓝色 例子中可以看到，使用”[]”可以定义属性选择器。 若”[]”中只有属性名（如第1行）则表示元素存在该属性即匹配 若”[]”中既有属性名，又有值（如第2行），则表示元素必须存在该属性，且值为指定值。此处”属性值”支持子串匹配（具体是怎样的，请查看其它资料）。 若有多个”[]”，表示多个属性选择必须同时匹配，如第3行。 ​ 4.6 组合前述几种基本选择符还可以组合使用，根据组合形式不同，表示不同的选择方式。常用组合方式有如下几种： (1) 直接结合：例如: p.classA表示选择&lt;p&gt;标签中 class=&quot;classA&quot; 的元素。 (2) 逗号分隔：表示并列关系。例如： p, span 表示选择 &lt;p&gt; 和 &lt;span&gt; (3) 空格分隔：表示选择后代。例如： p span 表示选择 &lt;p&gt; 的后代中的 &lt;span&gt; (4) “&gt;”分隔：表示选择 “直接儿子”。例如：p &gt; span 表示选择 &lt;p&gt; 的直接儿子中的 &lt;span&gt; 。（不明白后代和直接儿子有什么区别? 看后面的例子就明白了） (5) “+”分隔：表示选择相邻的兄弟元素。例如：p + span表示选择 &lt;p&gt; 的兄弟元素中其后紧邻的 &lt;span&gt;。（ 什么是兄弟? 看后面的例子！） 仔细实验下表中的例子, 其中红色标注的文字表示在浏览器中显示时此文字为红色： # 样式表 HTML 1 p.classA {color : red;} &lt;p&gt;段落1&lt;/p&gt;&lt;span&gt;标签&lt;/span&gt;&lt;p class=”classA”&gt;段落1&lt;/p&gt; 2 p, span {color : red;} &lt;p&gt;段落&lt;/p&gt;&lt;span&gt;标签&lt;/span&gt;&lt;div&gt;DIV里的文字&lt;/div&gt; 3 p span {color : red;} &lt;span&gt;标签&lt;/span&gt;&lt;p&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; 4 p &gt; span {color : red;} &lt;span&gt;标签&lt;/span&gt;&lt;p&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; 5 li + li {color : red;} &lt;ul&gt;&lt;li&gt;第1项&lt;/li&gt;&lt;li&gt;第2项&lt;/li&gt;&lt;li&gt;第3项&lt;/li&gt;&lt;/ul&gt; 比较上表中第3、4项的结果，现在知道后代与直接儿子的区别了吧！后代包括子子孙孙，无论多少代。而直接儿子指的是第1代，呵呵~ 研究第5项应该明白什么是兄弟了吧，嘿嘿~ 重要的事情说三遍, 多实践! 多实践! 多实践! ​ 外联样式表经过多次实验，现在你手头上应该至少有一个含有内联样式表的HTML文档了吧。现在我们来新建一个文本文件，并把已有的内联样式表代码（不含&lt;style&gt;和&lt;/style&gt;）剪切到新建的文本文件中，保存文件到HTML文档同一文件夹下（文件名叫test.css吧！注意文件扩展名为.css） 最后，在HTML文档的&lt;head&gt;&lt;/head&gt;标签中写入下面行代码: &lt;link href=&quot;test.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; 测试一下，打开HTML文档，是不是效果与使用内联样式表一样? 这就是外联样式表，自己总结一下，把操作步骤记下来… 其中，link标签中的href属性指明了外联样式表文件的相对路径。实际项目实践中，我们通常会把样式表文件放在一个独立的文件夹中，这样便于管理。此时，href属性那里相应调整一下就可以了。 显然，使用外联样式表可以令HTML文档更简洁，从逻辑上来说也更合理（HTML文档描述内容是什么， CSS文件描述元素什么样）。所以，大力推荐使用外联样式表！ ​ 好了，至此关于CSS的介绍就结束了，关键还需要多加实践，注意总结和积累，研究一下别人写的代码也是一个不错的学习方法。 下一节 CSS入门精要 (四) 中给出了一个简单的综合示例，如果看完了前面的讲述还不知道如何入手实战，可以继续往下阅读.","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"https://baileykm.github.io/tags/CSS/"}]},{"title":"CSS入门精要 (二)","slug":"CSS入门精要-2","date":"2014-05-03T16:01:30.000Z","updated":"2019-05-10T20:31:47.300Z","comments":true,"path":"2014/05/04/CSS入门精要-2/","link":"","permalink":"https://baileykm.github.io/2014/05/04/CSS入门精要-2/","excerpt":"本节包含 2 个内容: 浮动 ( Float ) 和 盒模型 ( Box Model ).","text":"本节包含 2 个内容: 浮动 ( Float ) 和 盒模型 ( Box Model ). Float 盒模型 FloatHTML标签中，有一些标签称为块标签（Block, 如：&lt;p&gt;、&lt;div&gt;），对于这样的标签，如果我们不说明其宽度，它将占满它可以使用的所有横向（水平）空间。即使设置了宽度，它也不会与同属一个父容器其它元素同处一行。 而有一些标签称为行内标签（Inline, 如：&lt;span&gt;、&lt;img&gt;），这样的标签默认会与同属一个父容器的其它元素同处一行。 ： O 有点晕！看下面的例子： 例2.1 12345&lt;p style=&quot;border:1px solid red;&quot;&gt;段落一&lt;/p&gt;&lt;p style=&quot;border:1px solid green;&quot;&gt;段落二&lt;/p&gt;&lt;p style=&quot;border:1px solid blue; width:200px;&quot;&gt;段落三&lt;/p&gt;&lt;span style=&quot;border:1px solid red;&quot;&gt;Span1&lt;/span&gt;&lt;span style=&quot;border:1px solid green;&quot;&gt;Span2&lt;/span&gt; 浏览器中显示效果如下图：（外层淡蓝色为浏览器的边框，即本例中 &lt;p&gt; 和 &lt;span&gt;的父容器边框） 现在明白了吧…… 细心的读者可能会有疑问，不是说块标签会占满横向空间嘛，怎么3个段落两端和浏览器边框之间还有一段间隙呢? 这是由于默认情况下，&lt;body&gt; 标签会有一点留白，你可以在 &lt;body&gt; 标签中添加样式，如 &lt;body style=&quot;margin:0px;&gt;，试试看，是不是没有间隙了? 块标签或行内标签只是针对标签的默认情形而言，我们可以使用样式 display:inline 令 &lt;p&gt; 标签显示为行内标签的样子，同样也可以使用样式 display: block 令 &lt;span&gt; 标签显示为块标签的样子。 OK，讲到这里可能有人会记下这样一句话：如果要让元素们同处一行，就把它们的 display 样式属性设置为inline。 可别这样，我们还有更好的办法，上面只是为了插叙一下块标签和行内标签的概念。 ​ 把上面例子中的代码修改一下，在每个 &lt;p&gt; 标签的样式中都插入 float: left : 123&lt;p style=&quot;border:1px solid red;float:left;&quot;&gt;段落一&lt;/p&gt;&lt;p style=&quot;border:1px solid green;float:left;&quot;&gt;段落二&lt;/p&gt;&lt;p style=&quot;border:1px solid blue; width:200px;float:left;&quot;&gt;段落三&lt;/p&gt; 结果变成这样了： 让我们欢迎这一节的主角 float 登场！ 正如你看到的，样式属性 float 可以让元素产生”浮动”效果，上面的例子让3个段落都向左浮动，于是它们就一个挨个地”飘”到一起了。当然，也可以设置为向右浮动或不浮动。 ​ 使用 float 时有几个问题需要注意： （1） 当一个容器中的多个元素 float 时，它们会努力地”飘”到同一行上，但如果容器横向空间不够，余下的元素就会向下”飘”, 请比较例 2.2 和 2.3。 例 2.2 &lt;div style=”border:2px solid red; width:300px; height:100px;”&gt; &lt;div style=”background-color:#CF6; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#FC3; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#69F; width:100px; height:50px; float:left;”&gt;&lt;/div&gt;&lt;/div&gt; 运行效果如下: 例 2.3 &lt;div style=”border:2px solid red; width:300px; height:100px;”&gt; &lt;div style=”background-color:#CF6; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#FC3; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#69F; width:101px; height:50px; float:left;”&gt;&lt;/div&gt;&lt;/div&gt; 运行效果如下: 例2.2 中外层DIV限定了宽度为300px，里面的3个DIV若宽度均是100px，总共宽度是100px * 3 = 300px，刚好可以放在同一行上。但若蓝色DIV稍宽1px，就被”挤”下来了（例2.3）。 好的，现在在例2.2的基础上，为里面的蓝色DIV设置1px宽的边框，如 border:1px solid blue;，在浏览器里打开试试看，什么情况? 蓝色的 DIV 是不是同样放不下, 掉下来了. （2） 当一个容器中的元素 float 时，会使得父容器在垂直方向”坍缩”。 例 2.4 &lt;div style=”border:2px solid red;”&gt; &lt;div style=”background-color:#CF6; width:100px; height:50px; float:left;“&gt;&lt;/div&gt; &lt;div style=”background-color:#FC3; width:100px; height:50px; float:left;“&gt;&lt;/div&gt; &lt;div style=”background-color:#69F; width:100px; height:50px; float:left;“&gt;&lt;/div&gt;&lt;/div&gt; 运行效果如下: 什么情况? 怎么外层的DIV变成一条线了? 是的，现在看到的一条水平红线其实是外层DIV上、下两条红色边框紧挨在一起形成的，换句话说，外层的DIV没有计算得到正确的高度 ( 父容器在垂直方向上”坍缩”了 )。 为什么会这样? 外层DIV的高度其实是由其内部的 3 个DIV”撑”起来的。现在内部的3个DIV都向左浮动（float:left）了，都”飘”起来了，不再与外层DIV在一个水平面上了，自然也就无法把外层DIV撑开了。 呵呵，有意思吧，float属性真的可以让元素浮起来! 看看下图，可能更好理解（它们其实是这样）。 OK，现在问题来了，通常情况下，我们希望容器可以随其内容长大，始终套住其子元素。怎么办呢? 有3种较常用的做法： 方法 1: 让外层DIV也浮起来，代码如下： &lt;div style=”border:2px solid red; float:left;“&gt; &lt;div style=”background-color:#CF6; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#FC3; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#69F; width:100px; height:50px; float:left;”&gt;&lt;/div&gt;&lt;/div&gt; 现在所有DIV都在”第二层空间”上了，外层DIV又可以正常计算得到高度值了。但这样会让外层DIV的宽度变成300px，而不是占满所有可用横向空间（也许，这正是你想要的效果，那你就这样用）。 方法 2: 给外层DIV添加样式 overflow: hidden，代码如下： &lt;div style=”border:2px solid red; overflow:hidden;“&gt; &lt;div style=”background-color:#CF6; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#FC3; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#69F; width:100px; height:50px; float:left;”&gt;&lt;/div&gt;&lt;/div&gt; 诡异吧，不是说内容溢出（ overflow ）时隐藏 ( hidden ) 吗? 怎么非但没隐藏内层的3个DIV，却把自己父容器变高了? 我想可以姑且这样理解，样式 overflow:hidden 要求父容器在装不下子元素时隐藏溢出的部分, 这会让浏览器认真考量一下父元素到底应该有多高, 正是这个动作使得父容器计算得到了正确的高度。 方法 3: 使用”空层”清除浮动： &lt;div style=”border:2px solid red;”&gt; &lt;div style=”background-color:#CF6; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#FC3; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; &lt;div style=”background-color:#69F; width:100px; height:50px; float:left;”&gt;&lt;/div&gt; ​ &lt;div style=”clear:both;”&gt;&lt;/div&gt; &lt;/div&gt; 方法三中我们插入了上面红色的这行代码，添加了一个看不见的层（未设置大小），并且设置样式 clear:both （清除左、右两个方向上的浮动）。 姑且可以这样理解，新插入的层在前3个DIV均在”第二层空间”摆好了位置之后清除了浮动，让它们又落回了”第一层空间”. 上述3个方法中，方法1让所有元素都浮起来了，个人认为不太好，本人更偏好后两种做法。 ​ 盒模型经过前面的学习，我们知道，从一个元素的内容区往外走，首先会踫到padding，然后是border，最后是margin，这3个东东就像是3层盒子套住了内容区，我们把它称为盒模型 (Box Model)。 看下面2个图，可能对你的理解有帮助。 仔细研究你可能会发现第一个图中红线标注的部分在说CSS标准中与IE对样式width的理解不一样，但这其实是历史问题, 经本人在IE 9.0下验证，不存在这个问题, 即 IE 9.0 理解的width也是指内容区(Content)宽度. 还愣着干什么，快实验一下吧… ​ OK, 继续… 比较下面例3.1和3.2的结果, 例3.1中设置了外层DIV的宽、高，但未设置内层DIV的宽度；例3.2中只设置内层DIV的宽、高，未设置外层DIV的大小。 别愣着, 把代码复制到 HMTL 文档里, 在浏览器里打开看一下! 你将发现种在以下两种情况下，内、外层DIV是如果计算大小的。（ 如果领悟到了什么就记下来吧! ） 例3.1 &lt;body style=”margin:0px;”&gt; &nbsp;&nbsp;&lt;div style=”border:10px solid #000; margin:10px; padding:10px; background-color:#CF3; ​ height:50px; width:50px;“&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div style=”background-color:#FFF; height:50px;”&gt;&gt;/div&gt; &nbsp;&nbsp;&lt;/div&gt; &lt;/body&gt; 例3.2 &lt;body style=”margin:0px;”&gt; &nbsp;&nbsp;&lt;div style=”border:10px solid #000; margin:10px; padding:10px; background-color:#CF3; float:left;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div style=”background-color:#FFF; width: 50px; height:50px; “&gt;&lt;/div&gt; &nbsp;&nbsp;&lt;/div&gt; &lt;/body&gt; 通过前面的讲述和实验，我们发现： a) 一个元素实际占据的横向空间宽度 = 内容区宽度 width + padding + border + margin，纵向高度类似。（对于块标签特指float时） b) 若为元素设置一个大于 0 的margin-left值，元素会连同边框一起向右偏移，而设置一个大于 0 的padding-left值，元素内容区会相对左边框向右偏移。同样，设置大于 0 的margin-top和padding-top可令元素向下偏移。 充分利用此特性，可进行元素定位（页面布局），这也是传说中的DIV+CSS 网页布局的重要基础。关于DIV+CSS 布局方法，请参阅CSS入门精要第(四)部分 综合示例. c) margin和padding可以设置为负值(小于 0 的值)，此时元素将向左/上偏移. 有时设置为负值可有意外惊喜~ ​ 对于margin还有一个特别的地方，我们再多说几句…… 看下面的例子： 例3.3 12&lt;div style=\"background-color:#6CF; width:50px; height:50px; margin-right:10px;float:left;\"&gt;&lt;/div&gt;&lt;div style=\"background-color:#FC0; width:50px; height:50px; margin-left:20px;float:left;\"&gt;&lt;/div&gt; 例3.4 12&lt;div style=\"background-color:#6CF; width:50px; height:50px; margin-bottom:10px;\"&gt;&lt;/div&gt;&lt;div style=\"background-color:#FC0; width:50px; height:50px; margin-top:20px; \"&gt;&lt;/div&gt; 运行结果如下, 左图为例 3.3 的结果, 右图为例 3.4 的结果: 呵呵，有意思吧! 水平放置时，相邻的两个DIV间距为30px,即左边DIV的margin-right(10px) + 右边DIV的margin-left(20px) （求和） 垂直放置时，相邻的两个DIV间距为20px，不再是margin求和，而是取较大值。即上面DIV的margin-bottom和下面DIV的margin-top两个值中的较大值（20px） 这叫外边距合并(融合)，虽然看上去增加了记忆的难度，但实际应用中这样的设计却更为合理，它可以使得纵排的多个元素之间的距离与元素与外层容器之间的距离保持一致。 好了, 本节到此结束, 在这一节里我们学习了浮动与盒模型的概念与用法, 在进入下一节之前, 建议回头再过一遍前面 (一)、(二)两节的内容. 最后留一个传送门, 传送到 CSS 入门精要(三) CSS 选择符","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"https://baileykm.github.io/tags/CSS/"}]},{"title":"CSS入门精要 (一)","slug":"CSS入门精要-1","date":"2014-05-03T15:20:08.000Z","updated":"2019-05-10T20:31:08.798Z","comments":true,"path":"2014/05/03/CSS入门精要-1/","link":"","permalink":"https://baileykm.github.io/2014/05/03/CSS入门精要-1/","excerpt":"本系列教程取名为 “入门精要”，首先是为入门读者准备的，如果你想在本文中找到关于CSS的高级知识，请绕行. 其次，”精要” 二字表明本文只讲述关于CSS的入门要点，力求精简，不求广博。 边看教程边实验大概需要3 ~ 5小时，剩下的就需要读者大量的实践与经验积累了。","text":"本系列教程取名为 “入门精要”，首先是为入门读者准备的，如果你想在本文中找到关于CSS的高级知识，请绕行. 其次，”精要” 二字表明本文只讲述关于CSS的入门要点，力求精简，不求广博。 边看教程边实验大概需要3 ~ 5小时，剩下的就需要读者大量的实践与经验积累了。 CSS 基本使用方法与语法 background* font*、text*、color、line-height border* margin*、padding* list* 其它样式属性 这里假设你已掌握 HTML，并有所实践。若假设不成立，请先学习并实践 HTML… 本教程分为四个部分: CSS基础知识 Float 与 盒模型 ( the Box Model ) CSS 选择符 综合示例 CSS是英文Cascading Style Sheets（层叠样式表单）的缩写，它是一种用来表现HTML或XML等文件样式的计算机语言。CSS与HTML、JavaScript共同构成了网页开发的三大基础, 又称前端三大技术。 个人观点： HTML主要用于描述网页里的元素是什么（内容), CSS主要用于描述网页里的元素是什么样子 (外观), 而JavaScript则用于增强网页的交互能力和逻辑控制能力. 它们之间应尽可能地各行其道, 避免过多耦合. 因此，应只使用HTML来说明网页中的元素是什么，而尽量避免使用HTML来描述元素的外观。 极端点说，诸如：&lt;font&gt;、&lt;b&gt;、&lt;u&gt;、&lt;i&gt;这样的标签就是HTML标签中的”怪胎”，应避免使用。 &lt;b&gt;和&lt;i&gt;目前也经常被用于 HTML 文档中, 但其所表达的意思通常已不再是原意”加粗”和”斜体”, 而是 bedge 和 icon ​ 曾经听到两位同学的这样一段对话： A：&lt;p&gt;标签是干什么用的？ B：就是让文字另起一行…… 本人认为，B同学完全忽视的&lt;p&gt;标签真正的作用是”定义一个段落”，换句话说是说明”这是一个段落”。而”让文字另起一行”这只是&lt;p&gt;标签作为块标记的一个”副作用”而已，我们完全可以使用CSS令其不另起一行。况且，”让文字另一起行”这是在控制元素显示效果（外观），这不应该是HTML标签的主要作用，而应该由CSS来承担。 上述言论完全是个人观点，若有异议，欢迎讨论，若打击到了某人，敬请海涵 :) OK，进入正题（请边阅读，边实验）…… CSS 基本使用方法与语法看个例子： &lt;p style=&quot;color:red;font-size:18px&quot;&gt;段落中文字是红色，大小为18像素&lt;/p&gt; 上述代码告诉浏览器，&lt;p&gt;&lt;/p&gt;中的文字显示为红色，大小为18像素。（快试一下吧！） 我们看到，要为一个标签说明样式，只需在标签中插入”style”属性即可。 语法格式：样式属性1:值1;样式属性2:值2;…… 属性与值之间使用冒号分隔，多个样式说明之间使用分号分隔。 好了，现在的问题是，到底有些什么样式属性可以使用呢？关于这个问题，本文不作阐述，读者可以查阅别的资料。或者，最简单的办法，使用IDE (如:Dreamweaver, VSCode) 的代码提示功能，如下图所示： 相信你在实验上面的例子时已经发现了怎么把这个提示框调出来了吧…… 从头至尾浏览一下提示框中显示的所有样式属性，中学英语水平应该可以足以看懂了，不行就查下字典嘛！ （花5~10分钟时间浏览完了再继续往下读…） 浏览的目的在于了解有些什么样式属性可用。就像你知道了有些什么材料，当你要盖房子时你就能灵活使用了。 当然能逐个试一下就更好了 :) 本人非常反对一开始就找一本厚厚的参考书，看完了才来实践！大胆猜测、大胆实验才是王道。 也别成天抬着嘴到处问，动不动就问别人”推荐一本书”，哎，又上火了，打击到你的话，我只能说 sorry了:） 应该注意，输入提示框里出现的那些样式属性不是所有属性在所有浏览器里都有效，所以要避免使用那些”非主流”的样式。 下面是本人小结的”主流”样式属性，分了类以方便记忆: 星号(*)表示此处有 0 个或多个字符 # 类别 说明 1 background* 元素背景相关 2 font*, text* 文字外观相关 3 border* 元素边框相关 4 margin* 元素外边距 5 padding* 元素内边距 6 list* 设置&lt;li&gt;标签的外观 7 其它 color、 line-heightposition、left/right/top/bottom、width/height、z-indexdisplay、visibilityfloat、clear、overflow、cursor 下面我们直接举例，请对照实践，并注意观察和总结。 background*以background开头的这一组样式属性主要说明元素的背景。例： 代码 说明 background-color : red; 背景为红色，支持多种颜色表示法, 如RGB表示法:#FF0000或#F00 background-image : url(“bg.jpg”); 设置背景图片为bg.jpg（相对路径表示） 设置了背景图，背景色就看不到了，除非背景图片失效 background-repeat : repeat-x; 背景图只在X方向（水平方向）上重复，还有其它值 ( repeat-y, no-repeat )，请自行实验 background-attachment : fixed; 背景图固定，不随滚动条滚动 background-position : 5px 10px; 设置背景图相对于元素左上角向右偏移5px, 向下偏移10px。可取负值。 注意善用此属性，可有意外惊喜! 可以把上面的代码简写为：background : red url(&#39;bg.jpg&#39;) repeat-x fixed 5px 10px; ​ font*、text*、color、line-height这一组属性均是说明文字的呈现形式，因此就一起举例说明了： 代码 说明 font-size : 12px; 设置文字大小为12像素 (请查阅其它资料了解其它单位) font-family : 宋体; 设置文字字体为”宋体”。应避免使用非主流字体，原因此处暂略，请自行思考 font-weight : bold; 文字加粗 text-align : center; 文字水平居中 text-decoration : underline; 文字加下划线 text-indent : 24px; 首行缩进24像素 color : red; 文字为红色，支持多种颜色表示法, 如RGB表示法:#FF0000或#F00 line-height : 24px; 每行文字的行高为24像素 请实验下面2段代码（省略号部分请自行填充不少于200字的一段文字）： &lt;p&gt;...&lt;/p&gt; &lt;p style=&quot;font-size:12px; line-height:22px&quot;&gt;……&lt;/p&gt; 第二段是否比第一段要美观，呵呵，自行小结一下吧！ 再实验下面这段代码： &lt;div style=”border:1px solid blue; width:200px; height:100px; text-align: center; line-height:100px;“&gt;文字&lt;/div&gt; 文字是否在div里垂直方向上居中了? 注意红色部分代码，又可以小结一下了！ ​ border*以 border 开头的这一组修饰元素的边框。边框分上、右、下、左四个方向，每个方向的边框可分别修饰”型”、”色”、”宽”。 看例子 (对于边框宽度须同时说明”型”、”色”、”宽”才有效) 代码 说明 border-left-color: red;border-left-style: solid;border-left-width:2px; 设置元素左边框为2px宽的红色, 实线边框 border-left : 2px solid red; 设置元素左边框为2像素宽的红色实线边 (上例的简写形式) border : 1px dotted red; 设置元素四周边框为1px宽的红色虚线边 border : 1px solid red;border-width : 2px 5px 10px 15px; 四周边框均为红色实线边，上、右、下、左边框宽度分别为2px、5px、10px、15px小结：(1) 第2行的代码覆盖了第1行中关于宽度的说明 (2) 四个方向的边框可属性可一起简写说明，中间以空格分隔，顺序为从”上”开始顺时针方向一周 border : 1px solid red;border-width : 5px 10px; 四周边框均为红色实线边，上下边为5px宽，左右边为10px. border : 1px solid red;border-width : 5px 10px 15px; 等同于 border-width : 5px 10px 15px 10px; ​ margin*、padding*margin指的是元素边框之外的空白，而padding则指元素边框之内与内容之间的空白。 是不是看得一头雾水? 没关系，暂时放一下，我们继续往下看，等读完”CSS入门精要（二）”就明白了。 ​ list*以list开头的这一组属性修饰&lt;li&gt;的外观，其中，list-style-type和list-style-image由字面即可猜到其用途，不行么试一下就知道了。 下面只讨论 list-style-position，直接看图： 左图为 list-style-position:outside 的情形，右图为 list-style-position:inside 的情形。 可以看到，未设置margin、padding 时： a) outside（默认值）：li元素内容紧靠相邻元素，项目符（那黑点）深入到了相邻元素内部 b) inside: li 元素项目符紧靠相邻元素，内容相应后缩。 ​ 其它样式属性这一组相对零散，下面配合例子说明： 代码 说明 width:50px;height:100px; 定义元素宽50px，高100px color: red; 设置元素中文字为红色，支持RGB表示的颜色，如:#FF00AB line-height:24px; 设置元素中文字行高24px cursor: pointer; 鼠标处于元素上方时显示为手指形状，类似处于超链接上方的效果 display: none; 隐藏元素。注意下面2行代码的作用：display: block; 设置元素以块标签方式显示display: inline; 元素以行内标签方式显示 还记得本文开头那两位同学的对话吗? 实验一下：&lt;p style=&quot;display:inline&quot;&gt;段落文字1&lt;/p&gt;&lt;p style=&quot;display:inline&quot;&gt;段落文字2&lt;/p&gt;现在P标记不再是换行的作用了吧…… visibility: hidden; 隐藏元素。与display: none的区别在于：使用visibility: hidden隐藏元素后元素原来占据的空间仍然保留，相邻元素并不侵占若原有空间。而display: none将元素隐藏后，原来占据的空间不再保留（试试就知道了） position: absolute; 设置元素的定位方式为绝对定位。关于position属性的几个取值及作用相对复杂，本文作为精简入门不再赘述，请参阅其它资料。 left:50px; 设置元素左外边距边界与其父容器左边界之间的偏移为50px left、top、right、bottom 4个属性的效果与position属性的取值有很大关系 z-index:999; 设置元素的叠放层次，z-index值越大，就越靠上层。 float:left; 元素向左浮动, 参阅 CSS入门精要（二） clear:both; 清除浮动效果, 参阅 CSS入门精要（二） overflow:scroll; 若元素中的内容超出了元素本身的大小，则显示滚动条。关于此属性的几个取值有一些让人很迷惑的效果和用途，读者可先实验，再上网搜索别的文档看看。 好了，至此我们已经初步了解了CSS的基本语法，以及常用样式属性的用途。 还是那句话，由于是精要入门教程，所以未对所有样式属性进行说明，即使文中提到的样式也未对其每一个取值用途进行详述，读者可自行实验、总结或查阅别的资料以学习本文未尽之处…… 前文中提到的的 float、clear、border、margin、padding 几个属性还有更多的内容需要讨论. 如果你已经基本理解了前文所述内容，那就继续看 CSS入门精要（二）吧！","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"https://baileykm.github.io/tags/CSS/"}]},{"title":"Java入门精要 (五)","slug":"Java入门精要-5","date":"2014-03-25T17:50:22.000Z","updated":"2019-05-10T20:29:50.620Z","comments":true,"path":"2014/03/26/Java入门精要-5/","link":"","permalink":"https://baileykm.github.io/2014/03/26/Java入门精要-5/","excerpt":"本节关键词: 抽象类与抽象方法, 接口, 桥接模式, List, Map","text":"本节关键词: 抽象类与抽象方法, 接口, 桥接模式, List, Map 抽象类与抽象方法 接口 List 和 Map 经过前面的学习, 对于基于Java的面向对象编程可算是入门了. 希望你也自己写了一些小程序, 或者看了一些别人写的程序. 在实践的过程中或许遇到了一些之前没有接触过的语法, 例如: 枚举 (enum) 的含意及使用方法; try … catch … finally … 这样的 “异常捕获” 语法; 但本系列教程主要关注基于Java语言的面向对象编程方法及思想, 因此在本教程中将不涉及这些基础语法, 希望读者自行补脑…… 当然在后续的例子中我们会很自然地用到这些东西, 到时会有简单的注释, 动一动你聪明的小脑袋, 应该可以很容易看懂, 所以也不用急着专门去学习…… 这一节里, 我们将把之前的例子进一步扩展, 让它更 “现实” 一些, 同时, 在这个过程中我们将学习新的知识. ​ 抽象类与抽象方法此前的例子中, 我们定义了两个类: Pig 和 SmallPig, 其中Pig类是SmallPig类的基类(父类), 而SmallPig类是Pig类的派生类(子类). 可以这样说, 作为父类的 Pig 更为通用一些, 而SmallPig 相对具体化一些. 事实上, 派生的过程确实是一步步扩展和具体化的过程…… 这里提醒一下, Pig 并非”大猪类”, 它是 SmallPig 类的父类, 是对 “猪” 相对 “普适” 的描述. ​ 好了, 既然还没有”大猪类” 那我们现在就定义一个好了…… 因为之前已经定义了 Pig 和 SmallPig 类, 那现在就只需要模仿 SmallPig 类来定义”大猪类”就好了. 代码如下: 123456789101112package com.bailey.study.animal;public class BigPig extends Pig &#123; public BigPig (String name) &#123; this(name, \"未知\"); &#125; public BigPig(String name, String sex) &#123; super(name, sex); &#125;&#125; 如果对于 “大猪” 没有更多需要进一步描述的, 那上述代码保持现状就好了. 否则, 你可以添加更多的属性和方法进行描述, 或通过 “覆盖” 对 Pig 类中已有的方法进行重新定义. ​ 继续…… 目前为止, 我们的猪类有了一个 eat 方法, 可以正常进食了, 但总不能白吃吧, 吃完要长肉, 长到一定程度就应该宰了~ 呵呵, 好悲催的猪! 好邪恶的人类! 因此, 为我们的猪添加一个存储当前体重的属性: weight. 因为无论 BigPig 还是 SmallPig都应该有体重, 因此, 我们把weight属性添加到了它们共同的父类 Pig 类中, 这样通过继承, BigPig 和 SmallPig 就自然地拥有了weight 属性了. 呵呵, 看到一点点传说中的代码复用了吧~ 修改后的代码如下 ( Pig.java ): 12345678910111213141516package com.bailey.study.animal;public class Pig &#123; ...... private double weight; ...... private void setWeight(double weight) &#123; this.weight = weight; &#125; public double getWeight() &#123; return weight; &#125; ......&#125; 上述代码中, 为了节省篇幅, 突出重点, 原先已有的代码使用省略号代替了… 注意: weight 属性前使用了 private 修饰符, 防止”外界”随意地修改猪的体重 (包括Pig类的派生类). 另一方面, 我们又不能把weight封得太”死”, 总得留一个读写的途径. 因此, 我们还定义了weight属性的 setter 和 getter 方法. weight的 “读” 方法 ( getWeight() ) 使用了 public 修饰符, 以便 “外界” 可以相对自由地得到猪的体重 setWeight ( … ) 方法使用了private 修饰符, 基于2个方面的考虑: (a) 把改写体重的控制权掌握在Pig类手中, 我们不想让 “外界” 随意改写体重值, 当然, Pig类的派生类也不行 (因为目前只有”吃”了才会长肉, 而”吃”的方法已经定义在了Pig类中, 无需留给Pig类的子孙后代改写体重的机会, 因此也没有使用protected修饰符 ); (b) setWeight() 因为是一个”函数”, 因此提供了更多的逻辑处理能力, 试想…… 如果今后我们要 “监视” 体重值, 以便通知饲养员”这头猪可以宰了”, 那么代码就可以添加在 setWeight 方法中了. ​ OK, 剩下的事情就是在猪吃东西的时候, 调用 setWeight() 方法让猪长点肉了…… 也许, 你已经想到了, 改写 Pig 类中的 eat 方法, 把代码攺成类似如下的样子 ( Pig.java ): 1234public void eat(String food) &#123; System.out.println(name + \"吃了\" + food); setWeight(weight * 1.001); // 每吃一次食物, 体重增长 0.1%&#125; 但是, 有这样一个现实情况: 大猪的生长速度显然不会有小猪快, 呵呵, 也就是说, 吃了相同数量的食物, 小猪的体重增长应该比大猪更多…… 因此… 上述代码中 setWeight(weight * 1.001) 这种“硬编码”形式显得太不灵活了…… 于是… 我们把体重的增长系数 (1.001) 做一下抽象: 由一个方法来返回增长系数, 这样在 BigPig 和 SmallPig 类中我们只要覆盖这个方法就可以更为灵活地设定猪的体重增长系数. 代码改成如下 ( Pig.java ): 12345678public void eat(String food) &#123; System.out.println(name + \"吃了\" + food); setWeight(weight * getGrowRatio()); &#125;protected double getGrowRatio() &#123; return 1.001;&#125; 怎么样? 是不是感觉面向对象编程语言越来越好用了? 呵呵, 但是… 相对于BigPig 和 SmallPig而言, Pig类是更为抽象的, 换句话说, Pig类并末具体化为大猪或是小猪, 我们这样 “武断” 地认为一头 “普适” 的猪 (Pig) 就该按 0.1% 的速度生长, 显然有点不妥…… 于是… 干脆把 getGrowRatio() 的函数体去掉得了, 因为我们在定义Pig类时根本不知道这头猪该有怎么的生长速度… 于是… 代码变成这样子 ( Pig.java ): 123456public void eat(String food) &#123; System.out.println(name + \"吃了\" + food); setWeight(weight * getGrowRatio()); &#125;protected double getGrowRatio(); OMG~ 这也行?! 呵呵, YES, Of Course YES! 只是, 现在getGrowRatio()方法没有内容了, 也就是说, 它更”抽象”了, 必须在定义时添加 abstract 修饰符, 相应地, Pig 类因为拥有一个抽象的方法, 也被变成抽象的猪类了, 在Pig类定义时也应添加abstract修饰符. 正确的代码应如下 ( Pig.java ): 12345678910111213package com.bailey.study.animal;public abstract class Pig &#123; ...... public void eat(String food) &#123; System.out.println(name + \"吃了\" + food); setWeight(weight * getGrowRatio()); &#125; protected abstract double getGrowRatio(); ......&#125; 好了, 这就是传说中的 “抽象类“ 和 “抽象方法“. 简单来说, “抽象方法” 就是未实现的方法 (没有函数体), “抽象类”就是含有抽象方法的类. 正因为是抽象的, 所以 抽象类是不能实例化的 , 即: 现在不能 new Pig () 了. 其中的道理应该一想就明白… (想不明白就多想一会~) ​ 关于抽象类和抽象方法, 它们完成了如下几项重大的”进化”: 提供了一种机制, 让功能的实现 “推迟” 到了派生类 “继承” 机制在实现代码复用的同时, 还提供了父类给子类指明”发展方向”的途径, 这事实上可以上升到所谓的”架构”层次. 而抽象类和抽象方法的引入, 让这种”为子孙后代指明发展方向”的功能发挥得更为自然. 通俗来说, 父类要求子孙们必须具备某项功能, 但在定义父类时又暂时无法确定这项功能应该具体如何实现, 于是把”具体化”的工作交给了后代. ​ 接口目前为止, 如果我们需要一头小猪, 那只要 new SmallPig(...); 小猪就出现了… 但是… 既然你把它 “生” 出来了, 就得喂它吧, 呵呵~ ( 好吧, 不应该是你把它生出来的! ) 也就是说, 如果猪儿们饿了, 应该可以通过调用类似 String getFood() { ... } 这样的方法来获得食物. ( 这猪好高级, 饿了还会主动要吃的, 呵呵~ ) 那么, 这个方法定义在那个类里面呢? 也许, 你已经想到了, 我们再来定义一个”饲养员”的类, 把 getFood() 方法定义在”饲养员”类里…… 但是, 可以提供食物的不止是饲养员吧, 比如… 猪妈妈应该可以给点奶吃… 再比如… 我们有一台高大上的”自动喂猪机”, 那它也应该可以提供食物… 换句话说, 提供食物的功能可以由不同的类来实现, 而这些类之间不一定有关系. 再换句话说, 其实, 我们关心的只是有某个东西能提供一个 getFood() 方法, 当调用这个方法的时候, 可以得到食物, 谁管它是什么东西呢…… ​ 说这么半天, 其实是想引入”接口“的概念. 术语化点说, 接口 ( Interface ) 是对功能的抽象, 而功能在这里其实就是方法. 这里抽象的好处在于可以把功能的 “描述” 和 “实现” 分离. “描述”可认为是方法(函数)的原型声明(函数头), 它告诉调用方, 方法名是什么? 需要什么样的参数? 会返回什么样的结果? 而”实现”就是方法(函数)体, 它是这个功能的具体实现. 对于上面的例子来说, “描述” 就是 String getFood(); 而 {...} 就是”实现”部分, 关键的是, “实现”部分可以在不同的类 (饲养员/猪妈妈/自动喂猪机) 完成. ​ 如果我们把一个或多个功能描述(函数原型声明部分)集中起来写到一起, 那就可以定义成接口了…… 代码如下 ( IFoodProvider.java ): 12345package cn.edu.ynnu.study;public interface IFoodProvider &#123; public String getFood();&#125; 那功能实现部分写在那里呢? 也就是说, 如何实现这个接口呢? 这就得有实现这个接口的类了… 比如: 自动喂猪机, 代码如下 ( PigFeedMechine.java ): 1234567891011package com.bailey.study.mechine;public class PigFeedMechine implements IFoodProvider &#123; ...... @Override // 这是一个\"注解\", 告诉编译器, 下面这个方法做了一个覆盖 (语法上并非必须) public String getFood() &#123; return \"玉米\"; // 返回食物 &#125; ......&#125; 当然, 你也可以模仿着定义出 “饲养员”, “猪妈妈”… ​ 怎么使用呢? 我们可以在 Pig 类中添加一个 setFoodProvider(IFoodProvider foodProvider) 方法, 把某个实现了IFoodProvider接口的类的实例”注册”给猪, 当猪需要食物的时候, 只要调用接口的 getFood() 方法即可…… 看看下面的代码 ( Pig.java ): 12345678910111213141516171819package com.bailey.study.animal;public abstract class Pig &#123; ...... private IFoodProvider foodProvider; public void setFoodProvider(IFoodProvider foodProvider) &#123; this.foodProvider = foodProvider; // 记录食物提供方 &#125; protected void feelHungry() &#123; // 饿了… if (foodProvider != null) &#123; eat(foodProvider.getFood()); // 把食物提供方返回的食物吃了 &#125; else &#123; ... // 继续饿着吧~ &#125; &#125; ......&#125; 此时, 若要调用 setFoddProvider() 方法, 为猪”注册”一个食物提供方, 只须传入实现了 IFoodProvider 的类的实例即可, 诸如: SmallPig sp = new SmallPig(...);sp.setFoodProvider(new PigFeedMechine()); ​ 上述代码中, 特别关注几个地方: 第 7 行, setFoodProvider 方法所需要的参数只是一个实现了 IFoodProvider 接口的对象, 并非某个具体的对象(饲养员/自动喂猪机) 第 12 ~ 13 行, 当需要食物时, 使用的也只是接口 IFoodProvider 类型的变量 foodProvider, 并非某个具体的对象 总之, 对于 Pig 类而言, 我们无须关心是谁提供食物, 只关心有某个东西能够提供食物 ( 只要实现了 IFoodProvider即表明此类的实例可以提供食物 ). 而对于那些实现 IFoodProvider 接口的类而言, 它们同样无须关心谁在使用它. 进一步说, 通过接口机制, 实现了功能提供方 (饲养员/自动喂猪机…) 和 功能调用方 (猪) 之间的解耦合, 这正是我们一直在追求的 “低耦合“. 在这里, 接口就象一座桥, 它把功能提供方和调用方连接起来了, 而这种连接又是相对松散的, 低耦合的, 灵活的. ​ 相对而言: 抽象类实现了一个家族体系 (继承体系) 内的功能抽象, 而接口把功能抽象进一步地延伸到了不同的家族中. ​ List 和 Map既然讲到接口, 那么我们就顺带提一下在Java中非常常用的两个接口: List 和 Map , 这两个接口均定义在 java.util 包中. 实现 List 接口的类很多, 其中最常用的应是 java.util.ArrayList . List 用来存储一组顺序数据, 而并不限定数据具体类型. 参看下面的代码, 也许可以有点感觉 代码很好猜, 如果看不懂就查英汉词典, 就不写注释了): 123456789List list = new ArrayList();list.add(\"a\");list.add(\"b\");list.add(\"c\");for (int i = 0, size = list.size(); i &lt; size; i++) &#123; System.out.println(list.get(i));&#125;list.remove(0);list.remove(\"c\"); ​ 同样, 实现 Map 接口的类也很多, 其中 java.util.HashMap 较常用. Map 用来存储 “键-值对“, 它也同样不限定存储的元素类型. 参看下面的代码: 123456Map map = new HashMap();map.put(\"sp1\", new SmallPig(\"小花\", Sex.公));map.put(\"sp2\", new SmallPig(\"小黄\", Sex.母));map.put(\"sp3\", new SmallPig(\"小黑\", Sex.公));System.out.println( ((SmallPig) map.get(\"sp1\")).getName() );map.remove(\"sp1\"); ​ 也许你会注意到上面的代码如果放到 Eclipse 里, 有出现 “警告” ( warning, 划黄色波浪线 ). 为什么呢? 通俗来说, 因为 List 或 Map 并不限制放入其中的元素类型, 但是这样可能对程序员而言似乎有些 “纵容”, 万一程序员一个失手, 本该放头猪进去, 却一不小心放了一头牛, 那 List 和 Map 其实是没有意见的, 在语法上没有任何问题, 但是在逻辑上就错了. 为了避免这种情况的发生, 更好的做法是, 在声明和实例化的时候就明确一下要放入的是什么类型的东西, 这样编译器就可以帮你检验放入的数据是否合法了. 上述代改写如下: 12List&lt;String&gt; list = new ArrayList&lt;String&gt;();Map&lt;String, SmallPig&gt; map = new HashMap&lt;String, SmallPig&gt;(); 当然, 既然已经明确了放入map的 “键-值对” 中的”键”是 String 类型的, 而”值”是 SmallPig 类的, 那么前面的代码中就无须强制转换了, 即可以删除 (SmallPig) 部分: System.out.println( ((SmallPig) map.get(“sp1”) ).getName() ); 上面的阐述只是为了便于理解, 严格的定义和概念, 请查阅关于 泛型 的资料. ​ OK, 就到这里, 本节我们学习了抽象类和接口, 另外也捎带了解了一下泛型. 从现在开始, 我们应该逐渐从只关心怎么把功能实现, 转变到如果把程序写得更好 ( 健壮, 结构清晰, 有条理, 易读, 易维护……), 也就是往所谓 “架构” 层面去思考和设计……","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"}]},{"title":"Java入门精要 (四)","slug":"Java入门精要-4","date":"2014-03-25T17:47:22.000Z","updated":"2019-05-10T20:29:43.143Z","comments":true,"path":"2014/03/26/Java入门精要-4/","link":"","permalink":"https://baileykm.github.io/2014/03/26/Java入门精要-4/","excerpt":"学习完前 3 节后是否感觉似乎学会了一些东西，但是又感觉脑袋里充满了浆糊？ 这一节我们来整理一下思路, 算是前一阶段的小结, 为开启新的征程做好准备.","text":"学习完前 3 节后是否感觉似乎学会了一些东西，但是又感觉脑袋里充满了浆糊？ 这一节我们来整理一下思路, 算是前一阶段的小结, 为开启新的征程做好准备. 一下吃太多了，消化不良了, 呵呵~ 两个办法可以让自己好受点： （1） 暂时停下脚步，再看一遍前 3 节，自己做一下小结，一个字…… 悟！ （2） 实践，自己做几个小例子，实践一下前面讲过的内容 ​ BUT！ 多年的实践证明，说了也等于白说，能停下来悟道的人不多…… ​ 所以，作为一个好人，下面我还是带你站高一点，宏观地看看目前学过的这些东西，也许会有帮助。 OK， 走起~ ​ 事实上，那些让人晕头转向的语法规定一直致力于通过引入一些机制, 让程序员少干点活, 并引导程序员保持相对清晰的头脑, 干活更有条理. 相对术语化地说, 即是: 尽可能地实现”代码重用“, 而又不失灵活性. 提供一些”开/闭机制“, 让程序员得以在“封闭”与“开放”之间寻找一个最佳的平衡. 更高层次来说, 便于实现更加稳固且便于扩展的程序架构. ​ 我们来回顾一下前两节学过的一些东西…… “类” 和 “对象” 概念的提出实现了数据和功能封装，将其聚合为一个相对独立的单元，而“继承”机制的引入最直接地实现了代码重用. 并且, 在继承过程中父类为子类指明了发展的方向. “重载”实现了一个类内部的”变异”, 而“覆盖” 则体现了继承过程中子类代对父代的”革新”, 这些都为程序员提供了扩展的途径. ​ 虽然, 封闭的”最高境界”是封得密不透风, 但若真如此就没有意义了. 因此, public, protected, private 修饰符在不同的范围内提供了开放的可能性, 并把控制权交给了程序员, 即: 可控的开/闭. static 修饰符的引入在一个方面实现了对象之间的数据共享. 同时将数据和功能从对象层面提到了类层面, 或者说把数据和功能从相对 “动态” 的对象中提到相对 “静态” 的类中. final 修饰符又封堵了变化可能性, 给程序员一机会做到适时地封闭. ​ 最后, 为那些之前只接触这 C 语言这类”面向过程”的程序设计语言的同学洗个脑…… 在使用C这样面向过程的程序设计语言编程时, 我们的工作大致可以分2步: (1) 功能封装: 定义实现各种功能的函数(过程); (2) 通过函数间的相互调用, 让程序运行起来…… 而使用 Java 这样的面向对象的程序设计语言编程时, 我们首先站在对象的视角去定义类 然后…… 在运行时, 让类实例化成对象, 然后…… 调用对象的方法 ( 函数 ) 以完成所需的工作, 然后…… 然后就没有然后了…… 对照之前的实例, 想想是不是这个过程: 首先把自己当做一头猪 ( 小花 (对象) ), 思考做为一头猪应该有些什么数据和功能, 然后定义猪类, 然后……通过 new Pig() 把猪类变成小花 ( 具体的对象 ), 然后…… 调用小花的 eat() 方法让它吃东西, 然后…… 就没有然后了…… ​ 最后的最后做个节目预告, 下一节我们将学习 “接口” 和 “抽象类”, 本节就先到这里, 给一点消化的时间…… ​ ​ 后面的教程中我们还要继续延伸这个”猪”的例子, 为了保证你的代码与我的例子没太大出入, 现将到目前为止的代码附上…… 文件结构: Pig.java 123456789101112131415161718192021222324252627282930313233343536package com.bailey.study.animal;public class Pig &#123; protected String name; final public String sex; public Pig(String name) &#123; this(name, \"未知\"); &#125; public Pig(String name, String sex) &#123; this.name = name; this.sex = sex; &#125; public void eat(String food) &#123; System.out.println(name + \"吃了\" + food); &#125; public void eat(String food, boolean isHot) &#123; if (isHot) &#123; System.out.println(\"等呀等... 终于凉了...\"); &#125; eat(food); &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; SmallPig.java 123456789101112131415161718192021222324package com.bailey.study.animal;public class SmallPig extends Pig &#123; public SmallPig(String name) &#123; this(name, \"未知\"); &#125; public SmallPig(String name, String sex) &#123; super(name, sex); &#125; @Override public void eat(String food) &#123; if (!\"奶\".equals(food)) &#123; throw new RuntimeException(\"小猪只能吃奶!\"); // 不是\"奶\", 抛出异常 &#125; super.eat(food); // 调用父类eat方法 &#125; public void play(String toy) &#123; System.out.println(name + \"玩了会\" + toy); &#125;&#125; HelloJava.java 1234567package com.bailey.study.test;public class HelloJava &#123; public static void main(String[] args) &#123; &#125;&#125;","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"}]},{"title":"Java入门精要 (三)","slug":"Java入门精要-3","date":"2014-03-12T05:25:00.000Z","updated":"2019-05-10T20:30:00.895Z","comments":true,"path":"2014/03/12/Java入门精要-3/","link":"","permalink":"https://baileykm.github.io/2014/03/12/Java入门精要-3/","excerpt":"本节关键词: 继承, 父类, 子类, 祖先类, 派生类, this 与 super, 覆盖, 异常, 等值判断","text":"本节关键词: 继承, 父类, 子类, 祖先类, 派生类, this 与 super, 覆盖, 异常, 等值判断 继承 覆盖(Override) 继承 关于”继承”的概念、为什么要继承、继承的好处等一些基础性的知识在本 Blog 中的另一文章“面向对象起步 — 封装、继承、多态”已有讲述, 因此此处不再赘述, 本文仅对如何在 Java 中实现继承进行阐述…… ​ 我们沿袭前面的例子, 由 Pig 类派生出一个子类 SmallPig (小猪): 在 com.bailey.study.animal 包内新建一个类, 并使用 extends 关键词实现继承, 代码如下: ​ 如上图所示, 当添加了代码 extends Pig 后 Eclipse 提示了一个错误, 大意是: 在父类 Pig 中未定义默认构造函数 Pig(), 因此必须定义一个明确的构造函数. 还记得上节最后讲述构造函数的时候我们列出了几点需要注意的, 其中第 (2) 点当时可能看不明白, 现在就来一起解释一下: 继承事实上是在父类的基础上进行 “扩展 ( extend )”. 当实例化子类的时候, Java 会先去实例化其父类, 因此, 若父类中没有那个不带任何参数的缺省 (默认) 构造函数, 那么子类在实例化的时候就必须明确要通过哪一个父类构造函数去实例化父类, 否则…… 爹都生不出来, 儿子怎么出来? 呵呵~ 那咋办呢? 看上图…… Eclipse 其实已经给出了2个建议 ( quick fix, 可以直接点击, 之后 Eclipse 会帮你把代码写好…) 下面的代码是经人工修改后, 正确代码: 12345678910package com.bailey.study.animal;public class SmallPig extends Pig &#123; public SmallPig(String name) &#123; this(name, \"雌\"); &#125; public SmallPig(String name, String sex) &#123; super(name, sex); &#125; &#125; 注意, 上述两个 SmallPig 类的构造函数均必须通过某种方式去调用父类的构造函数 (第 5 行 和 第 8 行). 其中: 第 8 行通过 super 关键词直接调用了父类中定义的构造函数: Pig(String name, String sex). 第 5 行则通过 this 关键词调用了当前类中第 7~9 行定义的构造函数 ( 间接地调用父类构造函数). 试着按住 Ctrl 键, 用鼠标点击第 5 行的 this …… 看到效果了吧 (点击函数名, Eclipse会跳转到实际执行的函数的声明位置, 点击变量, 则会跳转到变量声明位置) 上面是继承之后, 子类中必须解决的一个问题. ​ 覆盖(Override)下面来看另一个概念: 覆盖. 显然, SmallPig 恐怕还不能吃 “米饭”, 得吃 “奶” ! 因此, 我们为 SmallPig 重新定义一下 eat 方法, 将如下代码添加到SmallPig类中: 1234567@Override // @Override 注解告诉编译器注意校验\"下面的方法是覆盖版本\"public void eat(String food) &#123; if (!\"奶\".equals(food)) &#123; // 判断食物是否是奶 throw new RuntimeException(\"小猪只能吃奶!\"); // 不是\"奶\", 抛出异常 &#125; super.eat(food); // 调用父类eat方法&#125; 如上面代码所示, 简单来说, 在子类中重新定义祖先类中已有的方法就叫做覆盖 (或重写). 注意和第 (1) 节中讲到的重载对比一下 重载发生在同一个类的 “内部”, 而覆盖(重写)发生成祖先类和子类之间 ​ 先试试效果吧…… 什么? 怎么试? 好吗, 最后帮你一次…… 代如下: 复制不了…… 呵呵, 我故意的! 防止懒人偷代码! 什么都不想动手, 只是傻看的话永远学不会…… ​ 怎么样, 试了吗? 控制台 ( Console ) 是不是出现了异常信息, 并列出了函数调用栈的信息: 第一次见到这个东东, 简单解释一下…… 上图这段输出的大意是: 在线程 “main” 中出现了异常 ( Exception ), 这个异常是 RuntimeException (运行时异常), 后面那几个汉字不用解释了吧~ 第 2 行陈述了异常是在执行到哪一行抛出的 ( SmallPig.java 中的 16 行, 也就是上面代码的第 5 行, 鼠标点击一下带下划线的部分试试… ) 第 3 行表达的意思与第 2 行类似: 在执行到HelloJava.java中第 10 行出现异常…… 如果我们从下往上读, 是不是就是程序实际执行时的调用顺序~ 也许现在最吸引你注意的是 “异常(Exception)” 这个新鲜玩意是什么鬼, 或是上面出现的几行看不太懂的代码 ( 第3, 5行 ), 但先把它放下, 我们后面还会详细介绍. ​ 现在花10分钟 ( Maybe… 20 分钟 ), 设置断点, 单步跟踪程序的执行过程, 并仔细琢磨一下 p.eat(&quot;奶&quot;) 和 p.eat(&quot;奶&quot;, true) 是如何一步步执行的? 也许, 你还应该花点时间改变一下 Pig 类中那些属性和方法的可访问性修饰符, 看看效果…… 也许…… 你还应该在Pig类中使用一下 final 修饰符试试…… ( 把 final 放在类声明部分和 eat 方法声明部分试试 ) 再次强调, 本教程不能只是看… 必须边看, 边实验, 边思考, 你才能看得懂! ​ OK, 是不是越来越复杂了, 呵呵~ 确保前述内容没有太大的问题之后, 继续往下看…… ​ 虽然作为一头人品正常的猪, 生活就是”吃”和”睡”, 这是多少人向往的生活啊…… 但在下私心里估摸着, 猪儿的童年想必也是极喜欢玩耍的吧, 或许……平日间偶尔玩一下也是极好的~ 呵呵, 来吧, 给小猪类加个”玩”的方法…… 代码如下: 1234public void play(String toy) &#123; // 把 Pig 类中的 name 属性改为 protected 修饰就不报错了 System.out.println(name + \"玩了会\" + toy); &#125; 意思都明白吧…… 如果我们执行”小花”的play方法, 例如: p.play(&quot;球&quot;); 那应该输出: 小花玩了会球 ​ OK, 继续, 修改 HelloJava.java 的代码, 变成如下样式: 咦~ 好多错…… 别急, 我们一起来细细琢磨…… (1) 先把第 13~33 行注释掉 ( 选中 13~33 行, 按 “ Ctrl + / “ , 呵呵, 又学了一招~ 如果你不嫌麻烦, 删除也行 ), 运行一下试试…… 显然, 这没问题…… (2) 把 13~15 行加上…… 先看 13 行, 有意思吧, SmallPig 可以变成 Pig…… 废话~ 小猪当然也是猪了…… 这个故事告诉我们: 子类对象可以非常顺畅地转化为父类(祖先)的实例; 再看 15 行, 不用运行, Eclipse已经告诉你有问题了…… 既然 SmallPig 已经变成 Pig ( p2 )了, 那自然就不再会有play方法了, 因为 Pig 中压根就没定义过play方法. 这个故事告诉我们: 子类对象变成父类(祖先)实例后, 子类中新增的属性和方法将不再可用. 严格来说是不可视, 并未真正消失. (3) 把 15 行注释掉, 加上 17 ~ 19 行. 嘿嘿~ 猪 p2 被”强制转换”成小猪了, 这是允许的. 并且, 在第 19 行它又可以玩球了…… 运行试试…… 这个故事又告诉我们: (a) 类型是可以强制转换的, 语法见代码; (b) 子类对象变成父类(祖先)实例后, 新增属性和方法会暂时不可用, 但再次转回子类后, 那些属性/方法就又可用了. (4) 21 行是一条华丽丽的分隔线…… 歇会儿~ 喘口气, 想明白了继续…… (5) 加上 23 ~ 25 行, 25 行出错了, 这个错误比较低级, 自己应该想得明白, 我就不侮辱你的智商了…… (6) 注释掉 25 行, 加上 27~29 行, 又出错! 为什么? 因为…… 父类对象不能”顺畅地”直接转换为子类的实例 ( 与 13 行对比一下…… ). 虽然我们可以硬生生地拿着q2去play (第 29 行), 但 27 行编译都过不了, 那就别提运行了…… (7) 注释掉 27~29 行, 加上 31~33 行…… 呵呵, “强制转换”真的很牛吧~ 第 31 行一切正常, 编译也是可以通过的. 但是…… 运行试试…… 会在 33 行抛出异常 ( 虽然编译没错, 这叫运行时异常 ). 这个故事告诉我们: “强制转换”真的很强, 它能让编译器闭嘴, 但是…… 猪就是猪, 它绝对不可能变成小猪, 即使变成了小猪, 也是个半残废 (不会”play”). ​ 不要怀疑自己的智商, 彻底把你绕晕一直是我追求的目标…… OMG~ 谁扔的鸡蛋…… Just Relax ! 慢慢想, 不能完全想明白也不要紧, 能想明白多少算多少. 多练习, 也许有一天你就会突然明白了, 现在实现看不懂上面那段 (1) ~ (7) 就当没看见就是了. ​ ​ 不知不觉中, 我们已经把面向对象三大特性 (封装、继承、多态) 最基本的实现形式学完了, 小朋友们是否学会了呢? 如果喜欢记得叫上爸爸妈妈一起来顶贴哦~ 按照惯例, 给点温馨提示: (1) Java中无论是原生的类 ( 如: String, Integer ), 还是你自己定义的类 ( 如: Pig, SmallPig ), 它们都有一个共同的祖先: Object, 这是所有”类”的家谱中的”根”. ( 如果在声明类时没有extends…, 那 Java 会自己帮你加上 extends Object). 自己抽空看看 Object 类里被预先定义了些什么方法和属性吧… (2) 正因为 (1) 中所述, 有时我们要将两个”不相关”类的对象作为参数传递给一个函数时, 该函数的参数类型可选用Object. 但这只是权宜之计, 如果你的代码中真出现这样情况, “可能” 意示着那个函数设计得有问题 ( 违背了函数功能独立性原则, 因为你把两类不相关的参数传给同一个函数处理 ). 当然, 也不是说绝对不能使用 Object 作为形参, 所以说 “可能” 设计有问题. (3) 判断两个变量是否”相等”时, 千万注意: 对于引用类型 ( 对象 ) , 比较运算符 “==” 判定的是这两个变量是否是 “同一个” ( 在内存中就是同一个空间 ), 而非判定两个变量的”值”是否”相等”. 同理, 运算符 “!=” 类似…… 对于引用类型, 若要判定”值”是否”相等”, 一般使用equals方法. 当然, 对于我们自己定义的类, 必要时应覆盖Object类中已定义的equals方法. 对于非引用类型 ( 可简单理解为 Java 预定义的那些类型名以小写字母开头的类型, 如: int, boolean, char, long, double… ) 不存在前述问题. 可运行下面的代码, 比较一下就明白了: 1234567891011121314151617181920package com.bailey.study.test;public class Test &#123; public static void main(String[] args) &#123; String a = \"1\"; String b = new String(\"1\"); if (a == b) &#123; System.out.println(\"==\"); &#125; else &#123; System.out.println(\"!=\"); &#125; if (a.equals(b)) &#123; System.out.println(\"equal\"); &#125; else &#123; System.out.println(\"not equal\"); &#125; &#125;&#125;","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"}]},{"title":"Java入门精要 (二)","slug":"Java入门精要-2","date":"2014-02-25T09:01:22.000Z","updated":"2019-05-10T20:30:32.374Z","comments":true,"path":"2014/02/25/Java入门精要-2/","link":"","permalink":"https://baileykm.github.io/2014/02/25/Java入门精要-2/","excerpt":"本节关键词: 可访问性控制、修饰符, 代词this, 构造函数","text":"本节关键词: 可访问性控制、修饰符, 代词this, 构造函数 可访问性控制 构造函数 final static 可访问性控制关注 HelloJava 类的第 9 行, 这里我们直接通过 p.name = &quot;小花&quot; 对对象 p 的内部属性进行了操作, 这事实上破坏了对象的”封装性”, 这是不可取的! 也就是说, 我们应该尽可能地将对象的成员 ( 属性/方法 ) 封装在内部, 而不是随意地向外界暴露, 这才更符合封装的原则. 这就像你的钱总得藏着点, 不能随意让外人使用. 请自行查阅关于 “开/闭原则” 的资料. ​ 那么怎么把不想向外界暴露的成员藏起来呢? 这就要说到一个新的话题: 可访问性控制 某些材料上也叫 “可视性/可见性” ​ 打开 Pig 类的源代码, 将 name 属性前的 public 修饰符改为 private, 代码如下: private String name; 保存 ( Ctrl + S ) …… 之后我们注意到在 HelloJava 类的图标上出现了一个红色的叉, 这就说明出问题了…… 切换到 HellowJava 类的代码视图 (如下图), 把鼠标放在划红线的那里, 看看人家说什么了…… 大意是: Pig 类里的 name 属性 (filed, 字段) 不可见! 也就是说, 在 HelloJava 的 main 方法中不能直接访问 name 属性了. 看出 private 修饰符的作用了吧~ 它把 name 属性变成私有的了, 藏起来了…… ​ 在定义类, 属性或方法时, 我们可以添加访问控制修饰符, 以控制其可访问性. Java中有 3 种访问控制修饰符, 它们的作用如下: private : 私有的, 只在当前类中可访问. protected : 被保护的, 只在当前类, 当前类的子孙类 (子孙后代), 以及与当前类同属一个包 (package)的其它类中可访问. public : 公有的, 在所有类中均可访问. 那么…… 如果不写任何修饰符时”可访问性”又是如何呢? 这种情形下通常称作 default 修饰符, 它并不等同于 private, protected 或 public中的任何一个! 具体的差异可参看下表: 修饰符 当前类 同一个包里的类 子孙类 其他包里的类 public YES YES YES YES protected YES YES YES NO default YES YES NO NO private YES NO NO NO ​ 现在我们成功地把 name 属性私有化了, 那么如果有需要时, 外界怎么对它进行操作呢? 在Pig类中添加代码, 让它变成下面的样子: 12345678910111213141516package com.bailey.study.animal;public class Pig &#123; private String name; public String sex; public void eat(String food) &#123; System.out.println(name + \"吃了\" + food); &#125; public void setName(String name) &#123; this.name = name; // 在任何对象中, 代词 this 均指代当前对象 &#125; public String getName() &#123; return name; &#125;&#125; 我们为 Pig 类添加了2个方法: setName 和 getName. 这两个方法使用 public 修饰, 这样外界就可以通过这两个方法对 name 属性进行赋值或取值了. ( 相应地, 应该把HelloJava类中的 p.name = &quot;小花&quot; 改成 p.setName(&quot;小花&quot;); ) ​ 这样做的好处是: 我们可以灵活控制外界对 name 属性的访问. 例如: 当需要在给 name 属性赋值时做一些额外的附加的操作 (如: 数据合法性校验), 就可以把代码写在 setName 方法中. 当然, 如果不想让外界取得name的值, 那把getName方法去掉就行了. 对于 setXXX, getXXX 这样的方法, 通常称为 setter 和 getter方法. ​ 上面代码中第 10 行很有趣: this.name = name; 其中, this.name 指的是当前对象的name属性 (在对象 A 中, this.name就是 A 的name属性, 而在对象 B 中, 它就是 B 的name属性). 而 “=” 后面的 name 指的是setName方法的name参数 (形参). 这里的代词 this 指向当前对象. 类似地, 还有一个代词: super, 它指向当前类的直接父类. 关于 this 还有另外一层意思, 请继续往下看, 在讲述”构造函数”时将会提及. ​ 构造函数接下来我们插播一个内容: 构造函数. 所谓”构造函数”其实是一种特别的函数, 它的名称与类名相同, 在实例化的时候构造函数将被首先执行. 通常在构造函数中做一些初始化的工作. 现在在Pig类中添加一个方法, 代码如下: 12345public Pig(String name, String sex) &#123; this.name = name; this.sex = sex; System.out.println(name + \"出生啦(Constructed)!\");&#125; 这样我们为Pig类添加了一个构造函数. 相应地, 在实例化时就应该传入所需的参数, 例如: Pig p = new Pig(&quot;小花&quot;, &quot;雄&quot;); 赶快试试吧~ ​ 与普通方法一样, 构造函数也可以被重载. 试着再为Pig类添加一个构造函数, 代码如下: 123public Pig(String name) &#123; this(name, \"未知\"); // 调用上面定义那个构造函数&#125; 注意一下第 2 行, 又见到 this 了. 在这里 this 特指当前类的构造函数, 事实上第 2 行的写法就是告诉 Java, 根据传入的参数去选择调用一个合适的构造函数. 把 HelloJava.java 中的 Pig p = new Pig(&quot;小花&quot;, &quot;雄&quot;); 改成 Pig p = new Pig(&quot;小花&quot;); 设置断点, 跟踪调试一下吧~ ​ 关于构造函数, 还有几点需要注意: (1) 当一个类中没有明确定义任何构造函数时会存在一个不带任何参数 ( 形参表为空 ) 的构造函数 类似这样: public Pig() { } 这个构造函数称作默认构造函数. 而当我们明确地定义了任何一个或多个构造函数后, 上述默认构造函数就消失了. (2) 若父类中无默认构造函数 ( 形参表为空的构造函数, 如: Pig() { … } ), 则子类中必须至少明确定义一个构造函数. 并使用super(...)调用父类构造函数. (若看不懂, 暂时放一下, 在学习到继承时就明白了) (3) 若构造函数中出现了 this(...); 那么必须把它写在当前构造函数中的第 1 行. ​ 插播完”构造函数”的介绍后, 让我们再回到修饰符的介绍… 前面提到的 public, protected, private 修饰符主要是对可访问性 (可视性) 进行控制, 而现在将要讨论的这两个修饰符 ( final 和 static ) 并不影响可访问性. 具体是怎样的? 现在就来看看吧… ​ final添加了 final 修饰符的属性、方法、类将被认为是”最终版” 若修饰属性, 表示该属性在初始赋值后将不可重新赋值 (类似”常量”) 若修饰方法, 表示该方法是不能被覆盖 若修饰类, 则表示该类不能被继承 ​ final 修饰方法 和 置于类声明之前的情形, 涉及到 “继承”, 因到此为止尚未谈及如果实现继承, 暂不举例. 可先记住前述的规则. 先看修饰属性的情形: 修改一下上节例子中的 Pig 类, 为 sex 属性加上 final 修饰符 (我认为性别一旦设定就不能乱变了, 呵呵~). 1final public String sex; OK, 现在试试在别的地方给sex赋值一下… 是不是Eclipse已经提示错误了~ ​ 也许, 你已经想到了一个问题, 既然刚才我们说final用于修饰属性时类似”常量”, 那么应该象 C 语言一样, 在声明的时候就必须赋予初始值呀! 显然, 上面那句代码是没有给 sex 属性赋初值的, 那怎么 Eclipse 在这个时候为什么又不报错了呢? 呵呵, 秘密就在我们上节定义的构造函数中~ 我们在构造函数中通过代码 this.sex = sex; 对其进行了初始化. ( 记住: 构造函数在对象实例化的第一时间被执行 ) ​ 小结一下, final修饰属性时只能在 3 个地方对该属性赋值(三者取其一): (1) 声明同时, 例如: final public String sex = “雄”; (2) 在构造函数中. 并且, 即使是在构造函数中也只能赋值一次. (3) 在静态代码块中赋值 ( 什么是静态代码块? 简单来说, 就是使用 static 关键词修饰的一块代码, 类似 static { … }, 后文介绍 ) 总之…… final修饰的属性, 只能被赋值一次, 之后…… 该属性就是”终态”的了…… ​ final 还可以放置在方法的参数前 或 方法体中的声明的变量之前, 此时的含意亦与”常量”类似. 例如: 12345public void f (final String param) &#123; final int x = 3; param = \"Another\"; // 不允许 x = 5; // 不允许&#125; ​ staticstatic 意为”静态”的, 相信学过 C 语言的同学对它并不陌生. 这里所谓的 “静态”, 可姑且将其理解为: (1) 被 static 修饰的东东从属于类, 而非实例 (对象), 因此, 与类同生共灭 (2) 被 static 修饰的属性将被该类的所有实例 (对象) 共享 ​ 呵呵, 很不好理解吧~ 在解释之前我们先定义几个术语, 以便描述: (1) 实例变量 : 没有 static 修饰的属性. ( 此前例子中的 name, sex 都是实例变量 ) (2) 静态变量 : 有 static 修饰的属性 (3) 局部变量 : 定义在方法 (函数) 体中的变量 (4) 静态方法 : 有 static 修饰的方法 (函数) ​ OK, 继续… 实例变量 事实上是属于具体的实例 (对象) 的, 只有使用 new 关键词将类实例化为对象后, 它们才实际存在, 所以我们说它们是从属于具体实例 (对象) 的, 所以叫它们 “实例变量”. 我们在定义类的时候, 只是声称属于该类的所有实例 (对象) 均必须有这些属性 (实例变量), 而那个时候 ( 定义类的时候) 还没有任何实例产生, 因此, 这些实例变量也并未真正分配存储空间. 静态变量 则是属于类的, 它被属于该类的所以实例 (对象) 所共享. 只要类存在, 此属性就已经存在了, 而不必等到产生具体的实例 (对象) 才产生此属性. “类” 相对于 “对象” 而言是 “静的” , 所以这样的属性称作 “静态变量”. ​ 看下图可能更好理解: 哎呀~ 画图的水平真是不行, 还是辅以文字说明一下吧…… 上图中, x 为实例变量, 当我们通过 new Test() 创建出 3 个实例后 ( 实例A、实例B、实例C ) , 即会产生x的 3 个独立副本, 可以通过 a.x = 1; b.x = 2; c.x = 3; 分别赋值. 若继续执行 a.x = 4, 只会导致实例 A 的 x 值变为 4, 而不会影响到实例 B 和 C . 然而, y 为静态变量, 被实例 A、B、C 所共享, 即: a.y, b.y, c.y 是同一个东东, 值都是 5, 若执行 a.y = 6, 则 a.y, b.y, c.y 都将等于 6. 这就是实例变量 与 静态变量的区别. 所以, 我们可以说 “静态变量” 并不属于具体的某个实例, 而是属于类. 因此, 在写程序的时候, 我们通常不像上面写 a.y = 6, 而是写成 Test.y = 6 ( 使用类名引用, 而非对象 ) ​ 当 static 被用于修饰某个方法(函数)时, 该方法就被称作该类的静态方法, 它同样不依附于任何实例. 所以, 即使没有任何实例存在, 也可以使用类似 Test.f(); 的方式来调用静态方法 f() ​ 对于 static 还有一个特别的用法: 用来修饰一段代码, 姑且称其为”静态代码块“吧, 例如: 1234567public class Test &#123; public static int z = 0; static &#123; System.out.println(\"static 修饰的代码被执行了...\"); &#125;&#125; 其中, static { .... }大括号内的代码将在首次使用到Test类的时候被自动执行…… 你可以在 HelloJava.java 中写上一句 System.out.println(Test.z); 运行程序试试~ 是不是输出下面的结果了: 12static 修饰的代码被执行了...0 说明一下: 上面第 1 行是 “静态代码块” 里输出的, 而第 2 行是新写入的 System.out.println(Test.z); 输出的. 呵呵, 有意思吧…… ​ 小结: (1) static 可以修饰 属性 (静态变量), 方法 (静态方法), 或一段代码. (2) static 修饰的东西是从属于类的, 生命周期与类相同, 不依赖于实例. (3) 正因第 (2) 条所述 ( 从属于类, 不依赖于实例 ), 所以… 有可能静态方法或静态代码块被调用/执行的时候还没有任何实例存在. 因此, 不能在静态方法或静态代码块中访问/调用非静态成员 ( 如: 实例变量, 非静态方法 ) static也可以放在内部类的定义前, 这样的类称为静态内部类. 关于什么是内部类, 什么是静态内部类, 它们和普通的类有什么区别, 我们这里暂不展开, 只是提一下 static 还可以使用在类定义时. ​ 好了, 本节至此结束. 这一节里我们主要学习了这些内容: public, protected, private, final, static 代词 this 构造函数 ( constructor ) 回忆一下, 它们都是什么意思? 怎么用? ​ 下一节我们将介绍 “继承”, 敬请期待 ……","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"}]},{"title":"Java入门精要 (一)","slug":"Java入门精要-1","date":"2014-02-24T09:31:12.000Z","updated":"2019-05-10T20:30:15.284Z","comments":true,"path":"2014/02/24/Java入门精要-1/","link":"","permalink":"https://baileykm.github.io/2014/02/24/Java入门精要-1/","excerpt":"本系列教程为 Java 语言的入门教程, 主要针对有一定编程基础的同学, 帮助其了解 Java 的基础语法, 以及面向对象的一些基本特性在 Java 中的实现方式. 阅读本文之前请先学习博客中的另一文章“面向对象起步 — 封装、继承、多态”, 以了解面向对象编程的基本概念. 本文将不再复述其中已提到的概念和术语. 本节关键词: 类、对象、包、属性、方法、重载、调试","text":"本系列教程为 Java 语言的入门教程, 主要针对有一定编程基础的同学, 帮助其了解 Java 的基础语法, 以及面向对象的一些基本特性在 Java 中的实现方式. 阅读本文之前请先学习博客中的另一文章“面向对象起步 — 封装、继承、多态”, 以了解面向对象编程的基本概念. 本文将不再复述其中已提到的概念和术语. 本节关键词: 类、对象、包、属性、方法、重载、调试 类、对象 重载 关于Java相对于其它程序设计语言的优劣比较本文不再赘述, 事实上, 就设计语言而言并无优劣之分, 关键看其是否能满足项目需要. 本文中使用的开发工具涉及 JDK ( Java开发工具包) 和 IDE ( 集成开发环境, 教程中使用的是 Eclipse, 用其它 IDE 亦可. 若使用非 Eclipse 作为 IDE 则下文中针对 Eclipse 的操作步骤/界面会有差异, 但这不是重要, 必要时问一下度娘, 网上有大量介绍. ) . 本文不涉及如何安装 JDK, 如何搭建开发环境等内容, 若有必要, 请参阅其它资料. ​ 在正式开始学习之前先强调一下: 不同于一般的课本以知识点为主线进行阐述, 读者往往可以跳跃式地阅读. 本教程将以 “叙事” 的方式展开, 将相关知识点穿插其中. 教程中的 “故事情节” 环环相扣, 关联紧密. 因此, 在学习本教程时, 一定要跟着教程的叙述 (思路) 走, 教程中提到实验步骤一定要立刻动手操作, 当提到需要思考的地方一定要停下来思考和小结, 万不可囫囵吞枣, 泛泛而读. 否则, 越读到后面你将越迷惑. 就像看一部侦探片, 不可快进, 更不可”跃进”! 必要时甚至需要再回头重看. 切记! 切记! 阿门! ​ 类、对象在 Java 的世界里, 一切都是从创建类开始, 程序是无法独立存在于类之外的. 类和对象是面向对象理论里实现封装的重要手段. OK, 启动Eclipse, 我们来创建一个类…… 首次启动Eclipse的过程中会出现一个要求指定工作空间 ( workspace ) 的对话框, 指定一个保存项目文件的文件夹. 今后你的项目文件将被存储在该文件夹下,所以请记住它. 之后, 在Eclipse主界面左侧的 Package Explorer 视图中空白处点右键 → New → Java Project 新建一个 Java 项目 ( Java Project ), 如下图. 首次启动Eclipse可能会显示 Welcome 视图, 关闭它就可以看到 Package Explorer 视图 在此后出现的 “New Java Project” 对话框的 “Project Name” 输入框中填入项目名称 (随意), 此处我们填入 “JavaStudy”, 直接点击 Finish 按钮即可. 此时, Package Explorer 中即出现新建的项目. 逐层展开项目可看到Eclipse已经帮我们创建了一个名为src的源文件夹, 并引入了一些常用的 jar 文件 ( 这些文件被归入到了JRE System Library中 ), 如下图: src 源文件夹是用来存放我们写的程序. 默认引入的这些 jar 文件其实是别人已经写好了的一些程序, 经过打包之后形成一个个独立的 jar 文件. 这些 jar 是一般 Java 项目所需的, 暂时无须知道他们的用途…… 今后可能我们会使用到更多的第三方库 ( jar ), 也需要同样引入 ( 如何做? 暂时别管 ). ​ OK, 接着来…… 现在我们要在 JavaStudy 项目中新建我们的第一个类…… 在 src 图标上点击右键 → New → Class, 出现如下图所示的 “New Java Class” 对话框. 在 Package 处输入Package 的名称 ( 本文输入com.bailey.study.animal ) 在 Name 处输入类的名称 ( 本文输入Pig ) 点击 “Finish”…… 这样就创建了一个名为 Pig 的类 ( 猪类, 呵呵~). 疑问很多吧, 呵呵, 解释一下…… package : 称为”包“. 为了避免类名冲突 ( 不同的类名称相同 ), 通常需要为类指定它所在的包. 在其它的程序设计语言里也有类似的东西, 可能会被称为”命名空间 ( namespace )”. 习惯上包名一般以”公司域名倒序.项目名”开头. 在本例中, 指定了包名为 com.bailey.study.animal, 类名为Pig之后, 该类的完整名称其实是 com.bailey.study.animal.Pig, 这样就可以避免重名了…… 习惯上, 包名以小写字母开头, 以 “.” 分隔各个部分. 类名则以大驼峰法 ( Camel-Case )命名, 即首字母大写, 组成名称的各单词首字母大写, 其余字母小写(如: Pig, StudentInfo 参阅百度百科-骆驼命名法 ) ​ OK, 我们来看看Eclipse生成了些什么吧…… 可以看到, Package Explorer 中出现了新建的包和类, 而在右侧主视图中出现了 Pig.java 的源代码. ( 双击Package Explorer中的类名即可打开源码 ) ​ 相信你对那些花花绿绿的代码很好奇吧, 呵呵~ 简单解释一下(看注释)…… 123456789package com.bailey.study.animal; // 指定类所在的包/** * 定义\"猪类\". * \"public\" 是什么东东? 别管它, 等你长大了就知道了~ */public class Pig &#123;&#125; 看到绿色的注释了吧, 注释风格是不是和 C 语言很像? ​ 好… 继续…, 我们为 “猪类” 添加2个属性: name, weight ( 名字, 体重 ) 和 一个方法: eat ( 吃 ) , 代码如下 ( 注意看注释 ): 123456789101112package com.bailey.study.animal;public class Pig &#123; public String name; // 定义一个名为\"name\"的属性, 数据类型为 String (字符串) public String sex; // 性别 // 定义一个名为\"eat\"的方法, 接收一个 String 型(字符串)的参数food, 无返回值 public void eat(String food) &#123; // 若属性 name 的值为 \"小花\", 参数 food 值为 \"米饭\", 则输出 \"小花吃了米饭\" System.out.println(name + \"吃了\" + food); &#125;&#125; 嘿嘿, 就这么简单~ 别傻看了, 快去试试吧…… 上面的代码并非推荐的写法, 更好的写法在本文最后, 所以…… 请坚持看完本文! 好的, 到此为止我们定义了一个类 Pig, 那要怎么使用它呢? 注意, Pig 只是一个类 (猪类), 并非一头具体的猪, 它还吃不了东西, 就像我们不能说”猪类你去饭吧~”, 这样谁知道你叫谁呢…… 应该说”小花吃饭去吧~”, 也就是说, 我们得把猪类(类) 变成一头具体的猪(对象). 怎么变呢? 对了, 实例化! 代码大概是这样: Pig p = new Pig(); 但是, 这行代码写在那里呢? 总得有个调用方 ( 触发这段代码的地方 ) 吧…… ​ OK, 现在就来创建另外一个类, 作为程序的入口, 并把”小花”生出来…… 在 Package Explorer 视图中, src 图标上点右键 → New → Package, 在弹出对话框中的 Name 处输入com.bailey.study.test, 创建一个新的包. 然后…… 在com.bailey.study.test包的图标上点击右键 → New → Class, 创建一个新的类命名为”HelloJava“. 需要注意的是, 请选中 “New Java Class” 对话框中的 “public static void main(String[] args)” 复选框, 这样 Eclipse 会帮我们在新建的类中添加一个名称为 main 的方法, 这个方法将作为程序入口. 当然, 如果你使用别的 IDE, 暂时找不到上面所说的复选框也不要紧, 直接手动来写就行, 代码在下面… 然后…… 打开HelloJava类的源代码, 在里面添加一些代码, 最终完成的样子如下: 1234567891011package com.bailey.study.test;import com.bailey.study.animal.Pig; // 引入 Pig 类public class HelloJava &#123; public static void main(String[] args) &#123; Pig p = new Pig(); // 实例化, 将对象赋值给变量 p p.name = \"小花\"; // 将对象 p 的name属性赋值为字符串\"小花\" p.eat(\"米饭\"); // 调用对象 p 的 eat 方法, 让它吃米饭 &#125;&#125; 注意看一下上面的注释就能明白各行代码是什么意思了…… 其中, 有一些不知道含意的关键词, 例如: public, static, 暂时别管他, 以后我们再解释…… 对于上述代码中的第 3 行, 稍作解释…… 当要使用的类与当前类不在同一个包 ( package ) 时就必须使用 import 关键词引入该类 ( 例如本例中的 Pig 类 ). 否则… Java就不知道 Pig 从哪里来的! 把第 3 行删了试试… 呵呵~ 这有点像其它程序设计语言中的 include / using … 为了省事, 可以使用Eclipse快捷键 Ctrl + Shift + O, 试试~ ​ 好了, 现在入口函数也有了, 怎么让程序运行起来呢? 在 Package Explorer 视图中找到 HelloJava 类点右键 → Run As → Java Application 看到了吗? 在 Eclipse 窗口的中的 Console 视图出现了 “小花吃了米饭”, 呵呵, 这就运行起来了~ 如下图: Console 意为控制台, 这个视图中将显示程序的输出内容…… ​ 也可以在 HelloJava 类的图标上点右键 → Debug As → Java Application, 这样会以”调试模式“ 启动程序 ( 前面的叫”运行模式“ ). 在调试模式下, 程序运行到我们设置的”断点“就会暂停, 此时可以观察当前各个变量的当前值, 以便对程序进行排错. 而在运行模式下, 程序执行是会忽略所有的断点. 如何设置”断点”? 在想要设置 “断点” 的代码前双击即可, 之后, 会在断点所在的行前面出现一个蓝色的圆点, 如下图: 快以调试方式运行一次试试呀…… 以后遇到程序报错就别老傻坐着看了, 设个断点调试一下吧! 学会调试程序是一个程序员必备的重要技能! ​ 好了, 在继续往下看之前先暂停 3 分钟…… 整理一下思路, 想想我们刚才都做了些什么? 它们之间的关系是如何的? 过程大概是这样: 创建类 → 实例化 → 调用对象的方法 重载前面的例子中, 我们只为Pig类定义一种”吃法”: eat(String food), 无论这食物是凉的或是烫的, 这猪都一口就吃下去了. 但事实上, 如果食物是比较烫, 恐怕得凉一会, 呵呵~ 于是, 我想再多传一个参数给 eat 方法, 告诉它食物是否是烫的…… 程序该如何修改呢? 也许, 你想到的办法是修改原先的 eat 方法, 为它添加一个参数: isHot. 但其实没必要修改原先已有的那个 eat 方法, 只要为 Pig 类再增加一个同名的 eat 方法就好了. ( 原先的 eat 方法可认为是一种默认吃法, 我不想改它, 呵呵~) 如果你已经读完了“面向对象起步 — 封装、继承、多态”, 那你应该明白, 这就是传说中的”重载 (Overload)“了, 如果还没有读… 那建议先停一下, 去看看吧! ​ OK, 看代码…… 1234567891011public void eat(String food) &#123; System.out.println(name + \"吃了\" + food);&#125;public void eat(String food, boolean isHot) &#123; if (isHot) &#123; System.out.println(\"等呀等... 终于凉了...\"); &#125; eat(food); // 这里调用了第 1 行定义的那个eat方法&#125; 没什么好说的…… 关注一下第 10 行的注释, Maybe 你悟到了点什么…… 是的, Java会根据传入的参数, 自动选择一个最合适的方法去调用…… 说到这里, 去把 HelloJava.java 中的 p.eat(&quot;米饭&quot;); 改为 p.eat(&quot;米饭&quot;, true); 试试… 关于重载的一些概念和原则, 还是请阅读一下本博客中的另一篇文章“面向对象起步 — 封装、继承、多态”, 此处不再赘述…… ​ 好了, 本节内容就是这些…… 也许看完了之后你会发现有各种各样的规则 ( 要求 ), 别忙着死记, 放轻松~ 事实上, Eclipse 是很聪明的, 当你犯错时它会划红线提醒你的, 到时候再看看提示, 改一改就好了. 写了一些程序之后, 慢慢地就不会犯错了…… ​ 为了让你看上去像一个老Java程序猿, 一些约定俗成的东西应该遵循, 一些技巧可以了解: (1) 定义类/属性/方法时记得为它们加上访问修饰符 (2) 包名首字母小写 (3) 类名采用首字母大写的驼峰命名规则(大Camel-Case) (4) 属性名, 方法名采用首字母小写的驼峰命名规则(小Camel-Case) (5) 输入代码的过程中, 使用Eclipse快捷键 Alt + / 可调出输入提示 (6) 在代码视图中点右键 → Source → Generate Getters and Setters … 可快速地生成 getter, setter方法. (7) 程序出现异常时, 善用调试模式(Debug) 进行排错, 别动不动就怀疑是不是电脑出问题了, 或者张嘴就问. 一步步跟踪代码的执行过程, 发现问题, 思考原因, 最终解决问题是一个难得的学习机会.","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://baileykm.github.io/tags/Java/"}]},{"title":"面向对象起步 --- 封装、继承、多态","slug":"面向对象起步-封装-继承-多态","date":"2014-02-20T19:14:44.000Z","updated":"2019-05-10T20:27:02.925Z","comments":true,"path":"2014/02/21/面向对象起步-封装-继承-多态/","link":"","permalink":"https://baileykm.github.io/2014/02/21/面向对象起步-封装-继承-多态/","excerpt":"面向对象编程 ( OOP, Object Oriented Programming ) 对于一个现代的程序猿而言, 几乎是一个无法避开的话题. 无论你是想从 C++, C#, 还是 Java 开始你的学习旅程, 面向对象的一些基本的概念, 或者说是理念, 应该事先有所了解, 否则可能很快就会掉入某种编程语言的语法泥潭里, 或者陷入”不识庐山真面目, 只缘身在此山中” 的窘境. 这就如同我们要去某个地方, 首先应当明确的是目的地的方向, 再去规划具体的行进路线. 撰写本文的主要目的是为了让准备开始学习 Java 的同学先对面向对象的基本概念和理念有一个初步认识.","text":"面向对象编程 ( OOP, Object Oriented Programming ) 对于一个现代的程序猿而言, 几乎是一个无法避开的话题. 无论你是想从 C++, C#, 还是 Java 开始你的学习旅程, 面向对象的一些基本的概念, 或者说是理念, 应该事先有所了解, 否则可能很快就会掉入某种编程语言的语法泥潭里, 或者陷入”不识庐山真面目, 只缘身在此山中” 的窘境. 这就如同我们要去某个地方, 首先应当明确的是目的地的方向, 再去规划具体的行进路线. 撰写本文的主要目的是为了让准备开始学习 Java 的同学先对面向对象的基本概念和理念有一个初步认识. 封装 继承 多态 下面的阐述可能有一定局限性 (针对性), 也可能并不完备和严谨, 只是帮助大家理解和学习 Java, 严格的定义请参阅其它资料. 但在总体的方向上, 对于面向对象程序设计而言还是普适的. 文中使用到了 C 和 Java 做简单例子, 如果没学习过也不要紧, 当做没看见就行了. ​ 在面向对象编程的世界里, 封装、继承和多态被称为面向对象的三个重要特征. 当然, 有些资料上也把 “抽象”归入到了面向对象特征之一. ​ 关于 “抽象” 本文不再多言. 用几句话帮助理解: 抽象就是把客观世界的东西转化成计算机世界的数据模型. 例如: 把现实世界的一个人, 表示成计算机世界中的一个数据. 抽象的目的是”化繁为简”, 手段则是”特征提取”. 继续刚才的例子, 对于一个人而言, 关于他的信息不胜枚举, 比如: 姓名, 年龄, 性别, 身高, 体重, 家庭住址, 家庭成员, 个人爱好…… 但如果我们开发一个员工考勤系统, 显然诸如身高, 体重, 家庭成员…… 这些信息是无用的, 因此, 我们就会把那些无关的信息精简掉, 提取出我们关心的特征, 这就是抽象. 试想一下, 其实生活中很多时候都是做在抽象, 比如: 体检表就是对身体状况的抽象. ​ 好了, 来看我们今天的主角…… 我们通过一些例子和浅显的描述来理解一下 “封装、继承、多态”. ​ 封装 什么是封装? 封装就是把一些数据和功能打包成一个独立的单元. 也许 C 语言是你学习的第一种编程语言, 那就回想一下…… 为了存储一组相同类型的数据, 我们可能把它们组合成一个数组, 以便处理. 更高级一些, 我们可能把关于某个学生的信息组合成一个结构体变量. 这就是对数据的封装. 另一方面, 我们可能把诸如求三角形面积的功能写作一个函数, 这就是对功能的封装. 针对任何一个东西 ( 对象, Object ) 的描述均可以拆分成 2 个部分: 数据 和 功能. 封装即是把数据和功能封装成一个独立单元. ​ 为什么要封装?显然, 封装可以让数据和功能变得更为”整洁”, 并富有条理. 看一下墙上的电源开关, 对于使用者我们只须将 “开/关” 功能暴露给他, 而无须向其展示内部的实现. 再想一下组成计算机的各个部件…… 我们把显示功能封装在了显示器里, 而把数据存储功能封装在了硬盘里. 对于使用者而言, 封装可以让使用变得简单; 对于制造者而言, 封装可以让设计/制造变得更简单和专注, 更重要的一点, 封装有效地避免了使用者肆意地操纵(破坏)封装体的内部结构. ​ 封装的目标?上升到软件工程的层次, 封装需要实现软件工程中一个重要原则 “高内聚, 低耦合“. 简单来说: 把相对独立的功能和数据封装成一个单元, 这个单元的功能要尽可能地”单一”, 单元内部的数据和功能之间关系尽可能地”紧密” —- 高内聚; 另一方面, 不同的单元之间的联系要尽可能地”松散”, 当然, 更不能直接对对方的内部结构进行操纵 —- 低耦合. 应该注意的是, 封装是有层次的. 比如: 宏观上说, 我们把数据存储的功能封装在了硬盘里, 但对于硬盘而言可以进行更细层次的封装: 把供电的功能封装在了供电部件里, 把控制磁头移动的功能封装在磁头控制部件里……, 当然如果你愿意, 可以继续细分…… 总之, 站在不同的角度, 封装的”粒度”是不同的. 但无论如何, 封装体内部功能和数据应是”内聚”的, 而从外部来看, 封装体应是”独立”的, 或说是”整洁”的, 对它的操纵应只能通过其对外提供的”接口”来实现. ​ 如何实现封装?说了这么多, 那封装具体如何在编程过程中实现呢? 在刚才讲 “什么是封装” 的时候, 曾经举过 C 语言中的例子, 忘记了? 呵呵, 回去看一下吧~ 这里我们换一种说法: 使用 C 语言编程时, 我们把”数据”封装成了变量/数组/结构体……或者其它的数据结构, 而把”功能”封装成了”函数 ( function )”. 所以, 对于使用C语言编程而言”高内聚, 低耦合”的原则同样适用. 对于 C 语言这样的编程语言, 编程的主要工作就是在定义不同的函数, 然后使用 (调用) 它. 所以, 我们把C语言叫做面向过程的程序设计语言. …… 为什么不叫面向函数呢? 呵呵, 事实上”过程”和”函数”在定义上只有细微的差别, 对于象 C 语言这样只有”函数”的程序设计语言来说, 可以把函数等同于过程. 如果你想知道过程和函数的不同点, 请问度娘…… 当然, 如果你之前学习过诸如 Pascal, Basic 这样的程序设计语言, 那…… 你懂的, 呵呵~ 有人可能已经在咆哮了, 本文不是叫”面向对象起步”吗? 怎么老扯C语言…… 用C语言举例主要是因为我们很多同学学习程序设计是从C语言起步的, 如果没学习过C语言或者完全忘记了…… 那装作没看到”C语言”这三个字就行了, 呵呵~ 应该能看懂! ​ 呵呵, 别急, 面向对象不是从石头里蹦出来的, 它也是从面向过程发展而来的…… 所以, 还从C语言说起…… ​ 在C语言中, 我们使用 “结构体类型” 可谓是把数据进行了高层次的封装, 而用 “函数” 对功能进行了封装, 这两种形式的封装是相互独立的…… 而现实中, 数据和功能往往是一个有机的整体. 例如: 一个学生, 他的姓名, 性别, 年龄…… 这些是数据, 而学生也拥有吃饭, 睡觉, 打游戏这样的一些功能, 这些数据和功能其实都是学生这个整体的成员. 但是…… 在C语言中, 我们就只能通过结构体变量来存储这个学生的数据, 而定义一些函数来表达他的功能, 这两者之间在形式上是独立的, 而在关系上却又是联系紧密的. ​ 那么…… 能不能把数据和功能都封装成一个整体单元里呢? 呵呵, 说到点子上了…… 这就是传说中的“对象 (Object)” ​ 当你成为一名使用面向对象程序设计语言编程的程序猿之后, 就会发现, 每天的工作就是在定义”对象”, 并使用它. 所以叫面向对象编程(OOP) 嘛, 呵呵~ 这里需要注意的是, 使用对象之前, 我们要先定义 (描述) 这个对象应该长成什么样子. 通俗来说就是描述对象应该有些什么数据 ( OOP里叫属性 ) 和 功能 ( 函数, OOP里叫方法 ), 然后…… 再把它转化成一个具体的对象去使用. 这里, 在术语中, 前者叫做”类“, 后者叫”对象“, 转化过程叫”实例化“. 所以, 类和对象之间的关系其实是 “型” 与 “值” 的关系. 例如: 我们要先定义好整型是什么样子的, 然后才能声明一个具体的整型变量. 当然, 这个例子不一定恰当, 在几乎所有编程语言里整型这样的数据类型是无须程序员定义的, 但…… 总得有人定义吧…… 如果你已经开始学习Java, 那看下面的这段代码就明白了…… 1Integer x = new Integer(); // Integer是类(型), x是对象(值), 通过关键字new来实例化 对于普适的面向对象程序设计而言, 封装的典型形式就是把现实世界抽象的结果描述为对象, 当然也可能涉及到别的层面. ​ 继承 先来看一个有趣的例子…… 假如你发现门外有个如下图所示的东东, 你很兴奋地想要告诉正在赖床的室友, 下面是你们的对话: 你: 门外有一条黑狗! 猪头室友: 什么是黑狗? 你: …… 门外有一条皮毛是黑色的狗 ! 猪头室友: 什么是狗? 你: 门外有一只哺乳动物, 4 条腿, 一条尾巴, 喜欢啃骨头, …… 并且它的毛是黑色的 ! 猪头室友: 什么是哺乳动物? 你: &amp;#$!$%@ 猪头室友: 什么是动物呢? 你: 神啊, 宽恕这个无知的人吧, 阿门 ! ​ 咿呀, 要命了…… 要真有这样的室友, 那…… 搬了吧…… 这个故事虽然狗血, 但它告诉我们一个道理, 我们在提到 “黑狗” 的时候是建立在对方已经知道什么是 “狗” 的前提下的. 同样, 当我们提到 “狗” 的时候也是建立在对方已经知道什么是”哺乳动物”的前提下. 如若对方真是一个 “一无所知” 的人, 那还真得以最啰嗦的方式去描述. 但不幸的是, 计算机刚好是那个最无知的 “人”…… OK, 假如再来一头猪, 你形容一下吧, “猪是一种动物, @#$*!#$%……”, 呵呵~ ​ 从这个例子我们至少可以看到下面几点: (1) 一些事物之间是有层次关系的, 例如: 动物 → 哺乳动物 → 狗 → 黑狗; 动物 → 哺乳动物 → 猪. 如果我们把这个层次竖起来, 那从上到下是逐层递进 具体化 和 扩张 的过程 (2) 如果先把 “上层” 的东西描述清楚, 再来描述 “下层” , 那对于 “下层” 的描述将会变得很简洁, 例如: 当已经描述清楚什么是 “狗” 之后, 那 “黑色的狗” 4个字就可以说清楚什么是 “黑狗” 了. (3) 更关键的是, 如果我们按(2)中所说的方式去描述, 那当不同的 “层次序列” 有共同的 “上层” 时, 我们可以省很多事. 例如: 假设对动物, 哺乳动物, 狗, 黑狗均有了清晰的定义, 那要定义”猪”的时候就只需要在”哺乳动物”的基础上进一步说明就行了. ​ 呵呵, 这其实是一个很自然的过程, 我们的认识过程也是如此的…… ​ 下面我们来定义一些术语: (1) “动物”, “哺乳动物”, “狗” …… 这些东西称为 类. ( 注意, 不是对象! 具体的狗, “旺财”才称作”对象” ) (2) 从 “动物” 到 “哺乳动物” 的过程, 称为 继承, 相应地, 狗 → 黑狗也是继承, 其它类似…… (3) 在 “动物 → 哺乳动物” 这个继承关系中, 把”动物类”称作”哺乳动物类”的 父类(基类), 而 “哺乳动物类” 称作 “动物类” 的 子类(派生类) (4) 子类会自然地拥有父类的所有属性和方法, 但应记住, 继承是扩张的过程, 不能收缩. 也就是说, 父类有的, 子类一定有. ​ 大概明白什么是继承了吧…… 从写程序的角度, 继承可以实现高效、合理的 “代码复用“, 更重要的是, 它更有利于我们进行整体架构. 对于代码复用, 我想通过前面的例子已经可以体会到了. 简单来说, 就是不用老是做重复劳动. 回想一下, 你写程序的过程是不是有很多 “复制 → 粘贴 → 改一改” 的动作, 当有一天你发现最初的 “原版” 有问题, 需要修改, 而你已经复制/粘贴了N个地方, 那怕就疯了吧, 呵呵…… 那为什么不把共有的东西定义在父类中, 通过继承机制来复用呢? 当然, 把经常使用的功能定义在一个函数里, 也是代码复用, 只是我们现在在讲继承, 就不扯别的了…… 从整体架构的角度来说, 继承机制更符合我们的认识过程, 从简单到复杂, 从抽象到具体. 站在祖先的视角来看, 它规定了其子孙后代的发展方向, 呵呵~ ​ 多态 继续刚才的例子, 假如我们定义了 “动物类”, 并通过继承机制进而定义了 “狗类”. 所有动物都会吃东西吧, 呵呵, 于是我们在 “动物类” 中定义了 “吃”这个方法, 函数原型大概是这样的: void eat(String food, double weight) 然后…… 通过继承机制, 狗类也就自然地拥有了”吃” 这个方法 (函数). ​ 好了, 现在问题来了, 很有可能我们在动物类中定义的 “吃法” 只是一种普适的方法. 而狗能吃骨头, 如果 food 是骨头的时候, 它的吃法要有个性些. 也就是说, 在狗这个子类中, 需要对动物这个父类中的”吃”这个方法进行重新定义. 这行不行呢? 当然可以! 这叫”覆盖“ ​ OK, 相对书面化一点说, 覆盖(Override) 就是子类中重新定义了从父类中继承而来的方法. 要注意的是, 子类中定义的这个方法的原型必须与父类中的方法原型完全一致, 也就是说, 方法名和参数表都相同 (方法名后面括号中的参数个数和类型都必须一致), 否则不可称作覆盖. 那…… 如果只是方法名和参数表相同, 返回值不同, 这样能不能叫覆盖呢? 呵呵, 这叫”出错”! 哈哈, 语法上根本不允许…… 通常情况下, 使用 Java 编程时, 会在子类中有 “覆盖” 情形的方法前面写上 @Override 这个注解. 在C++中除了覆盖之外, 还有一个概念很相似, 叫 “重写(Overwrite)”, 它与覆盖(Override) 是有区别的, 但因为本文以 Java 为例, 并不存在重写的情况, 因此就不再赘述了, 感兴趣的问度娘…… ​ 说完了覆盖, 我们来看另一种情况: 假设在”动物”这个类中定义了一个 “喝水” 的方法, 原型是这样的: void drink(double weight) 现在我们还想继续定义另一个 “喝水” 的方法, 但多一个参数表示这水是热的, 还是凉的. 也许你会想, 那我们另外定义一个不同名字的方法不就行了嘛…… 呵呵, 或许我们就喜欢 “drink” 这个名字呢? 其实, 我们可以定义另外一个方法, 原型如下: void drink(double weight, boolean isHot) 也就是说, 我们在同一个类中定义了两个同名的方法, 但它们的参数表是可区分的, 这叫做 “重载(Overload)“ 这里解释一下什么叫”参数表是可区分的”, 为什么不说”参数表不同”呢?一般而言, 我们说 “参数表不同” 表达的是 “参数个数不同 或 参数类型不同, 或者两者均不同”. 但注意以下的情形: (1) void doSomeThing (Number param) (2) void doSomeThing (Integer param) (3) void doSomeThing (Double param) (4) void doSomeThing (int param)按上述的说法这 4 个方法显然是”参数表不同”的 但 (1) 与 (2) 是不能同时出现在一个类的定义里面的, 因为 Number类是 Integer的祖先类, 当我们以 doSomeThing(3) 的形式来调用doSomeThing方法的时候, 计算机不知道该调用(1) 还是(2). 同样的, (1) 与 (3) 也不能同时出现在一个类中. 但是, (2) 和 (3) 是可以的……那 (2) 和 (4) 可不可以在同一个类中出现呢? — 不行! 术语里, 把 Integer 称作 int 的”装箱类”. 如果它们同时出现在同一个类中, 调用时也是有歧意的.因此, 这里我们使用 “可区分” 这个词…… ​ 那么…… 同一个类中定义两个原型完全相同的方法(类似覆盖), 这样行不行呢? — NO!!! 语法错误! 那么…… 同一个类中定义两个名称相同, 参数表相同, 只是返回值不同的方法, 行不行? — NO!!! 那么…… 同一个类中定义两个名称不同, 其它都相同的方法行不行? — YES! 当然可以, 只是这就是两个普通方法定义了, 它们之间不构成重载关系. ​ 好了, 最后对比一下覆盖(Override) 和 重载(Overload): (1) 覆盖是发生成父类与子类之间的, 而重载是发生成同一个类的内部的. (2) 构成覆盖关系的函数要求名称相同, 参数表相同, 返回值也相同; 重载则要求名称相同, 返回值相同, 但参数表是可区分的. ​ STOP !!! 不是要讲什么是多态吗? 怎么扯半天的覆盖和重载? 呵呵, 其实覆盖与重载就是面向对象中多态性的两种表现形式. 当然, 多态性在不同的语言里可能还有更多的表现. 但对于 Java 而言, 覆盖与重载可算是最典型的形式, 对于 Java 初学者而言我想已经够了…… ​ 现在不用再解释什么是多态了吧, 呵呵, 自己领悟吧~ 一个不太严谨的说法是, 所谓”多态”, 就是同一个东东, 在收到不同的输入时, 有不同的行为 ( 同名多状态 ). 相当不严谨, 只是帮助理解, 勿喷~ 其实严格的定义很拗口, 也不容易理解, 这里就不再转载了…… 很多网上的文章或帖子, 对于多态的定义并不正确, 甚至有误导的嫌疑! 建议看点权威的资料~ ​ 好了, 到这里吧, 就到这里吧, 希望对学习面向对象程序设计有所帮助……","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://baileykm.github.io/tags/OOP/"}]},{"title":"jQuery 入门精要","slug":"jQuery 入门精要","date":"2013-05-01T15:00:00.000Z","updated":"2019-05-16T06:51:58.753Z","comments":true,"path":"2013/05/01/jQuery 入门精要/","link":"","permalink":"https://baileykm.github.io/2013/05/01/jQuery 入门精要/","excerpt":"jQuery 是一个轻量级的 javascript 库, 目前 ( 2019 年 5 月 ) 发布的最新版本为 3.4.1. 它在前端开发中应用广泛, 可以这样说, 有 jQuery 的助力, 你的前端开发将如虎添翼. 本文力争以最简练的语言讲述关于 jQuery 的基本用法, 以帮助初学者快速入门。","text":"jQuery 是一个轻量级的 javascript 库, 目前 ( 2019 年 5 月 ) 发布的最新版本为 3.4.1. 它在前端开发中应用广泛, 可以这样说, 有 jQuery 的助力, 你的前端开发将如虎添翼. 本文力争以最简练的语言讲述关于 jQuery 的基本用法, 以帮助初学者快速入门。 jQuery 能做什么? 起步（ 引入 jQuery ） 解读 $(document).ready(function(){ … }); jQuery 的工厂函数: $() 事件注册：为元素注册事件处理函数 改变元素的显示效果 DOM 操作 AJAX 笔者假设你已经掌握了HTML，CSS， Javascript 的基本语法，并有一定的实践。若上述假设不成立，那可能需要找点别的资料补补课了: ) ​ OK, 废话少说, 我们开始吧… ​ jQuery 能做什么?先了解一下 jQuery 大概可以做些什么事情. 粗略汇总一下, jQuery 可以完成如下任务: 1) 取得文档中的元素 2) 修改页面的外观 3) 改变文档的内容 4) 响应用户的交互操作 5) 为页面添加动态效果 6) 无需刷新页面从服务器获得信息 7) 简化常见的JavaScript任务 ​ 起步（ 引入 jQuery ）下载 jQuery 库, 可到官网下载 , 其中有 2 个版本: 压缩版 ( compressed, jquery-xxx.js ) 和 未压缩版 ( uncompressed, jquery-xxx.min.js ) 一般在开发环境使用未压缩版, 以便于调试, 生产环境使用压缩版, 以提高页面加载速度. ​ 在HTML文档的&lt;head&gt;&lt;/head&gt;中写入如下代码, 即可引入 jQuery. &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-xxx.js&quot;&gt;&lt;/script&gt; 上述描述中, xxx 为版本号, 视你下载的 jQuery 版本而定. &lt;script&gt;&lt;/script&gt;中的src属性指向 jQuery 文件的相对路径, 根据实际情况作适当修改. ​ 解读 $(document).ready(function(){ … });使用过 javascript 操纵网页中元素的同学都应该知道, 在对此元素进行操纵之前, 首先应确保此元素的 DOM 已经构建完成, 否则对该元素的操作将抛出异常 (空指针). jQuery 为我们提供了一个很好的机制 (时间点), 可在 DOM 就绪后立即执行指定的代码, 而不必等待图片或其它资源完全加载完成. 这将在一定程度上改善用户体验. 例如如下的代码可在页面的 DOM 构建完成后第一时间弹出一个显示 “Hello world!” 的警告框. 123$(document).ready(function() &#123; alert('Hello world!');&#125;; ​ jQuery 的工厂函数: $()在 jQuery 中有一个名字非常特别的函数 $() ( 有时为避免名称冲突, 也可写作 jQuery() ), 此函数称作 jQuery 的工厂函数. 为什么把函数$()称作 “工厂函数” ? 这词来自设计模式中的工厂模式. 建议抽空学习一下 设计模式 ( Disign Pattern ) 使用工厂函数$()可完成如下 3 方面的工作: 1. 找到网页中符合指定规则元素, 并将其封装为 jQuery 对象 ( jQuery 对象较普通的 DOM 拥有更多属性和方法 )通常，在我们操纵网页上的元素之前首先要获得该元素的引用，常规的做法一般使用document.getElementById()获得元素后进行操作. jQuery 为我们提供了更简捷, 但更强大的方式。 Example: 12$('p').text('Hello world'); // 把所有段落的内容替换为 \"Hello world\"$('p.ca').text('Hello world'); // 把所有类似 &lt;p class=\"ca\"&gt;...&lt;/p&gt; 的段落内容替换为 \"Hello world\" 我们可以在$()函数的参数位置使用CSS选择符形式的字符串来说明欲寻找的元素应符合的条件. jQuery 支持所有的 CSS选择符 语法. text() 方法的用法将在下文中介绍. 也许你已经注意到了，jQuery 的 $() 函数不止选出了所有符合选择条件元素，更把这些元素进行了封装（本文称其为 jQuery 对象），从而增加了更多有用的方法（如上面的 text() 方法） 同时，jQuery 还会将找到的元素封装成一个集合，后续的操作均是针对集合中的每一个元素进行的，例如：对 $(&#39;p&#39;) 的操作将被应用到所有的段落. 2. 将普通的 DOM 对象封装为 jQuery 对象Example: 123document.getElementById(\"p1\").onclick = function()&#123; $(this).text(\"Hello world\");&#125; 上例中, 我们为 ID 为 “p1” 的那个元素注册了 onclick事件回调函数. 在函数内部, this指向了被点击的那个 元素, 通过 jQuery 工厂函数的封装, $(this)变成了 jQuery 对象, 从而拥有了 text() 方法. ( 若写成this.text(&quot;Hello world&quot;); 是会报错的~ ) 3. 动态创建网页元素Example: 123var p = $(\"p\"); // 动态创建一个段落元素(&lt;p&gt;)p.text(\"Hello world\"); p.appendTo($(\"body\")); // 将新创建的段落元素添加到 &lt;body&gt;&lt;/body&gt; 内部, appendTo()方法的用法见下文 ​ 事件注册：为元素注册事件处理函数使用工厂函数 $() 找到要操纵的元素后，我们可能想为该元素添加事件处理函数。例如：为页面中所有的段落注册onclick事件处理函数，当用户点击了段落时，弹出消息框，可使用如下的代码： 123$('p').bind('click', function()&#123; alert('Hello world'); &#125;); jQuery还为常用的事件注册提供了简写形式，如上面的代码可以简写为： 123$('p').click(function()&#123; alert('Hello world'); &#125;); jQuery 中支持简写的事件包括： blur, change, click, dblclick, error, focus, keydown, keypress, keyup, load, mousedown, mousemove, mouseout, mouseover, mouseup, resize, scroll, select, submit, unload ​ 复合事件(函数)有时候我们可能希望同时捕获鼠标移动到某个元素上方和移开两个事件, 分别进行处理… 例如: 用于实现下拉菜单的显示和隐藏 jQuery 的复合事件正好提供了此项功能，例如: 123456// 鼠标移到 &lt;p&gt; 上方时弹出\"mouse over\", 移开则弹出\"mouse out\"$('p').hover(function()&#123; alert('mouse over');&#125;, function()&#123; alert('mouse out');&#125;); 下面是3个常用的复合事件(函数)： 1) .hover(function(){…}, function(){…}); 鼠标指针进入时执行函数1，离开时执行函数2 2) .toggle(speed, function(){…}); 若元素可见则隐藏之, 否则令其可见. speed 为显示/隐藏动画的速度, function 为动作完成后的回调函数 这个函数在新旧版本中的作用有差异, 在 jQuery 1.11.1 版本测试是上述效果. 在早期版本中语法为 .toggle(function(){…}, function(){…}), 表示奇数次点击时执行第 1 个函数, 第偶数次点击时执行第 2 个函数 3) .toggleClass( cssClassName ); 检查元素是否存在指定名称的CSS类，不存在则添加，存在则移除 ​ 改变元素的显示效果本部分将讨论改变页面上元素的显示效果。本文将效果分为2类：（1）操纵CSS；（2）元素的显示与隐藏 操纵 CSSCSS 的主要功能即时控制元素的外观，若我们可以操纵CSS不就可以控制元素的外观了吗 ? 下面是控制 CSS 的 常用 jQuery 函数: .css(&#39;property&#39;, &#39;value&#39;); // 设置CSS的某个属性值 .css({&#39;property1&#39; : &#39;value1&#39;, &#39;property2&#39; : &#39;value2&#39;); // 设置CSS的某些属性值 .addClass( &#39;CssClassName&#39; ); // 添加一个CSS类 .removeClass( &#39;CssClassName&#39; ); // 移除一个CSS类 Example: 123456789101112131415161718192021// 所有段落文字变为红色$('p').css('color', 'red'); // 所有段落文字变为红色，加粗$('p').css(&#123; 'color': 'red', 'font-weight' : 'bold'&#125;);// 假设页面中定义了1个CSS类：.red &#123; color : red; &#125; // 所有段落文字变为红色$('p').addClass('red'); // 鼠标处于段落之上时文字变红，离开则恢复原来的颜色// 注意代码中红色的 this 指代当前的段落$('p').toggle(function()&#123; $(this).addClass('red'); &#125;, function()&#123; $(this).removeClass('red'); &#125;); ​ 显示和隐藏元素Example: 123456789101112$('p').hide(); // 把所有段落隐藏$('p').show(); // 把所有段落显示出来// 把所有段落隐藏（慢慢地）// slow (0.6 秒完成）, normal(0.4 秒完成）,fast(0.2 秒完成）,也可使用毫秒数值 $('p').hide('slow');// 把所有段落显示出来（ 3秒钟完成 ）$('p').show(3000);$('p').fadeOut(1000); // 淡出$('p').fadeIn(1000); // 淡入 快去试试吧, 别傻看了… ​ DOM 操作下面来看 jQuery 提供的针对 DOM 操作的函数： 1) .attr(&#39;property&#39;, &#39;value&#39;) // 设置属性值 2) .removeAttr(&#39;property&#39;) // 删除属性 3) .append() .appendTo() .prepend() .prependTo() // 在元素中插入新元素 4) .after() .insertAfter() .before() .insertBefore()// 在元素相邻位置插入新元素 5) .wrap() .wrapAll() .wrapInner() // 在元素外插入新元素 6) .html() .text() .replaceAll() .replaceWith() // 用新元素或文本替换 7) .empty() // 移除元素中的子元素 8) .remove() // 移除元素及其后代元素，但不实际删除它们 写到这里，原想着不用举例了，但又怕各位看官囫囵吞枣，还是简单举2个例子: Example: 1234567891011// 页面里所有超链接一起指向 CCTV$('a').attr('href', 'http://www.cctv.com');// 在所有超链接原文字的后面加上“GOOD”。// 好好琢磨一下这一句，是不是又学会了点什么?$('&lt;span&gt;GOOD&lt;/span&gt;').appendTo($('a'));// 清除段落的子元素$('p').empty();// 其他的, 自己试试吧... ​ AJAXAJAX ( Asynchronous JavaScript and XML, 异步 JavaScript 和 XML )是一种客户端与服务器端进行异步通讯的技术，要是不知道是什么东东，下面这段就不用看了，先找点别的资料看看… 1) .load(&#39;url&#39;) // 加载 url 指向的内容，作为元素的子元素 2) $.getJSON ( &#39;url&#39;, function(data){…} ) // 向URL指定的地址请求JSON格式的数据 3) $.getScript(&#39;url&#39;) // 向URL指定的地址请求 javascript 脚本，并执行 4) 更为常见的 Ajax 请求方法 1234567891011$.ajax(&#123; type : \"post\", // method (post/get) url : \"...\", // 请求数据的地址 dataType : 'json', // 数据格式(json, xml, text …) data : &#123;...&#125;, // 向服务器端发送的数据 beforeSend : function(xhr) &#123;&#125;, // 请求前的回调函数 success : function(result,status,xhr)&#123;&#125;, // 请求成功的回调函数 error : function(xhr,status,error) &#123;&#125;, // 出错时的回调函数 complete : function(xhr,status) &#123;&#125; // 请求完成时的回调函数&#125;); 因为要配合服务器端技术，不太好演示，所以就简单举个例吧. 例：假设页面中有一个div, id=”contener”, 如： &lt;div id=&quot;contener&quot;&gt;&lt;/div&gt; 以下代码可以把 a.html 页面嵌入到该DIV中 $(&#39;#contener&#39;).load(&#39;a.html&#39;); ​ 好了，本文既然名为 “jQuery入门精要”, 那就到此为止吧。 当然，jQuery 还提供了更多的功能和机制, 希望各位阅读了本文后能初窥门径, 那也算我没有白白折腾了！ 若文中所述有失偏颇，敬请指正！","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"},{"name":"jQuery","slug":"jQuery","permalink":"https://baileykm.github.io/tags/jQuery/"}]},{"title":"我给媳妇解释设计模式-第 (1) 部分 [转载]","slug":"我给媳妇解释设计模式-1","date":"2013-03-25T17:47:22.000Z","updated":"2019-05-10T20:28:11.754Z","comments":true,"path":"2013/03/26/我给媳妇解释设计模式-1/","link":"","permalink":"https://baileykm.github.io/2013/03/26/我给媳妇解释设计模式-1/","excerpt":"“设计模式” 是程序员 “飞升上仙” 的必修课, 本文用生动有趣的故事阐述了关于 “设计模式” 的一些基础知识.","text":"“设计模式” 是程序员 “飞升上仙” 的必修课, 本文用生动有趣的故事阐述了关于 “设计模式” 的一些基础知识. 引子我跟媳妇曾经就面向对象设计这个话题做过有趣的探讨。当我把它们发表在社区之后，得到了一些很不错的反馈，也大大鼓舞了我。所以，我很高兴能把我们后面的一次谈话继续分享出来，那是关于面向对象的设计模式的，大家往下看吧。 ​ 什么是设计模式丈夫: 我想你现在对面向对象的设计原则有了一些基本概念了吧。我们那次关于OOD (面向对象设计) 原则（SOLID原则）的有趣谈话被我发表在社区上了，你不会介意吧？网址在这里: 我怎么向妻子解释OOD。 设计模式则是这些原则在某些特定和常用条件下的应用，并且做了一些标准化。我们还是来一些例子吧。 媳妇: 好极了，我喜欢例子。 丈夫: 以我们的车为例吧。它是一个对象，不过有点复杂，是由几千个其它对象组成的，包括引擎、车轮、转向装置、座位、车身，等等。 一辆车的各种零件。这辆车在制造的时候，制造商收集所有的零件，把它们组装起来。这些零件本身也是复杂的对象，是由其它的制造商组装的。但汽车公司并不关心这些零件是怎么造出来的（当然，他们需要确信这些零件的质量是过硬的）。他们只会关心如何通过不同的方式将不同的零件组装起来，以便生产出不同型号的汽车。 由不同零件根据不同设计组装成的不同型号的车。 媳妇: 每种型号的汽车应该都有各自的设计和蓝图什么的，是吧？ 丈夫: 非常正确。而且，这些设计是经过深思熟虑的，花了很长的时间和很大的努力才得以诞生。完成设计之后，汽车的生产就只剩下遵循设计这么简单的事了。 媳妇: 嗯……很不错的办法，先想出一些优秀的设计，然后遵照这些设计，就可以在很短的时间里造出不同的东西。如果制造商想要开发某种型号的产品，不需要从头进行设计，或者说重新造轮子，只要遵循那些设计就可以了。用于不同型号产品（车）的不同设计。 丈夫: 你说到点子上了。现在，回到现实里，我们是软件厂商，我们需要根据需求，用不同的组件来创造出不同的软件。在这个过程中，一定会碰到一些情形，是在许多不同的软件里都有的，对不对？ 媳妇: 对啊。而且，我们还常常在不同的软件里碰到相同的设计难题呢。 丈夫: 我们尝试着用一种面向对象的方式来开发我们的软件，利用OOD原则来让我们的代码更容易管理、重用和扩展。就像你上面提到的那些相同的问题，如果我们预先就有一些良好的设计，那是不是很棒呢？媳妇: 是啊，那可以省下大把的时间，而且这样打造的软件质量更好，更容易管理。 丈夫: 没错。还有个好消息，我们并不需要自己造轮子。这么多年以来，遭遇同样问题的人们早已发现了许多很棒的解决方案，而且把它们标准化过了。我们管这些方案叫设计模式。我们要感谢四人帮(GoF)，他们在设计模式: 可重用面向对象软件的基本元素这本书里归纳了23个最基本的设计模式。想知道这四个牛人是谁吗？Erich Gamma、Richard Helm、Ralph Johnson和 John Vlissides。面向对象的设计模式很多，但大家认为这23个模式是其它模式的基础。 媳妇：我能创建一个新模式吗？有可能吗？ 丈夫：当然可以，亲爱的，为什么不行呢？设计模式并不是被科学家发明和创造的东西。他们只是被“发现”而已。也就是说，对任何一个普通的问题场景，肯定会有一些好的设计方案。如果我们能识别出一个能解决某个新问题的面向对象设计，那我们就定义了一个新的设计模式。谁知道呢？如果我们发现一些设计模式，没准儿大家会叫我们“二人帮”呢…哈哈。 媳妇：:) 我们怎么来学习设计模式呢？丈夫: 我始终坚信，通过例子学习是最好的。在我们的学习过程中，我们不会“先理论后实践”，因为我认为这是一种“坏”方法。设计模式不是基于理论发明的。相反，总是先有问题场景，再基于需求和情景不断演化设计方案，最后把一些方案标准化成“模式”。所以，我们讨论每一个设计模式时，要尽量用生活中的真实问题来理解和分析。然后尝试一步步地阐述设计，并以一个能匹配某些模式的设计收尾。设计模式就是这样被发现的，你觉得呢？ 媳妇: 我觉得对我来说，这种方式可能更好使。如果我能通过先分析问题，然后阐述解决方案, 最后得到一个设计模式，我就不用死记那些图形和定义了。就这么办吧。 基础的设计问题和解决方案丈夫: 让我们考虑一下下面的情况:我们的家里都有家用电器（比如电灯和风扇），他们都是由开关控制。 任何时候，你都可以在不改变其他东西的情况下做一些事。你可以在不更换开关的情况下换掉灯泡，也可以在不接触灯泡或者风扇的情况下更换开关，甚至可以在不接触开关的情况下，把灯泡和风扇的开关互换。 家用电器：风扇和灯泡 两种开关（第二个显然比第一个要好看） 媳妇：对啊，这看起来很自然，不是吗？ 丈夫：是的，非常自然，同时也应该这样安排。当不同的事物联系到一起时，他们应该在一个可以变更或者可以替换的系统中以便不相互影响，或者影响尽可能的小。这样让你更为方便、成本最小地去管理你的系统。可以想象，如果你要换一个你房间里的灯泡得要求你把开关也换了，你会考虑在你房子里使用这样的一个系统吗？ 媳妇：当然不会。 丈夫：现在，让我们想一下电灯或者电风扇是怎样和开关联系起来以便更换其中一个而不会影响到其他的。你想到什么了？ 媳妇：当然是电线啦。丈夫：正确，是电线以及其他的电工手段把电灯/电风扇与开关连接起来。我们可以把这概括为沟通不同系统的桥梁。基本思想是，一个事物不能直接连接另一个事物。当然，他们能够通过一些桥梁或接口连接起来。在软件世界里，我们称之为“松耦合”。 媳妇：嗯，我明白这点。丈夫：现在，我们来尝试理解一些类似电灯/电风扇与开关类似的关键问题，同时尝试理解是怎样设计和关联它们的。媳妇：好的，我们开始吧。在我们的列子里，有一些开关，这些类似普通的开关、有不同的花式开关可能有不同的种类，但是，一般情况下，他们就是开关。同时，每个开关都能开和关。这样的话，我们就会得到如下的Switch基类： 12345678public class Switch &#123; public void On() &#123; //Switch has an on button &#125; public void Off() &#123; //Switch has an off button &#125;&#125; 同时，我们可能也 需要一些特定类型的开关，譬如正常的开关、不同花式的开关等等。同样的我们扩展Switch类来实现FancySwitch和NormalSwitch： 123456public class NormalSwitch extends Switch&#123; &#125; public class FancySwitch extends Switch&#123; &#125; 这两个特定的开关类可能用于它们自己特有的行为和特征，但是到目前为止，我们还是保持它们现在的简单形式。 丈夫：棒极了。现在，如何处理风扇和灯呢？ 媳妇：让我试试。按照面向对象设计原则中的封闭原则，我认为我们需要试着在任何可能的地方做抽象处理，对吗？ 丈夫：对。 媳妇: 电扇和电灯情况有点不一样，它们两个不是同一种东西。对于不同的开关，我们可以用同一个基本的Switch类，但对于电扇和电灯就不大合适了，感觉用接口会更合适一点。因为，从大体上讲，它们都算是电器，那么我们可以就定义一个接口: IElectricalEquipment，用它来抽象电扇和电灯，对不对？ 丈夫: 很对。 媳妇: 那么，所有电器都有一些共性，可以被打开和关闭。那么这个接口就可以是: 1234public interface IElectricalEquipment&#123; void PowerOn(); // Each electrical equipment can be turned on void PowerOff(); // Each electrical equipment can be turned off&#125; 媳妇: 没错，开关并不知道电扇和电灯的存在。它只知道它可以打开或关闭某个电器IElectricalEquipment。那么，也就是说每个Switch应该拥有一个IElectricalEquipment实例，是吧？ 丈夫: 没错。你的抽象能力很强呀，媳妇。好了，现在我们还缺一座桥。在现实世界里，桥是电线。在对象的世界里，开关知道怎么开关电器，电器需要用某种方式跟开关连起来。可这里没有电线，我们唯一有的，是封装。 丈夫: 很对。这里，被封装的实例，也就是IElectricalEquipment，就是这座桥。好，我们来修改一下Switch类，让它把电器封装进去: 12345678910public class Switch &#123; public IElectricalEquipment equipment; public void On() &#123; // Switch has an on button &#125; public void Off() &#123; // Switch has an off button &#125;&#125; 媳妇: 我懂了。接下来我再定义真正的电器吧。电扇和电灯，总体上都是电器，所以它们应该实现IElectricalEquipment接口。 12345678910111213141516171819// 电扇类:public class Fan implements IElectricalEquipment&#123; public void PowerOn() &#123; System.out.println(\"Fan is on\"); &#125; public void PowerOff() &#123; System.out.println(\"Fan is off\"); &#125;&#125;// 电灯类:public class Light implements IElectricalEquipment&#123; public void PowerOn() &#123; System.out.println(\"Light is on\"); &#125; public void PowerOff() &#123; System.out.println(\"Light is off\"); &#125;&#125; 丈夫: 很好。现在该是接上开关的时候了。开关在打开和关闭的时候，必须能打开和关闭它所连接的电器。也就是说:当按下开关的打开按钮时，必须打开连接的电器。当按下开关的关闭按钮时，必须关闭连接的电器。我们想要的功能基本上是这个样子: 12345678910111213141516171819202122public static void main(String[] args)&#123; // We have some electrical equipments, say Fan, Light etc. // So, lets create them first. IElectricalEquipment fan = new Fan(); IElectricalEquipment light = new Light(); // We also have some switches. Lets create them too. Switch fancySwitch = new FancySwitch(); Switch normalSwitch = new NormalSwitch(); // Lets connect the Fan to the fancy switch fancySwitch.equipment = fan; // As the switch now has an equipment (Fan), // so switching on or off should turn on or off the electrical equipment fancySwitch.On(); // It should turn on the Fan. // so, inside the On() method of Switch, we must turn on the electrical equipment. // It should turn off the Fan. So, inside the On() method of fancySwitch.Off(); // Switch, we must turn off the electrical equipment // Now, lets plug the light to the fancy switch fancySwitch.equipment = light; fancySwitch.On(); //It should turn on the Light now fancySwitch.Off(); //It should be turn off the Light now&#125; 媳妇: 明白了。那么，开关的On()方法应该调用电器的TurnOn()方法，而它的Off()方法应该调用电器的TurnOff()方法，Switch类应该是这个样子: 12345678910public class Switch &#123; public void On() &#123; System.out.println(\"Switch on the equipment\"); equipment.PowerOn(); &#125; public void Off() &#123; System.out.println(\"Switch off the equipment\"); equipment.PowerOff(); &#125;&#125; 丈夫: 干得好。这个电扇显示是可以换开关的。而且，反过来也是可以换的，可以不修改电扇和电灯，直接更换开关，例如，我们可以把电灯的开关从FancySwitch换成NormalSwitch: 12normalSwitch .equipment = light;normalSwitch.On(); // It should turn on the LightnownormalSwitch.Off(); // It should be turn off the Light now 看到没，我们可以在不影响任何一方的情况下，改变另一方。这个设计看起来很不错，而且相当的优雅。其实四人帮管这个设计叫桥梁模式。 媳妇：酷！我懂了。一般来说，两个系统不应该直接地互相联接和依赖。相反，他们应该通过抽象来联接或依赖（正如依赖倒置和开闭原则所言），这样它们就是松耦合的，我们就可以在必要时轻松地修改实现，而不对系统的其它部分造成太大影响。 丈夫：亲爱的，你得我真传了。我们来看一下桥接模式的定义吧： ​ 把抽象和实现解耦，使得它们可以独立地变化我们的设计完全符合定义。如果你有类设计器（Visual Studio和其它流行的IDE都有这功能），你能看到一个和下图相似的类图： 在我们的例子里，Abstraction是基础的Switch类，RefinedAbstraction是某个具体的开关类（FancySwitch和NormalSwitch），Implementor是IElectricalEquipment接口，ConcreteImplementorA和ConcreteImplementorB分别是Fan和Light类。 媳妇: 我有点好奇。你不是说有很多模式么，干嘛先说桥梁模式呢？有什么特别重要的原因吗？ 丈夫: 问得好。我从桥梁模式开始，而不是其它模式，只有一个原因。我觉得它是所有面向对象设计模式的基础。因为: 它能教你如何抽象地思维，这可是OO设计模式的关键。 它实现了基本的OOD原则。 它很好理解。 如果你能正确地理解它，学习其它模式就易如反掌了。 媳妇**:** 你觉得我理解的对么？ 丈夫: 哦~亲爱的，我觉得你理解的非常好。 媳妇: 那么，下一步呢？ 丈夫: 通过了解桥接模式，我们才稍微的了解了设计模式的概念。在我们接下来的谈话中，我们将会学习其他的涉及模式，希望你不会觉得它们无聊。 媳妇: 不会的，相信我。 请关注我们的下一次谈话:) 在原文中代码是使用 C++ 写的, 考虑到我亲爱的同学们可能更熟悉 Java, 所以我把代码部分改成了 Java 语法. 本文转自开源中国社区 http://www.oschina.net/translate/how-i-explained-design-patterns-to-my-wife-part-1?from=20130113 英文原文：http://www.codeproject.com/Articles/98598/How-I-explained-Design-Patterns-to-my-wife-Part-1 参与翻译(8人)： AlfredCheung, SeabornLee, throwable, Claymore, 不是小白, Naixjs, 铂金小龟, Tocy","categories":[{"name":"编程思想","slug":"编程思想","permalink":"https://baileykm.github.io/categories/编程思想/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://baileykm.github.io/tags/设计模式/"}]},{"title":"Web工作原理简述","slug":"WEB工作原理简述","date":"2013-02-25T17:47:22.000Z","updated":"2019-05-09T13:47:36.786Z","comments":true,"path":"2013/02/26/WEB工作原理简述/","link":"","permalink":"https://baileykm.github.io/2013/02/26/WEB工作原理简述/","excerpt":"作为一名想学习网站开发, 或者更专业一点说叫 “B/S体系结构软件开发 / Web 应用程序开发” 的同学来说, 可能首先想到的是学习各种前端技术, 例如: HTML, CSS, Javascript……, 以及各种动态网站开发技术, 如: ASP, ASP.NET, JSP, PHP…… . 但是, 在你开始之前, 请稍安勿躁, 了解一下网站是如何工作的往往是一件”磨刀不误砍柴工”的事情.","text":"作为一名想学习网站开发, 或者更专业一点说叫 “B/S体系结构软件开发 / Web 应用程序开发” 的同学来说, 可能首先想到的是学习各种前端技术, 例如: HTML, CSS, Javascript……, 以及各种动态网站开发技术, 如: ASP, ASP.NET, JSP, PHP…… . 但是, 在你开始之前, 请稍安勿躁, 了解一下网站是如何工作的往往是一件”磨刀不误砍柴工”的事情. 曾经接触过一些公司里刚入职的程序员, 往往会犯一些比较低级的错误而百思不得其解, 其实就是入门时的基础没有打好. 因此, 这里我们就简单来了解一下Web工作原理. ​ 先上个图……本人比较懒, 所以就借用了别人做好的图, 还望原作者本着人道主义的精神不要追究我的责任. 上图使用了一些相对专业的术语来描述了我们平时上网的一个过程. 简单来说就是我们上网的那台设备 (通常称为”客户端”, 可以是电脑/手机或别的东东) 上面安装的浏览器 (IE, Firefox, Chrome, Opera, Safari……) 作为我们的一个代理向网站服务器发送请求 (Request), 网站服务器接收到请求后, 对请求中包含的信息进行解析, 进行一些处理后把处理的结果以响应 (Response) 的形式返回给浏览器, 最后浏览器解析返回的数据包并将其转化成一个可视化的界面, 就是我们看到的网页. 上网的过程大概也就是一个上述过程的循环. ​ 其中, 一些术语和细节解释一下: (1) 什么是URL? “全球资源定位器 ( Uniform Resource Locator ). 真的好专业, 挺能唬人, 呵呵~ 简单来说, 就是用来描述Internet上的某一个资源所在位置的一个字符串, 比如我们平时说的网址, 当然也可以是Internet上的一张图片, 一个视频或其它东东. 根据URL计算机至少可以得到2个信息: (a) 资源所在的服务器的地址; (b) 资源在服务器上的存放路径. (2) 什么是HTTP协议? 超文本传输协议 ( Hyper-Text Transport Protocol ). 呵呵, 还是好专业…… 好吧, 简单点说, 就是一种计算机之间传输数据所遵循的协议, 这里所说的协议其实是一种通信双方必须遵守的一些规范. 计算机会把要传输的数据封装成一个叫做”数据包”的东东, 协议规定了这个”数据包”里应该有些什么信息, 这些信息分别应该放在什么位置, 等等. HTTP 协议是众多协议中的一种, 它详细规定了浏览器与网站服务器之间进行数据传输的规范. 具体HTTP协议里规定了些什么东东? 感兴趣的同学可以查一下别的资料. 但可以想到里面肯定包含了收发方的地址信息和我们要传输的数据主体. (3) 遵循HTTP协议封装的数据还要经过更低层的一些协议封装, 最后通过物理链路传输到服务器. 这就不解释了, 再解释就天亮了…… 感兴趣的, 可以看看计算机网络, OSI 模型之类的东东 (4) 服务器收到HTTP请求之后干什么呢? 大体来说, 3件事: (a) 找到你要的东西; (b) 进行一些应该在服务器端完成的处理, 比如: 执行服务器端脚本. 当然这一步并非对所有请求都是必须的; (c) 把处理结果封装成HTTP协议描述的数据包, 返回给客户端. (5) 浏览器收到服务器返回的响应之后, 解析得到的数据, 将其转化成一个图形化的界面, 就是我们看到的网页. 当然, 如果其中还包含 javascript 之类的脚本, 浏览器还会执行它…… ​ 接下来干什么呢? 输入另一个网址, 继续上网呗, 呵呵~ 当然, “输入”这个词不太准确, 我们不会老是去地址栏输网址吧…… “输入”的方式还可以是点击网页中的一个超链接或是提交网页中的一个表单 (比如: 发帖子的时候, 在输入框里写好的要发的信息后点击”发送”按钮) . 还有别的方式吗? 也许, 但暂时想不到了…… ​ OK, 现在大概有点感觉了吧…… ​ ​ 下面有几点友情提醒一下, 省得今后做傻事…… 若你刚开始学习 Web 应用程序开发, 以下部分内部可能暂时理解不了, 那就直接跳过, 等将来有一定开发经验了再回来看… (1) 网站是工作在”两端”的 (服务器端和客户端), 即使有些情况下(比如: 开发阶段) 服务器端和客户端可能是同一台电脑, 但应该在服务器端和客户端执行的任务也是运行在完全隔离的进程或内存空间里的. 所以, 千万别干诸如在客户端脚本中读写服务器端脚本中变量的傻事!! 看不懂? 呵呵, 继续往下看就懂了…… (2) 服务器端除了接收请求和返回响应之外, 可能还会进行一些处理工作. 比如, 执行我们使用ASP/JSP技术做动态网站时候写在&lt;% %&gt; 中的代码, 这通常称为服务器端脚本. 当然, 服务器可能还会做更多事情, 比如: 读写数据库, 执行程序等等. 但无论如何, 服务器端无法直接操纵客户端, 它只能通过”间接”的方式, 比如: 在返回的响应中嵌入客户端脚本或指令, 由浏览器解释执行, 从而达到操纵客户端的目的. (3) 服务器端返回的只有数据或”静态网页”, 没有”服务器端脚本”或”服务器端变量”. 即便要将服务器端内存中某个变量的值传给客户端, 也要经过所谓的”序列化”过程, 转换成数据流才能到达客户端. 所以, 千万别想着把一个服务器端对象直接开放给客户端来读写. (4) 对于浏览器而言无论它多么高档, 作为最基本的功能, 它处理的就是 HTML, CSS 和 Javascript, 至于其它的…… 比如: 播放Flash, 那就只能靠第三方的插件 或 浏览器生产商提供的一些扩展了. 所以, 别想着在浏览器里直接执行 Java 代码, 呵呵, 至少目前还不行. (5) 客户端可以是电脑, 手机或别的东东. 服务器端也不一定就是多么高档的一台机器, 它也可能就是一个单片机或嵌入式系统. 无论什么设备, 只要它能接收HTTP请求, 返回HTTP响应那也就可以称作”WEB服务器”. 想想你进入路由器设置的那个界面, 呵呵~ (6) HTTP 和 HTML没有必然的联系! HTTP是一种通信协议, 而HTML是用来告诉浏览器网页内容的一种编程语言. 通过HTTP协议传输的不一定非得是HTML文档, 也可以是”纯数据”, 在使用Ajax技术时大多数情况下从服务器返回的仅是数据而已, 并非完整的HTML文档. 当然, 还可以想到…… 可以使用HTTP协议传输文件. (7) 无论客户端和服务器端是多少庞大和复杂的一个系统, 最终将它们联系起来的只是HTTP协议描述的信息. 呵呵, 一切都将被转换为最朴素的数据流. (8) 从上面的图可以看出, 整个工作过程的”起始点”是由客户端发起”请求”, 服务器端是”被动”地响应. 所以, 基于 HTTP 协议, 通过一般的手段是无法由服务器端主动把数据”推送”给客户端的. 那不一般的手段是什么呢? 呵呵, 比如, 使用的 “轮询” 或 “捎带” 机制, 再比如使用 Websocket 协议. (9) 客户端和服务器端谁多干点活, 究竟那一些该 “胖 (fat)” 些 或 “富 (rich)” 一些, 这是个永恒的话题, 没有绝对的结论. 但无论如何不应该让HTTP数据包胖起来, 也就是说, 尽可能地减少在客户端和服务器端之间传输的数据量和传输的次数. ​ 好吧, 暂时就想到这么多了……","categories":[{"name":"入门教程","slug":"入门教程","permalink":"https://baileykm.github.io/categories/入门教程/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baileykm.github.io/tags/Web/"}]}]}